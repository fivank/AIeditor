<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>VoiceNotes AI Manager</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Typography -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel para JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>

    <style>
        :root {
            --color-bg: #f7f9fc;
            --color-card: #ffffff;
            --radius-lg: 0.9rem;
            --radius-xl: 1.25rem;
            --primary-color: #4f46e5;
            --secondary-color: #7c3aed;
            --accent-color: #f59e0b;
            --danger-color: #ef4444;
            --success-color: #22c55e;
            --shadow: 0 14px 32px rgba(36, 42, 66, 0.12);
            --shadow-strong: 0 18px 46px rgba(36, 42, 66, 0.18);
            --gradient-aurora: radial-gradient(circle at 20% 20%, rgba(79, 70, 229, 0.22), transparent 32%),
                radial-gradient(circle at 82% 16%, rgba(236, 72, 153, 0.14), transparent 26%),
                radial-gradient(circle at 45% 70%, rgba(34, 197, 94, 0.14), transparent 26%),
                linear-gradient(145deg, #eef2ff 0%, #f9fafb 40%, #ffffff 100%);
            --card-background: #ffffff;
            --text-color: #0f172a;
            --border-radius: 1.2rem;
        }

        /* Estilos base y utilidades */
        body {
            font-family: 'Roboto', 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: var(--color-bg);
            color: var(--text-color);
            margin: 0;
            line-height: 1.6;
            -webkit-tap-highlight-color: transparent;
            position: relative;
            min-height: 100vh;
        }

        body::after,
        body::before {
            content: "";
            position: fixed;
            inset: 0;
            pointer-events: none;
            background: none;
            z-index: -3;
        }

        .safe-top {
            padding-top: env(safe-area-inset-top, 0);
        }
        .safe-bottom {
            padding-bottom: env(safe-area-inset-bottom, 0);
        }

        .card {
            background: linear-gradient(145deg, rgba(255,255,255,0.9), rgba(250, 251, 255, 0.95));
            border-radius: var(--border-radius);
            border: 1px solid #e5e7f9;
            box-shadow: var(--shadow);
            transition: transform 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease, background 0.3s ease;
        }

        .card:hover {
            transform: translateY(-3px);
            box-shadow: var(--shadow-strong);
            border-color: rgba(79, 70, 229, 0.25);
            background: linear-gradient(145deg, rgba(255,255,255,1), rgba(239, 246, 255, 0.94));
        }

        .card-tap {
            transition: transform 0.12s ease, box-shadow 0.12s ease, border-color 0.12s ease;
        }
        .card-tap:active {
            transform: scale(0.98);
            box-shadow: 0 4px 12px rgba(15, 23, 42, 0.08);
        }

        .icon-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 9999px;
            padding: 0.35rem;
            font-size: 0.75rem;
            color: var(--primary-color);
            background: rgba(79, 70, 229, 0.08);
            border: 1px solid rgba(79, 70, 229, 0.12);
            transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.2s ease, color 0.2s ease;
        }
        .icon-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 14px rgba(33, 41, 64, 0.14);
            background: rgba(79, 70, 229, 0.14);
            color: #312e81;
        }
        .icon-btn-sm {
            padding: 0.25rem;
        }

        /* Animación de carga */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Animación de grabación */
        .pulse-ring {
            box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
            animation: pulse-red 1.5s infinite cubic-bezier(0.66, 0, 0, 1);
        }
        @keyframes pulse-red {
            to { box-shadow: 0 0 0 15px rgba(239, 68, 68, 0); }
        }

        /* Scrollbar bonita */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        
        .glass-panel {
            background: linear-gradient(120deg, rgba(255,255,255,0.9), rgba(255,255,255,0.82)) padding-box,
                        linear-gradient(120deg, rgba(63,81,181,0.35), rgba(121,134,203,0.25)) border-box;
            border: 1px solid transparent;
            box-shadow: 0 14px 32px rgba(33, 41, 64, 0.14);
            backdrop-filter: blur(14px);
        }

        .app-surface {
            background: var(--color-bg);
        }

        .section-title {
            color: var(--primary-color);
            font-weight: 800;
            letter-spacing: -0.01em;
        }

        .pill-button {
            border-radius: 9999px;
            font-weight: 700;
            transition: transform 0.15s ease, box-shadow 0.2s ease, background 0.2s ease;
        }

        .content-shell {
            background: rgba(255, 255, 255, 0.92);
            border-radius: 1.5rem;
            border: 1px solid rgba(226, 232, 240, 0.8);
            box-shadow: 0 20px 50px rgba(15, 23, 42, 0.08);
            backdrop-filter: blur(8px);
        }

        .section-card {
            background: linear-gradient(180deg, rgba(255,255,255,0.95), rgba(245, 248, 255, 0.95));
            border-radius: 1rem;
            border: 1px solid #e6e8f5;
            box-shadow: 0 16px 30px rgba(15, 23, 42, 0.08);
        }

        .tag-chip {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.35rem 0.65rem;
            border-radius: 999px;
            font-weight: 600;
            font-size: 0.75rem;
            background: rgba(79, 70, 229, 0.08);
            color: #4338ca;
            border: 1px solid rgba(79, 70, 229, 0.18);
        }

        .pill-button:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 12px 26px rgba(33, 41, 64, 0.16);
        }

        .pill-button:active:not(:disabled) {
            transform: scale(0.98);
        }

        .primary-cta {
            background: var(--primary-color);
            color: white;
            box-shadow: 0 12px 26px rgba(63, 81, 181, 0.28);
            border: 1px solid rgba(63, 81, 181, 0.25);
        }

        .primary-cta:hover:not(:disabled) {
            background: #303f9f;
        }

        .secondary-cta {
            background: rgba(255, 152, 0, 0.14);
            color: #c05621;
            border: 1px solid rgba(255, 152, 0, 0.35);
            box-shadow: 0 10px 20px rgba(255, 152, 0, 0.15);
        }

        .floating-bar {
            background: linear-gradient(135deg, rgba(255,255,255,0.95), rgba(239, 246, 255, 0.9));
            border: 1px solid rgba(79, 70, 229, 0.18);
            box-shadow: 0 22px 48px rgba(15, 23, 42, 0.2);
            backdrop-filter: blur(14px);
        }
        }

        /* Estilos del editor y visualización de notas */
        .editor-content,
        .editor-content * {
            word-break: break-word;
            overflow-wrap: anywhere;
        }
        .editor-content h1 {
            font-size: 22px;
            font-weight: 800;
            color: #1f2937;
            margin: 0 0 0.5rem;
        }
        .editor-content h2 {
            font-size: 18px;
            font-weight: 800;
            color: #111827;
            text-decoration: underline;
            margin: 0 0 0.4rem;
        }
        .editor-content p,
        .editor-content li {
            font-size: 16px;
            line-height: 1.65;
        }
        .editor-content ul {
            list-style-type: disc;
            padding-left: 1.25rem;
            margin: 0.25rem 0 0.5rem;
        }
        .editor-content ol {
            list-style-type: decimal;
            padding-left: 1.25rem;
            margin: 0.25rem 0 0.5rem;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useMemo } = React;

        // --- ICONOS SVG ---
        const Icons = {
            GenAI: () => (
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.6" strokeLinecap="round" strokeLinejoin="round">
                    <path d="M19 3h-2v2h-2v2h2v2h2V7h2V5h-2z" />
                    <path d="M5 4H3v2H1v2h2v2h2V8h2V6H5z" />
                    <path d="M11 9.5 9.5 13.5 6 14.8l3.5 1.3L11 20l1.5-3.9L16 16.1l-3.5-1.3Z" fill="currentColor" stroke="none" />
                    <path d="M14.5 5.5 13 8l2.5 1.5L18 8l-2.5-1.5Z" />
                </svg>
            ),
            Grid: () => (
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.8" strokeLinecap="round" strokeLinejoin="round">
                    <rect x="4" y="4" width="7" height="7" rx="1.5" />
                    <rect x="13" y="4" width="7" height="7" rx="1.5" />
                    <rect x="4" y="13" width="7" height="7" rx="1.5" />
                    <rect x="13" y="13" width="7" height="7" rx="1.5" />
                </svg>
            ),
            Book: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></svg>,
            Folder: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg>,
            Mic: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>,
            Settings: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.72v-.51a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>,
            ChevronLeft: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="15 18 9 12 15 6"/></svg>,
            Plus: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>,
            Pencil: () => (
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                    <path d="M12 19l9-9" />
                    <path d="M15 6l3 3" />
                    <path d="M3 21l3-0.5 8.5-8.5-2.5-2.5L3 18z" />
                </svg>
            ),
            Wand: () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M15 4V2"/><path d="M15 16v-2"/><path d="M8 9h2"/><path d="M20 9h2"/><path d="M17.8 11.8 19 13"/><path d="M15 9h0"/><path d="M17.8 6.2 19 5"/><path d="M3 21l9-9"/><path d="M12.2 6.2 11 5"/></svg>,
            Merge: () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m8 6 4-4 4 4"/><path d="M12 2v10.3"/><path d="M12 12.3v9.3"/><path d="m8 18 4 4 4-4"/></svg>,
            Link: () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l2.92-2.92a5 5 0 0 0-7.07-7.07l-1.43 1.43" /><path d="M14 11a5 5 0 0 0-7.54-.54l-2.92 2.92a5 5 0 1 0 7.07 7.07l1.43-1.43" /></svg>,
            Trash: () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>,
            Check: () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="20 6 9 17 4 12"/></svg>,
            Alert: () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>,
            Menu: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/></svg>,
            Sort: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m3 16 4 4 4-4"/><path d="M7 20V4"/><path d="m21 8-4-4-4 4"/><path d="M17 4v16"/></svg>,
            Cloud: () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M17.5 19H9a5 5 0 1 1 .9-9.9A7 7 0 0 1 21 12a4 4 0 0 1-3.5 7Z"/></svg>
        };

        // --- CONFIGURACIÓN INICIAL ---
        const DEFAULT_API_KEY = "";
        const DEFAULT_MODEL = "gemini-2.0-flash-exp";
        const DEFAULT_PROMPTS = {
            merge: "Combina las siguientes notas en un único texto coherente, bien estructurado y resumido. Usa Markdown para dar formato si es necesario.",
            style: "Reescribe el siguiente contenido aplicando estrictamente el siguiente estilo o tono: {STYLE}. Mantén la información original pero cambia la forma de expresarla.",
            generate: "Crea una nota nueva usando el siguiente contexto. Respeta el idioma y el nivel de detalle del material."
        };
        const DEFAULT_SPEECH_CONFIG = {
            preferredEngine: 'browser',
            aiAssistEnabled: true,
            languagePreferences: {}
        };
        const DEFAULT_COLLECTION = {
            id: 'uncollected',
            name: 'Sin colección',
            description: 'Libros sin colección'
        };
        const TEMP_CHAPTER_TITLE = 'temporary';
        const TEMP_BOOK_TITLE = 'temp notes';
        const FIRESTORE_COLLECTION = 'voiceNotes_appData';
        const LOCAL_USAGE_KEY = 'voiceNotes_lastUse';
        const FIRESTORE_SYNC_KEY = 'voiceNotes_lastFirestoreSync';
        const SESSION_KEY = 'voiceNotes_sessionId';
        const LOCAL_COLLECTIONS_KEY = 'voiceNotes_collections';
        const LOCAL_LIBRARY_VIEW_KEY = 'voiceNotes_libraryView';
        const LOCAL_COLLECTION_VIEW_KEY = 'voiceNotes_collectionViewMode';
        const LOCAL_ACTIVE_COLLECTION_KEY = 'voiceNotes_activeCollectionId';
        const LOCAL_LIBRARY_SORT_KEY = 'voiceNotes_librarySort';
        const LOCAL_RECENCY_WINDOW_MS = 5 * 60 * 1000; // 5 minutos
        const AUTO_FIRESTORE_SAVE_DELAY = 2 * 60 * 1000; // 2 minutos

        const firebaseConfig = {
            apiKey: "AIzaSyA-wfyW4A1x0OhlBnnPhN2xwgs8N0e_3ek",
            authDomain: "smartbookwriter-f6dd5.firebaseapp.com",
            projectId: "smartbookwriter-f6dd5",
            storageBucket: "smartbookwriter-f6dd5.firebasestorage.app",
            messagingSenderId: "924785765286",
            appId: "1:924785765286:web:42b733d5914b095bbf7d67"
        };

        const ensureBookTimestamps = (book, now = Date.now()) => {
            const createdAt = book.createdAt || book.timestamp || now;
            const updatedAt = book.updatedAt || createdAt;
            return { ...book, createdAt, updatedAt };
        };

        const touchBook = (book, now = Date.now()) => ({ ...ensureBookTimestamps(book, now), updatedAt: now });

        const normalizeBooksData = (bookList = []) => bookList.map(b => ({
            ...ensureBookTimestamps(b),
            collectionId: b.collectionId || DEFAULT_COLLECTION.id,
            notes: b.notes || [],
            chapters: (b.chapters || []).map(c => ({ ...c, notes: c.notes || [] }))
        }));

        const detectSpeechEngines = () => {
            const ua = navigator?.userAgent?.toLowerCase?.() || '';
            const hasWebSpeech = ('webkitSpeechRecognition' in window) || ('SpeechRecognition' in window);
            const isAndroid = ua.includes('android');
            const isIOS = ua.includes('iphone') || ua.includes('ipad') || ua.includes('ipod');
            const hasKeyboardDictation = isAndroid || isIOS;
            const mediaDevicesAvailable = !!navigator?.mediaDevices?.getUserMedia;

            return [
                {
                    id: 'browser',
                    label: 'Motor del navegador',
                    description: 'Usa la API nativa de SpeechRecognition del navegador.',
                    available: hasWebSpeech,
                    languages: [
                        { code: 'es-ES', label: 'Español (España)' },
                        { code: 'en-US', label: 'Inglés (EE.UU.)' },
                        { code: 'fr-FR', label: 'Francés' }
                    ]
                },
                {
                    id: 'android',
                    label: 'Predeterminado de Android',
                    description: 'Dictado del sistema en dispositivos Android.',
                    available: isAndroid,
                    languages: [
                        { code: 'es-MX', label: 'Español (Latam)' },
                        { code: 'en-GB', label: 'Inglés (UK)' },
                        { code: 'pt-BR', label: 'Portugués (Brasil)' }
                    ]
                },
                {
                    id: 'keyboard',
                    label: 'Dictado del teclado',
                    description: 'Usa el botón de micrófono del teclado en pantalla.',
                    available: hasKeyboardDictation,
                    languages: [
                        { code: 'es-ES', label: 'Español' },
                        { code: 'en-US', label: 'Inglés' },
                        { code: 'it-IT', label: 'Italiano' }
                    ]
                },
                {
                    id: 'handsfree',
                    label: 'Manos libres / auriculares',
                    description: 'Captura audio desde un dispositivo conectado (auriculares o coche).',
                    available: mediaDevicesAvailable,
                    languages: [
                        { code: 'es-ES', label: 'Español' },
                        { code: 'en-US', label: 'Inglés' }
                    ]
                },
                {
                    id: 'ai-assisted',
                    label: 'AI assisted speech-to-text',
                    description: 'Usa la IA para limpiar y completar dictados ruidosos.',
                    available: true,
                    languages: [
                        { code: 'multi', label: 'Multi idioma (auto)' }
                    ]
                }
            ];
        };

        const resolvePreferredLanguages = (engineId, engines, languagePreferences = {}) => {
            const engine = engines.find((eng) => eng.id === engineId);
            const preferred = languagePreferences?.[engineId];
            if (preferred && preferred.length > 0) return preferred;
            if (engine?.languages?.length > 0) return engine.languages.map((lang) => lang.code);
            return [];
        };

        const resolveRecognitionConfig = (speechEngines, speechSettings) => {
            const engines = speechEngines || [];
            const preferredEngineId = speechSettings?.preferredEngine;
            const preferredEngine = engines.find((engine) => engine.id === preferredEngineId);
            const fallbackEngine = engines.find((engine) => engine.id === 'browser' && engine.available)
                || engines.find((engine) => engine.available)
                || engines[0];

            const engineForRecognition = preferredEngine && (preferredEngine.available || preferredEngine.id === 'ai-assisted')
                ? preferredEngine
                : fallbackEngine;

            const resolvedLanguages = resolvePreferredLanguages(
                engineForRecognition?.id,
                engines,
                speechSettings?.languagePreferences
            );

            const primaryLanguage = resolvedLanguages[0];
            return {
                engine: engineForRecognition,
                language: primaryLanguage,
                languages: resolvedLanguages
            };
        };

        const generateId = () => Date.now().toString(36) + Math.random().toString(36).substr(2);
        const moveItem = (array, from, to) => {
            const arr = [...array];
            const [item] = arr.splice(from, 1);
            arr.splice(to, 0, item);
            return arr;
        };
        const matchTitle = (value, target) => (value || '').trim().toLowerCase() === target;
        const isPreliminaryChapterTitle = (title) => ['preliminary', 'preliminar', TEMP_CHAPTER_TITLE].some(t => matchTitle(title, t));
        const cloneNote = (note) => ({ ...note, id: generateId(), timestamp: Date.now() });
        const escapeHtml = (text) => text.replace(/[&<>"]/g, (c) => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;' }[c]));
        const normalizeContent = (content) => {
            if (!content || typeof content !== 'string') return '<p></p>';
            const trimmed = content.trim();
            const looksLikeHtml = /<[^>]+>/.test(trimmed);
            if (looksLikeHtml) return trimmed;
            return `<p>${escapeHtml(trimmed).replace(/\n/g, '<br>')}</p>`;
        };

        const ensureCollectionsWithDefault = (collections = []) => {
            const sanitized = (collections || []).filter(c => c && c.id && c.name);
            const hasDefault = sanitized.some(c => c.id === DEFAULT_COLLECTION.id);
            return hasDefault ? sanitized : [DEFAULT_COLLECTION, ...sanitized];
        };

        const toPlainText = (html) => {
            if (!html) return '';
            return html
                .replace(/<style[\s\S]*?>[\s\S]*?<\/style>/gi, ' ')
                .replace(/<script[\s\S]*?>[\s\S]*?<\/script>/gi, ' ')
                .replace(/<[^>]+>/g, ' ')
                .replace(/&nbsp;/g, ' ')
                .replace(/\s+/g, ' ')
                .trim();
        };

        const isValidHttpUrl = (text) => {
            try {
                const url = new URL(text.trim());
                return ['http:', 'https:'].includes(url.protocol);
            } catch (e) {
                return false;
            }
        };

        const shortenUrl = (url) => {
            try {
                const u = new URL(url);
                const host = u.hostname.replace(/^www\./, '');
                const path = u.pathname.replace(/\/$/, '');
                const compactPath = path && path !== '/' ? path : '';
                const finalPath = compactPath.length > 28 ? `${compactPath.slice(0, 28)}…` : compactPath;
                return `${host}${finalPath ? `/${finalPath}` : ''}`;
            } catch (e) {
                return url;
            }
        };

        const getYoutubeThumbnail = (url) => {
            const host = url.hostname.replace(/^www\./, '');
            if (host === 'youtu.be') {
                const id = url.pathname.replace('/', '');
                return id ? `https://img.youtube.com/vi/${id}/hqdefault.jpg` : null;
            }
            if (host.includes('youtube.com')) {
                const id = new URLSearchParams(url.search).get('v');
                return id ? `https://img.youtube.com/vi/${id}/hqdefault.jpg` : null;
            }
            return null;
        };

        const fetchLinkMetadata = async (rawUrl) => {
            const url = new URL(rawUrl.trim());
            let title = '';
            let thumbnail = getYoutubeThumbnail(url);
            try {
                const jinaResponse = await fetch(`https://r.jina.ai/${url.href}`);
                if (jinaResponse.ok) {
                    const text = await jinaResponse.text();
                    const foundTitle = text.match(/<title>(.*?)<\/title>/i)?.[1];
                    const ogImage = text.match(/property="og:image" content="(.*?)"/i)?.[1]
                        || text.match(/property='og:image' content='(.*?)'/i)?.[1];
                    if (foundTitle) title = foundTitle;
                    if (!thumbnail && ogImage) thumbnail = ogImage;
                }
            } catch (e) {
                console.warn('No se pudo extraer metadata del enlace', e);
            }

            if (!thumbnail) {
                const favIcon = `https://www.google.com/s2/favicons?sz=128&domain_url=${url.origin}`;
                thumbnail = favIcon;
            }

            const displayUrl = shortenUrl(url.href);
            const fallbackTitle = title?.trim() || url.hostname.replace(/^www\./, '');
            return { title: fallbackTitle, thumbnail, displayUrl };
        };

        const buildLinkNote = async (rawUrl) => {
            const normalizedUrl = rawUrl.trim();
            if (!isValidHttpUrl(normalizedUrl)) throw new Error('No se encontró una URL válida en el portapapeles.');
            const metadata = await fetchLinkMetadata(normalizedUrl);
            return {
                id: generateId(),
                type: 'link',
                url: normalizedUrl,
                meta: metadata,
                content: normalizeContent(metadata.title || metadata.displayUrl || normalizedUrl),
                timestamp: Date.now()
            };
        };
        const buildDestinations = (books, source) => {
            const options = [];

            const tempBook = books.find(b => matchTitle(b.title, TEMP_BOOK_TITLE));
            const tempChapter = tempBook?.chapters.find(c => isPreliminaryChapterTitle(c.title));
            const isFromTempPreliminary = source?.type === 'chapter' && tempBook && source.bookId === tempBook.id && source.chapterId === tempChapter?.id;

            const addChapterOption = (book, chapter) => {
                if (!chapter) return;
                if (options.some(opt => opt.chapterId === chapter.id)) return;
                options.push({ label: `${book.title} → ${chapter.title}`, type: 'chapter', bookId: book.id, chapterId: chapter.id });
            };

            const addTempChapterFromOtherBooks = (currentBookId) => {
                books
                    .filter(book => book.id !== currentBookId)
                    .forEach(book => {
                        const preliminary = book.chapters.find(ch => isPreliminaryChapterTitle(ch.title));
                        addChapterOption(book, preliminary);
                    });
            };

            if (isFromTempPreliminary) {
                tempBook?.chapters.forEach(chapter => addChapterOption(tempBook, chapter));
                addTempChapterFromOtherBooks(tempBook?.id);
            } else if (source?.bookId) {
                const currentBook = books.find(b => b.id === source.bookId);
                currentBook?.chapters.forEach(chapter => addChapterOption(currentBook, chapter));
                addTempChapterFromOtherBooks(currentBook?.id);
            } else {
                books.forEach(book => book.chapters.forEach(chapter => addChapterOption(book, chapter)));
            }

            if (tempBook && tempChapter) {
                addChapterOption(tempBook, tempChapter);
            }

            return options;
        };

        const ensureTempChapterInBook = (currentBooks, bookId) => {
            let updated = [...currentBooks];
            const bookIndex = updated.findIndex(b => b.id === bookId);
            if (bookIndex < 0) return { books: updated, chapterId: null, changed: false };

            const book = updated[bookIndex];
            let chapter = book.chapters.find(c => isPreliminaryChapterTitle(c.title));
            let changed = false;

            if (!chapter) {
                chapter = { id: generateId(), title: TEMP_CHAPTER_TITLE, notes: [] };
                updated[bookIndex] = { ...book, chapters: [...book.chapters, chapter] };
                changed = true;
            }

            return { books: updated, chapterId: chapter.id, changed };
        };

        const ensureTempBookAndChapter = (currentBooks) => {
            let updated = [...currentBooks];
            let tempBook = updated.find(b => matchTitle(b.title, TEMP_BOOK_TITLE));
            let changed = false;

            if (!tempBook) {
                const now = Date.now();
                tempBook = touchBook({ id: generateId(), title: TEMP_BOOK_TITLE, chapters: [], notes: [], collectionId: DEFAULT_COLLECTION.id }, now);
                updated = [...updated, tempBook];
                changed = true;
            }

            const { books: withChapter, chapterId, changed: chapterChanged } = ensureTempChapterInBook(updated, tempBook.id);
            const refreshedBook = withChapter.find(b => b.id === tempBook.id);

            return {
                books: withChapter,
                tempBookId: refreshedBook?.id || tempBook.id,
                tempChapterId: chapterId,
                changed: changed || chapterChanged
            };
        };

        const ensurePreliminaryChaptersEverywhere = (currentBooks) => {
            let updated = [...currentBooks];
            let changed = false;

            updated.forEach(book => {
                const ensured = ensureTempChapterInBook(updated, book.id);
                if (ensured.changed) {
                    updated = ensured.books;
                    changed = true;
                }
            });

            return { books: updated, changed };
        };

        const updateChapterNotesInBooks = (bookList, bookId, chapterId, updater, timestamp = Date.now()) => bookList.map(book => {
            if (book.id !== bookId) return book;
            return touchBook({
                ...book,
                chapters: book.chapters.map(chapter => chapter.id === chapterId ? { ...chapter, notes: updater(chapter.notes || []) } : chapter)
            }, timestamp);
        });

        const useLongPressMoveMode = (duration = 500, { onEnterMoveMode } = {}) => {
            const [moveModeId, setMoveModeId] = useState(null);
            const pressTimer = useRef(null);
            const longPressTriggered = useRef(false);

            const clearPressTimer = () => {
                if (pressTimer.current) {
                    clearTimeout(pressTimer.current);
                    pressTimer.current = null;
                }
            };

            const startPress = (id) => {
                clearPressTimer();
                longPressTriggered.current = false;
                pressTimer.current = setTimeout(() => {
                    longPressTriggered.current = true;
                    setMoveModeId(prev => {
                        const nextId = prev === id ? null : id;
                        if (nextId) onEnterMoveMode?.(nextId);
                        return nextId;
                    });
                }, duration);
            };

            const cancelPress = () => {
                clearPressTimer();
            };

            const getItemProps = (id) => ({
                onPointerDown: () => startPress(id),
                onPointerUp: cancelPress,
                onPointerLeave: cancelPress,
                onPointerCancel: cancelPress,
                onClick: (e) => {
                    if (longPressTriggered.current) {
                        e.preventDefault();
                        e.stopPropagation();
                        longPressTriggered.current = false;
                    }
                },
            });

            useEffect(() => () => clearPressTimer(), []);

            const activateMoveMode = (id) => {
                setMoveModeId(prev => {
                    const nextId = id ?? null;
                    if (nextId && nextId !== prev) onEnterMoveMode?.(nextId);
                    return nextId;
                });
            };

            const exitMoveMode = () => {
                setMoveModeId(null);
                longPressTriggered.current = false;
                clearPressTimer();
            };

            return { moveModeId, getItemProps, exitMoveMode, activateMoveMode };
        };

        const NoteEditorModal = ({ isOpen, title, value, nameValue, onNameChange, onChange, onSave, onClose }) => {
            const editorRef = useRef(null);
            const [fontFamily, setFontFamily] = useState('Calibri');
            const [fontSize, setFontSize] = useState(16);
            const [highlightColor, setHighlightColor] = useState('#fef3c7');
            const [textColor, setTextColor] = useState('#7c3aed');
            const selectionRef = useRef(null);
            const [activeFormats, setActiveFormats] = useState({
                bold: false,
                italic: false,
                underline: false,
                unorderedList: false,
                orderedList: false,
                alignLeft: true,
                alignCenter: false,
                alignRight: false,
                alignJustify: false,
                highlight: false,
                textColor: false,
            });

            useEffect(() => {
                if (isOpen && editorRef.current) {
                    if (value && editorRef.current.innerHTML !== value) {
                        editorRef.current.innerHTML = value;
                    } else if (!value) {
                        editorRef.current.innerHTML = '<p></p>';
                    }
                    editorRef.current.focus();
                    syncCommandStates();
                }
            }, [isOpen, value]);

            useEffect(() => {
                if (!isOpen) return;
                const handleSelectionChange = () => syncCommandStates();
                document.addEventListener('selectionchange', handleSelectionChange);
                return () => document.removeEventListener('selectionchange', handleSelectionChange);
            }, [isOpen]);

            const normalizeHex = (value) => {
                if (!value) return '';
                const temp = document.createElement('div');
                temp.style.color = value;
                document.body.appendChild(temp);
                const rgb = getComputedStyle(temp).color;
                document.body.removeChild(temp);

                const match = rgb.match(/(\d+)/g);
                if (!match) return value.toLowerCase();
                const toHex = (n) => Number(n).toString(16).padStart(2, '0');
                const [r, g, b] = match;
                return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
            };

            const colorsEqual = (a, b) => normalizeHex(a) === normalizeHex(b);

            const saveSelection = () => {
                const selection = window.getSelection();
                if (!selection || selection.rangeCount === 0) return;
                const range = selection.getRangeAt(0);
                if (editorRef.current && editorRef.current.contains(range.commonAncestorContainer)) {
                    selectionRef.current = range.cloneRange();
                }
            };

            const rememberSelectionBeforeToolbarInteraction = () => {
                // Pointer/touch interactions on mobile clear the editable selection.
                // Capture the current range so formatting commands can restore it.
                saveSelection();
            };

            const restoreSelection = () => {
                const selection = window.getSelection();
                if (!selection || !selectionRef.current) return;
                selection.removeAllRanges();
                selection.addRange(selectionRef.current);
            };

            const syncCommandStates = () => {
                if (!editorRef.current) return;
                saveSelection();
                const highlightValue = document.queryCommandValue('hiliteColor');
                const textColorValue = document.queryCommandValue('foreColor');

                setActiveFormats({
                    bold: document.queryCommandState('bold'),
                    italic: document.queryCommandState('italic'),
                    underline: document.queryCommandState('underline'),
                    unorderedList: document.queryCommandState('insertUnorderedList'),
                    orderedList: document.queryCommandState('insertOrderedList'),
                    alignLeft: document.queryCommandState('justifyLeft'),
                    alignCenter: document.queryCommandState('justifyCenter'),
                    alignRight: document.queryCommandState('justifyRight'),
                    alignJustify: document.queryCommandState('justifyFull'),
                    highlight: colorsEqual(highlightValue, highlightColor),
                    textColor: colorsEqual(textColorValue, textColor),
                });
            };

            const format = (command, arg = null) => {
                if (!editorRef.current) return;
                restoreSelection();
                document.execCommand(command, false, arg);
                editorRef.current.focus();
                onChange(editorRef.current.innerHTML);
                syncCommandStates();
            };

            const applyFontFamily = (family) => {
                setFontFamily(family);
                format('fontName', family);
            };

            const applyFontSize = (size) => {
                if (!editorRef.current) return;
                setFontSize(size);
                const sizeMap = { 10: 2, 11: 2, 12: 3, 14: 4, 16: 5, 18: 6, 20: 7 };
                const commandSize = sizeMap[size] || 3;
                document.execCommand('fontSize', false, commandSize);

                const fonts = editorRef.current.getElementsByTagName('font');
                Array.from(fonts).forEach((font) => {
                    if (font.size == commandSize) {
                        font.removeAttribute('size');
                        font.style.fontSize = `${size}px`;
                    }
                });

                editorRef.current.focus();
                onChange(editorRef.current.innerHTML);
            };

            const applyHighlight = (color) => {
                saveSelection();
                restoreSelection();
                const current = document.queryCommandValue('hiliteColor');
                const shouldClear = colorsEqual(current, color);
                setHighlightColor(color);

                if (shouldClear) {
                    format('hiliteColor', 'transparent');
                } else {
                    format('hiliteColor', color);
                }
            };

            const applyTextColor = (color) => {
                restoreSelection();
                const current = document.queryCommandValue('foreColor');
                const shouldClear = colorsEqual(current, color);
                setTextColor(color);
                format('foreColor', shouldClear ? '#000000' : color);
            };

            const handleInput = () => {
                if (editorRef.current) onChange(editorRef.current.innerHTML);
                syncCommandStates();
            };

            const toolbarButtonClass = "px-2.5 py-2 rounded-lg border bg-white/90 shadow-sm text-xs text-slate-700 hover:bg-slate-100 flex items-center gap-1 min-w-[2.35rem]";
            const activeToolbarClass = "bg-violet-50 border-violet-500 text-violet-700 shadow-inner";
            const getButtonClasses = (isActive = false) => `${toolbarButtonClass} ${isActive ? activeToolbarClass : ''}`;

            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 z-50 bg-slate-900/60 backdrop-blur flex flex-col">
                    <div className="flex items-center justify-between px-4 py-3 bg-white shadow-md border-b">
                        <div>
                            <p className="text-[11px] uppercase tracking-[0.2em] text-slate-400">Editor de nota</p>
                            <p className="text-sm font-semibold text-slate-900">{title}</p>
                        </div>
                        <div className="flex gap-2">
                            <button onClick={onClose} className="px-3 py-1.5 rounded-lg border text-slate-700 hover:bg-slate-50 text-sm">Cancelar</button>
                            <button onClick={onSave} className="px-3 py-1.5 rounded-lg bg-indigo-600 text-white font-semibold shadow hover:bg-indigo-700 text-sm">Guardar</button>
                        </div>
                    </div>
                    <div className="px-4 py-3 bg-white border-b">
                        <input
                            value={nameValue || ''}
                            onChange={(e) => onNameChange?.(e.target.value)}
                            className="w-full px-3 py-2 rounded-xl border border-slate-200 focus:ring-2 focus:ring-indigo-200 focus:outline-none text-sm font-semibold text-slate-900"
                            placeholder="Nombre de la nota"
                        />
                    </div>
                    <div className="px-3 py-2 bg-slate-50 border-b">
                        <div className="overflow-x-auto pb-2">
                            <div
                                className="grid grid-rows-2 grid-flow-col auto-cols-max gap-2 min-w-full"
                                onPointerDown={rememberSelectionBeforeToolbarInteraction}
                            >
                                <select
                                    value={fontFamily}
                                    onChange={(e) => applyFontFamily(e.target.value)}
                                    onPointerDown={rememberSelectionBeforeToolbarInteraction}
                                    onFocus={rememberSelectionBeforeToolbarInteraction}
                                    className="h-8 rounded-md border bg-white px-1.5 text-xs shadow-sm w-[3.6rem] min-w-[3.6rem] truncate"
                                >
                                    {['Calibri', 'Arial', 'Georgia', 'Times New Roman', 'Segoe UI', 'Roboto'].map((font) => (
                                        <option key={font} value={font}>{font}</option>
                                    ))}
                                </select>
                                <select
                                    value={fontSize}
                                    onChange={(e) => applyFontSize(Number(e.target.value))}
                                    onPointerDown={rememberSelectionBeforeToolbarInteraction}
                                    onFocus={rememberSelectionBeforeToolbarInteraction}
                                    className="h-8 rounded-md border bg-white px-1.5 text-xs shadow-sm w-[2rem] min-w-[2rem]"
                                >
                                    {[10, 11, 12, 14, 16, 18, 20].map((size) => (
                                        <option key={size} value={size}>{size}</option>
                                    ))}
                                </select>
                                <button
                                    onClick={() => applyHighlight('#fff59d')}
                                    className={getButtonClasses(activeFormats.highlight)}
                                    title="Resaltar"
                                >
                                    <span className="inline-flex h-4 w-4 rounded-sm border" style={{ backgroundColor: highlightColor }}></span>
                                    <span className="hidden sm:inline">Resaltar</span>
                                </button>
                                <button
                                    onClick={() => applyTextColor('#7c3aed')}
                                    className={getButtonClasses(activeFormats.textColor)}
                                    title="Color de texto"
                                >
                                    <span className="inline-flex h-4 w-4 rounded-sm border" style={{ backgroundColor: textColor }}></span>
                                    <span className="hidden sm:inline">Color</span>
                                </button>
                                <button onClick={() => format('bold')} className={getButtonClasses(activeFormats.bold) + ' font-semibold'}><strong>B</strong></button>
                                <button onClick={() => format('italic')} className={getButtonClasses(activeFormats.italic) + ' italic'}>I</button>
                                <button onClick={() => format('underline')} className={getButtonClasses(activeFormats.underline) + ' underline'}>U</button>
                                <button onClick={() => format('justifyLeft')} className={getButtonClasses(activeFormats.alignLeft)}>
                                    <svg xmlns="http://www.w3.org/2000/svg" className="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                        <path d="M4 6h16" /><path d="M4 10h10" /><path d="M4 14h16" /><path d="M4 18h10" />
                                    </svg>
                                    <span className="sr-only">Alinear a la izquierda</span>
                                </button>
                                <button onClick={() => format('justifyCenter')} className={getButtonClasses(activeFormats.alignCenter)}>
                                    <svg xmlns="http://www.w3.org/2000/svg" className="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                        <path d="M6 6h12" /><path d="M4 10h16" /><path d="M6 14h12" /><path d="M4 18h16" />
                                    </svg>
                                    <span className="sr-only">Centrar</span>
                                </button>
                                <button onClick={() => format('justifyRight')} className={getButtonClasses(activeFormats.alignRight)}>
                                    <svg xmlns="http://www.w3.org/2000/svg" className="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                        <path d="M4 6h16" /><path d="M10 10h10" /><path d="M4 14h16" /><path d="M10 18h10" />
                                    </svg>
                                    <span className="sr-only">Alinear a la derecha</span>
                                </button>
                                <button onClick={() => format('justifyFull')} className={getButtonClasses(activeFormats.alignJustify)}>
                                    <svg xmlns="http://www.w3.org/2000/svg" className="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                        <path d="M4 6h16" /><path d="M4 10h16" /><path d="M4 14h16" /><path d="M4 18h16" />
                                    </svg>
                                    <span className="sr-only">Justificar</span>
                                </button>
                                <button onClick={() => format('insertUnorderedList')} className={getButtonClasses(activeFormats.unorderedList)}>
                                    <svg xmlns="http://www.w3.org/2000/svg" className="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                        <path d="M7 6h11" /><path d="M7 12h11" /><path d="M7 18h11" />
                                        <path d="M4 6h.01" /><path d="M4 12h.01" /><path d="M4 18h.01" />
                                    </svg>
                                    <span className="sr-only">Lista con viñetas</span>
                                </button>
                                <button onClick={() => format('insertOrderedList')} className={getButtonClasses(activeFormats.orderedList)}>
                                    <svg xmlns="http://www.w3.org/2000/svg" className="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                        <path d="M6 6h12" /><path d="M6 12h12" /><path d="M6 18h12" />
                                        <path d="M4 6h.01" /><path d="M4 12h.01" /><path d="M4 18h.01" />
                                    </svg>
                                    <span className="sr-only">Lista numerada</span>
                                </button>
                            </div>
                        </div>
                    </div>
                    <div className="flex-1 overflow-y-auto bg-white">
                        <div
                            ref={editorRef}
                            contentEditable
                            onInput={handleInput}
                            className="max-w-4xl mx-auto p-5 min-h-[60vh] prose prose-slate focus:outline-none editor-content"
                            placeholder="Escribe o pega tu nota con formato..."
                        ></div>
                    </div>
                </div>
            );
        };

        const MoveControls = ({ onMoveUp, onMoveDown, accentClass = 'text-slate-700' }) => (
            <div className="flex flex-col items-center justify-center gap-1 bg-white/90 rounded-full border border-slate-200 shadow-sm p-1">
                <button
                    onPointerDown={(e) => e.stopPropagation()}
                    onClick={(e) => { e.stopPropagation(); onMoveUp?.(); }}
                    className={`w-8 h-8 rounded-full flex items-center justify-center hover:bg-slate-100 active:scale-95 ${accentClass}`}
                    aria-label="Mover hacia arriba"
                >
                    ▲
                </button>
                <button
                    onPointerDown={(e) => e.stopPropagation()}
                    onClick={(e) => { e.stopPropagation(); onMoveDown?.(); }}
                    className={`w-8 h-8 rounded-full flex items-center justify-center hover:bg-slate-100 active:scale-95 ${accentClass}`}
                    aria-label="Mover hacia abajo"
                >
                    ▼
                </button>
            </div>
        );

        const getPlainTextFromHtml = (htmlContent) => {
            const temp = document.createElement('div');
            temp.innerHTML = htmlContent || '';
            return (temp.textContent || temp.innerText || '').trim();
        };

        const extractNoteName = (htmlContent) => {
            const text = getPlainTextFromHtml(htmlContent);
            const firstLine = text.split(/\n/).map(line => line.trim()).find(Boolean);

            if (!firstLine) return 'Nueva nota';

            const firstSentence = firstLine.split(/(?<=[.!?])\s+/).find(Boolean);
            return (firstSentence || firstLine || '').trim() || 'Nueva nota';
        };

        const getNoteBodyPreview = (note, limit = 140) => {
            const text = getPlainTextFromHtml(note?.content);
            const name = note?.name || extractNoteName(note?.content);
            const body = text.startsWith(name) ? text.slice(name.length).trimStart() : text;
            if (!body) return '';
            return body.length > limit ? `${body.slice(0, limit).trim()}...` : body;
        };

        const NoteChip = ({ note, actions = {}, selectionMode = false, isSelected = false, onCardClick, moveHandlers = {}, moveModeActive = false, collapsed = false, previewLength = 140 }) => {
            const { onEdit, onMoveUp, onMoveDown } = actions;
            const showMoveControls = moveModeActive && (onMoveUp || onMoveDown);
            const isLinkNote = note?.type === 'link' && note?.url;
            const linkHost = (() => {
                try { return new URL(note.url).hostname.replace(/^www\./, ''); } catch (e) { return note.url || ''; }
            })();
            const noteName = note?.name || extractNoteName(note?.content);
            const previewText = collapsed
                ? (isLinkNote ? (note?.meta?.title || shortenUrl(note.url || '')) : getNoteBodyPreview(note, previewLength))
                : null;

            const handleLinkOpen = () => {
                if (!isLinkNote || !note.url) return;
                window.open(note.url, '_blank', 'noopener,noreferrer');
            };

            const renderLinkCard = () => {
                const title = note?.meta?.title || linkHost;
                const subtitle = note?.meta?.displayUrl || shortenUrl(note.url || '');
                const thumbnail = note?.meta?.thumbnail;
                return (
                    <div className="flex gap-3 items-center">
                        <div className="w-24 h-16 rounded-lg overflow-hidden bg-slate-100 border border-slate-200 flex items-center justify-center">
                            {thumbnail
                                ? <img src={thumbnail} alt={title} className="w-full h-full object-cover" />
                                : (
                                    <div className="flex flex-col items-center text-[11px] text-slate-500">
                                        <Icons.Link />
                                        <span>Enlace</span>
                                    </div>
                                )
                            }
                        </div>
                        <div className="flex-1 min-w-0">
                            <p className="text-sm font-semibold text-slate-800 truncate">{title}</p>
                            <p className="text-xs text-slate-500 truncate">{subtitle}</p>
                            <p className="text-[11px] text-indigo-600 flex items-center gap-1 mt-1">
                                <Icons.Link />
                                <span className="truncate">{linkHost}</span>
                            </p>
                        </div>
                    </div>
                );
            };

            return (
                <div
                    {...moveHandlers}
                    className={`p-4 rounded-xl shadow-md border transition relative cursor-pointer select-none backdrop-blur-sm ${isSelected ? 'bg-gradient-to-r from-indigo-50 via-rose-50 to-amber-50 border-indigo-300 ring-2 ring-rose-200' : 'bg-white/90 border-white/60 hover:shadow-lg'}`}
                    onClick={(e) => {
                        moveHandlers.onClick?.(e);
                        if (e.defaultPrevented) return;
                        if (selectionMode) {
                            onCardClick?.(e);
                            return;
                        }
                        if (isLinkNote && !moveModeActive) {
                            handleLinkOpen();
                            return;
                        }
                        if (onEdit && !moveModeActive) {
                            onEdit();
                            return;
                        }
                        onCardClick?.(e);
                    }}
                >
                    {isLinkNote
                        ? renderLinkCard()
                        : collapsed
                            ? (
                                <div className="space-y-1">
                                    <p className="text-sm font-bold text-slate-900 leading-tight">{noteName}</p>
                                    {previewText && (
                                        <p className="text-sm text-gray-800 leading-relaxed whitespace-pre-wrap break-words">{previewText}</p>
                                    )}
                                </div>
                            )
                            : (
                                <div className="space-y-2">
                                    <p className="text-base font-bold text-slate-900 leading-tight">{noteName}</p>
                                    <div className="text-sm text-gray-800 prose prose-slate max-w-none leading-relaxed editor-content" dangerouslySetInnerHTML={{ __html: note.content }} />
                                </div>
                            )
                    }
                    <div className="mt-2 flex justify-between items-center text-[10px] text-gray-400">
                        <span>{new Date(note.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>
                        {showMoveControls && (
                            <div className="relative">
                                <MoveControls onMoveUp={onMoveUp} onMoveDown={onMoveDown} />
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const OptionPicker = ({ state, onSelect, onClose }) => {
            if (!state.open) return null;
            return (
                <div className="fixed inset-0 z-40 flex items-center justify-center bg-black/40 p-4" onClick={onClose}>
                    <div className="w-full max-w-md bg-white rounded-2xl shadow-2xl border p-4" onClick={(e) => e.stopPropagation()}>
                        <div className="flex items-center justify-between mb-3">
                            <p className="text-sm font-semibold text-slate-800">{state.title || 'Select an option'}</p>
                            <button onClick={onClose} className="text-slate-400 hover:text-slate-600">✕</button>
                        </div>
                        <div className="space-y-2 max-h-64 overflow-y-auto">
                            {state.options.map((opt, idx) => (
                                <button
                                    key={`${opt.label}-${idx}`}
                                    onClick={() => onSelect(opt)}
                                    className="w-full text-left px-3 py-2 rounded-xl border border-slate-200 hover:border-blue-400 hover:bg-blue-50 transition"
                                >
                                    {opt.label}
                                </button>
                            ))}
                        </div>
                    </div>
                </div>
            );
        };

        const AiCornerButton = ({ onClick, title = 'Acciones con IA' }) => (
            <button
                onClick={onClick}
                className="w-12 h-12 rounded-full bg-gradient-to-br from-indigo-500 to-blue-600 text-white shadow-[0_14px_36px_rgba(59,130,246,0.45)] border border-indigo-200 hover:scale-105 active:scale-95 flex items-center justify-center transition"
                aria-label={title}
                title={title}
            >
                <Icons.GenAI />
            </button>
        );

        const SpeechToTextConfig = ({
            open,
            onClose,
            engines,
            selectedEngine,
            aiAssistEnabled,
            languagePreferences,
            onSave
        }) => {
            const [draftEngine, setDraftEngine] = React.useState(selectedEngine);
            const [draftAiAssist, setDraftAiAssist] = React.useState(aiAssistEnabled);
            const [draftLanguages, setDraftLanguages] = React.useState(languagePreferences || {});

            useEffect(() => {
                if (open) {
                    setDraftEngine(selectedEngine);
                    setDraftAiAssist(aiAssistEnabled);
                    setDraftLanguages(languagePreferences || {});
                }
            }, [open, selectedEngine, aiAssistEnabled, languagePreferences]);

            if (!open) return null;

            const activeEngine = engines.find((engine) => engine.id === draftEngine) || engines[0];
            const activeLanguages = draftLanguages?.[draftEngine] && draftLanguages[draftEngine].length > 0
                ? draftLanguages[draftEngine]
                : (activeEngine?.languages || []).map((lang) => lang.code);

            const toggleLanguage = (engineId, code) => {
                setDraftLanguages((prev) => {
                    const current = prev?.[engineId] && prev[engineId].length > 0
                        ? prev[engineId]
                        : (engines.find((e) => e.id === engineId)?.languages || []).map((lang) => lang.code);
                    const exists = current.includes(code);
                    const next = exists ? current.filter((c) => c !== code) : [...current, code];
                    return { ...prev, [engineId]: next };
                });
            };

            const handleSave = () => {
                onSave?.({
                    preferredEngine: draftEngine,
                    aiAssistEnabled: draftAiAssist,
                    languagePreferences: draftLanguages
                });
                onClose?.();
            };

            return (
                <div className="fixed inset-0 z-50 bg-black/60 overflow-y-auto" onClick={onClose}>
                    <div className="min-h-full w-full flex items-center justify-center p-4" onClick={(e) => e.stopPropagation()}>
                        <div className="w-full max-w-xl bg-white rounded-2xl shadow-2xl border border-slate-100 p-5 flex flex-col max-h-[90vh]">
                            <div className="flex items-start justify-between gap-3 pb-3 border-b border-slate-100 sticky top-0 bg-white">
                                <div>
                                    <p className="text-sm font-semibold text-slate-800">Speech-to-Text</p>
                                    <p className="text-xs text-slate-500">Elige tu motor, revisa idiomas soportados y guarda los cambios.</p>
                                </div>
                                <button onClick={onClose} className="icon-btn text-slate-400 hover:text-slate-700">✕</button>
                            </div>

                            <div className="space-y-3 overflow-y-auto pr-1 mt-3">
                                {engines.map((engine) => (
                                    <div
                                        key={engine.id}
                                        className={`w-full px-4 py-3 rounded-xl border text-left transition ${draftEngine === engine.id ? 'border-indigo-300 bg-indigo-50/70' : 'border-slate-200 hover:border-indigo-200 hover:bg-indigo-50/50'} ${engine.available ? '' : 'opacity-60 cursor-not-allowed'}`}
                                        onClick={() => engine.available && setDraftEngine(engine.id)}
                                    >
                                        <div className="flex items-start justify-between gap-3">
                                            <div className="flex-1 min-w-0">
                                                <p className="font-semibold text-slate-800 text-sm truncate">{engine.label}</p>
                                                <p className="text-xs text-slate-500 truncate">{engine.description}</p>
                                                {engine.languages?.length > 0 && (
                                                    <div className="flex flex-wrap gap-1.5 mt-2">
                                                        {engine.languages.map((lang) => (
                                                            <span key={lang.code} className="text-[11px] px-2 py-1 rounded-full bg-white border border-slate-200 text-slate-600">
                                                                {lang.label}
                                                            </span>
                                                        ))}
                                                    </div>
                                                )}
                                            </div>
                                            <div className="flex flex-col items-end gap-1">
                                                <span className={`text-[11px] px-2 py-1 rounded-full border ${engine.available ? 'text-emerald-700 bg-emerald-50 border-emerald-200' : 'text-slate-500 bg-slate-100 border-slate-200'}`}>
                                                    {engine.available ? 'Disponible' : 'No detectado'}
                                                </span>
                                                {draftEngine === engine.id && <Icons.Check />}
                                            </div>
                                        </div>
                                    </div>
                                ))}

                                <div className="p-4 rounded-xl border border-indigo-100 bg-indigo-50/70 flex items-start gap-3">
                                    <div className="flex-shrink-0 w-9 h-9 rounded-full bg-white text-indigo-600 flex items-center justify-center shadow-inner">
                                        <Icons.Wand />
                                    </div>
                                    <div className="flex-1">
                                        <p className="font-semibold text-slate-800 text-sm">Asistencia AI</p>
                                        <p className="text-xs text-slate-600">Pulir automáticamente las transcripciones usando tu modelo configurado.</p>
                                        <label className="mt-3 inline-flex items-center gap-2">
                                            <input type="checkbox" checked={draftAiAssist} onChange={(e) => setDraftAiAssist(e.target.checked)} />
                                            <span className="text-sm text-slate-700">Activar post-procesamiento AI</span>
                                        </label>
                                    </div>
                                </div>

                                {activeEngine?.languages?.length > 0 && (
                                    <div className="p-4 rounded-xl border border-slate-200 bg-white">
                                        <div className="flex items-start justify-between gap-2">
                                            <div>
                                                <p className="font-semibold text-slate-800 text-sm">Idiomas para {activeEngine.label}</p>
                                                <p className="text-xs text-slate-500">Activa los idiomas que quieres permitir en Text-to-Speech y dictado.</p>
                                            </div>
                                            <span className="text-[11px] px-2 py-1 rounded-full bg-slate-100 text-slate-600 border border-slate-200">{activeLanguages.length} seleccionados</span>
                                        </div>
                                        <div className="flex flex-wrap gap-2 mt-3">
                                            {activeEngine.languages.map((lang) => {
                                                const selected = activeLanguages.includes(lang.code);
                                                return (
                                                    <button
                                                        key={lang.code}
                                                        onClick={() => toggleLanguage(activeEngine.id, lang.code)}
                                                        className={`px-3 py-1.5 rounded-full border text-sm flex items-center gap-2 transition ${selected ? 'bg-indigo-50 border-indigo-300 text-indigo-700' : 'bg-white border-slate-200 text-slate-600 hover:border-indigo-200'}`}
                                                    >
                                                        <input type="checkbox" checked={selected} readOnly />
                                                        <span className="text-xs font-medium">{lang.label}</span>
                                                    </button>
                                                );
                                            })}
                                        </div>
                                    </div>
                                )}

                                <p className="text-[11px] text-slate-500 leading-relaxed">Guardamos tu preferencia de captura de voz (navegador, Android, teclado u otras opciones detectadas) para que puedas decidir cómo dictar cuando uses esta app en tu teléfono.</p>
                            </div>

                            <div className="flex flex-col gap-2 pt-4 mt-2 border-t border-slate-200 sticky bottom-0 bg-white">
                                <button onClick={handleSave} className="w-full py-3 rounded-xl bg-indigo-600 text-white font-semibold shadow-md hover:bg-indigo-700 transition">Guardar preferencias</button>
                                <button onClick={onClose} className="w-full py-2.5 rounded-xl border border-slate-200 text-slate-700 font-medium bg-slate-50 hover:bg-slate-100">Cancelar</button>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const HamburgerMenu = ({
            open,
            onClose,
            onSettings,
            onSpeechSettings,
            onLogin,
            onLogout,
            authUser,
            status,
            message,
            firebaseReady,
            firebaseError
        }) => {
            if (!open) return null;
            const statusColor = status === 'success' ? 'text-green-700 bg-green-50 border-green-200' : status === 'error' ? 'text-red-700 bg-red-50 border-red-200' : 'text-blue-700 bg-blue-50 border-blue-200';
            return (
                <div className="fixed inset-0 z-50 bg-black/40" onClick={onClose}>
                    <div className="absolute top-3 right-3 w-72 bg-white rounded-2xl shadow-2xl border border-slate-100 p-4 space-y-3" onClick={(e) => e.stopPropagation()}>
                        <div className="flex items-start justify-between gap-2">
                            <div>
                                <p className="text-sm font-semibold text-slate-800">Menu</p>
                                <p className="text-xs text-slate-500">Firebase {firebaseReady ? 'ready' : 'not initialized'}</p>
                                {firebaseError && <p className="text-[11px] text-red-600">{firebaseError}</p>}
                                {authUser && <p className="text-[11px] text-slate-500">{authUser.email}</p>}
                            </div>
                            <button onClick={onClose} className="icon-btn text-slate-400 hover:text-slate-700">✕</button>
                        </div>

                        <div className="space-y-2">
                            <button onClick={onSettings} className="w-full flex items-center justify-between px-3 py-2 rounded-xl border bg-slate-50 hover:bg-slate-100">
                                <span className="text-sm font-medium text-slate-800">AI Settings</span>
                                <Icons.Settings />
                            </button>
                            <button onClick={onSpeechSettings} className="w-full flex items-center justify-between px-3 py-2 rounded-xl border bg-violet-50 hover:bg-violet-100">
                                <span className="text-sm font-medium text-violet-800">Speech-to-Text</span>
                                <Icons.Mic />
                            </button>
                            <button onClick={authUser ? onLogout : onLogin} className="w-full flex items-center justify-between px-3 py-2 rounded-xl border bg-indigo-50 hover:bg-indigo-100 text-indigo-800 font-semibold">
                                <span>{authUser ? 'Log Out' : 'Log In'}</span>
                                <Icons.Cloud />
                            </button>
                        </div>

                        {status && (
                            <div className={`text-xs px-3 py-2 rounded-xl border ${statusColor}`}>
                                <p className="font-semibold">{status === 'loading' ? 'Processing...' : status === 'success' ? 'Success' : 'Alert'}</p>
                                <p>{message}</p>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // --- API GEMINI ---
        async function callGemini(apiKey, model, prompt, content) {
            if (!apiKey || apiKey.length < 10) throw new Error("Falta la API Key.");

            // Usar el modelo configurado
            const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
            const fullText = `${prompt}\n\n--- CONTENIDO ---\n${content}`;
            const payload = { contents: [{ parts: [{ text: fullText }] }] };

            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const data = await response.json();

                if (!response.ok) {
                    if (data.error?.code === 404) {
                        throw new Error(`Modelo '${model}' no encontrado. Revisa el nombre en Configuración.`);
                    }
                    throw new Error(data.error?.message || 'Error desconocido en la API');
                }

                return data.candidates?.[0]?.content?.parts?.[0]?.text || "No se generó respuesta.";
            } catch (error) {
                console.error("API Error:", error);
                throw error;
            }
        }

        // --- COMPONENTE PRINCIPAL ---
        function App() {
            const [books, setBooks] = useState([]);
            const [collections, setCollections] = useState([DEFAULT_COLLECTION]);
            const [rootNotes, setRootNotes] = useState([]);
            const [settings, setSettings] = useState({
                apiKey: DEFAULT_API_KEY,
                model: DEFAULT_MODEL,
                prompts: { ...DEFAULT_PROMPTS },
                speechToText: { ...DEFAULT_SPEECH_CONFIG }
            });
            const [dataLoaded, setDataLoaded] = useState(false);
            const [view, setView] = useState('home');
            const [libraryView, setLibraryView] = useState('list');
            const [librarySort, setLibrarySort] = useState('latest');
            const [activeCollectionId, setActiveCollectionId] = useState(null);
            const [collectionViewMode, setCollectionViewMode] = useState('grid');
            const [activeBookId, setActiveBookId] = useState(null);
            const [activeChapterId, setActiveChapterId] = useState(null);
            const [loading, setLoading] = useState(false);
            const [testStatus, setTestStatus] = useState(null); // null, 'loading', 'success', 'error'
            const [testMsg, setTestMsg] = useState("");
            const [selectedBookIds, setSelectedBookIds] = useState([]);
            const [bookSelectionMode, setBookSelectionMode] = useState(false);
            const [activeSelectedBookId, setActiveSelectedBookId] = useState(null);
            const [selectedChapterIds, setSelectedChapterIds] = useState([]);
            const [chapterSelectionMode, setChapterSelectionMode] = useState(false);
            const [activeSelectedChapterId, setActiveSelectedChapterId] = useState(null);
            const [noteModal, setNoteModal] = useState({ open: false, target: null });
            const [noteDraft, setNoteDraft] = useState('<p></p>');
            const [noteTitleDraft, setNoteTitleDraft] = useState('');
            const recognitionRef = useRef(null);
            const [recordingTarget, setRecordingTarget] = useState(null);
            const [isRecording, setIsRecording] = useState(false);
            const [micSupportError, setMicSupportError] = useState(null);
            const [picker, setPicker] = useState({ open: false, options: [], title: '', resolve: null });
            const [menuOpen, setMenuOpen] = useState(false);
            const [speechConfigOpen, setSpeechConfigOpen] = useState(false);
            const [firebaseReady, setFirebaseReady] = useState(false);
            const [firebaseError, setFirebaseError] = useState(null);
            const [authUser, setAuthUser] = useState(null);
            const [cloudStatus, setCloudStatus] = useState(null);
            const [cloudMessage, setCloudMessage] = useState('');
            const [shouldBootstrapFromCloud, setShouldBootstrapFromCloud] = useState(false);
            const firebaseAppRef = useRef(null);
            const authRef = useRef(null);
            const dbRef = useRef(null);
            const autoSaveTimeoutRef = useRef(null);
            const [immediateSaveCounter, setImmediateSaveCounter] = useState(0);

            const speechEngines = useMemo(() => detectSpeechEngines(), []);
            const availableCollections = useMemo(() => ensureCollectionsWithDefault(collections), [collections]);

            const getCollectionName = useCallback((collectionId) => {
                const found = availableCollections.find(c => c.id === collectionId);
                return found?.name || DEFAULT_COLLECTION.name;
            }, [availableCollections]);

            const getBookPreview = useCallback((book) => {
                const directNotes = book.notes || [];
                const chapterNotes = (book.chapters || []).flatMap(ch => ch.notes || []);
                const sample = [...directNotes, ...chapterNotes].find(n => n?.content);
                const text = toPlainText(sample?.content || '');
                if (!text) return 'Sin notas todavía';
                return text.length > 110 ? `${text.slice(0, 110)}…` : text;
            }, []);

            const booksByCollection = useMemo(() => {
                const grouped = availableCollections.map(col => ({
                    ...col,
                    books: books.filter(b => (b.collectionId || DEFAULT_COLLECTION.id) === col.id)
                }));

                const missing = books.filter(b => !availableCollections.some(col => col.id === (b.collectionId || DEFAULT_COLLECTION.id)));
                if (missing.length > 0) {
                    const idx = grouped.findIndex(g => g.id === DEFAULT_COLLECTION.id);
                    if (idx >= 0) {
                        grouped[idx] = { ...grouped[idx], books: [...grouped[idx].books, ...missing] };
                    }
                }

                return grouped;
            }, [availableCollections, books]);

            const sortBookList = useCallback((list = []) => {
                const sorted = [...list];
                const getCreated = (book) => book.createdAt || 0;
                const getUpdated = (book) => book.updatedAt || getCreated(book);
                sorted.sort((a, b) => {
                    if (librarySort === 'latest') return getUpdated(b) - getUpdated(a);
                    if (librarySort === 'oldest') return getCreated(a) - getCreated(b);
                    if (librarySort === 'newest') return getCreated(b) - getCreated(a);
                    return (a.title || '').localeCompare(b.title || '', undefined, { sensitivity: 'base' });
                });
                return sorted;
            }, [librarySort]);

            const sortedBooks = useMemo(() => sortBookList(books), [books, sortBookList]);

            const requestImmediateFirestoreSave = useCallback(() => {
                if (autoSaveTimeoutRef.current) {
                    clearTimeout(autoSaveTimeoutRef.current);
                    autoSaveTimeoutRef.current = null;
                }
                setImmediateSaveCounter((prev) => prev + 1);
            }, []);

            useEffect(() => {
                if (!window.firebase) {
                    setFirebaseError('Firebase SDK no está disponible.');
                    return;
                }
                try {
                    if (!firebase.apps.length) {
                        firebase.initializeApp(firebaseConfig);
                    }
                    firebaseAppRef.current = firebase.app();
                    authRef.current = firebase.auth();
                    dbRef.current = firebase.firestore();
                    setFirebaseReady(true);
                    const unsubscribe = authRef.current.onAuthStateChanged((user) => setAuthUser(user));
                    return () => unsubscribe?.();
                } catch (error) {
                    console.error('Firebase init error', error);
                    setFirebaseError(error.message);
                }
            }, []);

            useEffect(() => {
                const sessionId = sessionStorage.getItem(SESSION_KEY) || generateId();
                const hasLoadedThisSession = sessionStorage.getItem('voiceNotes_hasLoaded') === 'true';
                sessionStorage.setItem(SESSION_KEY, sessionId);
                sessionStorage.setItem('voiceNotes_hasLoaded', 'true');

                const savedBooks = localStorage.getItem('voiceNotes_books');
                const savedSettings = localStorage.getItem('voiceNotes_settings');
                const savedCollections = localStorage.getItem(LOCAL_COLLECTIONS_KEY);
                const savedLibraryView = localStorage.getItem(LOCAL_LIBRARY_VIEW_KEY);
                const savedCollectionViewMode = localStorage.getItem(LOCAL_COLLECTION_VIEW_KEY);
                const savedActiveCollectionId = localStorage.getItem(LOCAL_ACTIVE_COLLECTION_KEY);
                const savedLibrarySort = localStorage.getItem(LOCAL_LIBRARY_SORT_KEY);
                if (savedBooks) {
                    const parsed = JSON.parse(savedBooks);
                    setBooks(normalizeBooksData(parsed));
                }
                const savedRoot = localStorage.getItem('voiceNotes_rootNotes');
                if (savedRoot) setRootNotes(JSON.parse(savedRoot));
                if (savedCollections) {
                    const parsed = JSON.parse(savedCollections);
                    setCollections(ensureCollectionsWithDefault(parsed));
                }
                if (savedSettings) {
                    const parsed = JSON.parse(savedSettings);
                    setSettings({
                        apiKey: parsed.apiKey || DEFAULT_API_KEY,
                        model: parsed.model || DEFAULT_MODEL,
                        prompts: { ...DEFAULT_PROMPTS, ...(parsed.prompts || {}) },
                        speechToText: { ...DEFAULT_SPEECH_CONFIG, ...(parsed.speechToText || {}) }
                    });
                }
                if (savedLibraryView) setLibraryView(savedLibraryView);
                if (savedCollectionViewMode) setCollectionViewMode(savedCollectionViewMode);
                if (savedActiveCollectionId) setActiveCollectionId(savedActiveCollectionId);
                if (savedLibrarySort) setLibrarySort(savedLibrarySort);

                const lastUse = parseInt(localStorage.getItem(LOCAL_USAGE_KEY) || '0', 10);
                const lastFirestoreSync = parseInt(localStorage.getItem(FIRESTORE_SYNC_KEY) || '0', 10);
                const navigationEntry = (performance.getEntriesByType?.('navigation') || [])[0];
                const isReload = navigationEntry?.type === 'reload' || performance?.navigation?.type === performance?.navigation?.TYPE_RELOAD;
                const now = Date.now();
                const isRecentUse = lastUse > 0 && (now - lastUse) < LOCAL_RECENCY_WINDOW_MS;
                const shouldLoadFromCloud = isReload || !isRecentUse || !lastFirestoreSync || !hasLoadedThisSession;
                setShouldBootstrapFromCloud(shouldLoadFromCloud);

                localStorage.setItem(LOCAL_USAGE_KEY, String(now));
                setDataLoaded(true);
            }, []);

            useEffect(() => { localStorage.setItem('voiceNotes_books', JSON.stringify(books)); }, [books]);
            useEffect(() => { localStorage.setItem('voiceNotes_settings', JSON.stringify(settings)); }, [settings]);
            useEffect(() => { localStorage.setItem('voiceNotes_rootNotes', JSON.stringify(rootNotes)); }, [rootNotes]);
            useEffect(() => { localStorage.setItem(LOCAL_COLLECTIONS_KEY, JSON.stringify(collections)); }, [collections]);
            useEffect(() => { localStorage.setItem(LOCAL_LIBRARY_VIEW_KEY, libraryView); }, [libraryView]);
            useEffect(() => { localStorage.setItem(LOCAL_COLLECTION_VIEW_KEY, collectionViewMode); }, [collectionViewMode]);
            useEffect(() => { localStorage.setItem(LOCAL_ACTIVE_COLLECTION_KEY, activeCollectionId || ''); }, [activeCollectionId]);
            useEffect(() => { localStorage.setItem(LOCAL_LIBRARY_SORT_KEY, librarySort); }, [librarySort]);
            useEffect(() => {
                if (!dataLoaded) return;
                localStorage.setItem(LOCAL_USAGE_KEY, String(Date.now()));
            }, [books, rootNotes, settings, view, activeBookId, activeChapterId, libraryView, activeCollectionId, collectionViewMode, collections]);

            useEffect(() => {
                if (libraryView !== 'collections' && activeCollectionId) {
                    setActiveCollectionId(null);
                }
            }, [libraryView, activeCollectionId]);

            useEffect(() => {
                if (!dataLoaded) return;
                requestImmediateFirestoreSave();
            }, [libraryView, collectionViewMode, activeCollectionId, collections]);

            useEffect(() => {
                if (!activeCollectionId) return;
                const exists = booksByCollection.some((collection) => collection.id === activeCollectionId);
                if (!exists) setActiveCollectionId(null);
            }, [booksByCollection, activeCollectionId]);
            useEffect(() => {
                if (!dataLoaded) return;
                setBooks(prevBooks => {
                    let updatedBooks = [...prevBooks];
                    let changed = false;

                    const ensuredTemp = ensureTempBookAndChapter(updatedBooks);
                    updatedBooks = ensuredTemp.books;
                    changed = changed || ensuredTemp.changed;

                    for (let i = 0; i < updatedBooks.length; i++) {
                        const book = updatedBooks[i];
                        if ((book.notes || []).length === 0) continue;

                        const ensuredChapter = ensureTempChapterInBook(updatedBooks, book.id);
                        updatedBooks = ensuredChapter.books;

                        const refreshedBookIndex = updatedBooks.findIndex(b => b.id === book.id);
                        const refreshedBook = updatedBooks[refreshedBookIndex];
                        const tempChapterId = ensuredChapter.chapterId;
                        const migratedNotes = (refreshedBook.chapters.find(c => c.id === tempChapterId)?.notes || []).concat(book.notes);

                        updatedBooks[refreshedBookIndex] = {
                            ...refreshedBook,
                            notes: [],
                            chapters: refreshedBook.chapters.map(ch => ch.id === tempChapterId ? { ...ch, notes: migratedNotes } : ch)
                        };
                        changed = true;
                    }

                    return changed ? updatedBooks : prevBooks;
                });
            }, [dataLoaded]);

            useEffect(() => {
                if (!dataLoaded || rootNotes.length === 0) return;

                setBooks(prevBooks => {
                    const noteCopies = rootNotes.map(note => ({ ...note }));
                    const ensured = ensureTempBookAndChapter(prevBooks);
                    const { books: withTemp, tempBookId, tempChapterId } = ensured;

                    if (!tempBookId || !tempChapterId) return prevBooks;

                    return updateChapterNotesInBooks(
                        withTemp,
                        tempBookId,
                        tempChapterId,
                        (notes) => [...notes, ...noteCopies]
                    );
                });

                setRootNotes([]);
            }, [dataLoaded, rootNotes]);

            useEffect(() => {
                if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                    setMicSupportError("Navegador sin soporte de voz");
                }
                return () => { if (recognitionRef.current) recognitionRef.current.stop(); };
            }, []);

            // Helpers de navegación y datos
            const addBook = (title, collectionId = DEFAULT_COLLECTION.id) => {
                const now = Date.now();
                setBooks([...books, touchBook({ id: generateId(), title, chapters: [], notes: [], collectionId, createdAt: now }, now)]);
                requestImmediateFirestoreSave();
            };
            const addCollection = (name) => {
                const trimmed = (name || '').trim();
                if (!trimmed) return;
                const exists = availableCollections.some(c => c.name.toLowerCase() === trimmed.toLowerCase());
                if (exists) return alert('Ya existe una colección con ese nombre.');
                const newCollection = { id: generateId(), name: trimmed, description: 'Colección personalizada' };
                setCollections(prev => ensureCollectionsWithDefault([...prev, newCollection]));
                requestImmediateFirestoreSave();
            };
            const handleCreateCollection = () => {
                const title = promptForName("Nueva colección:");
                if (title) addCollection(title);
            };
            const moveBookToCollection = async (bookId) => {
                const choice = await openPickerWithOptions(availableCollections.map(c => ({ label: c.name, id: c.id })), 'Mover a colección');
                if (!choice?.id) return;
                const now = Date.now();
                setBooks(prev => prev.map(b => b.id === bookId ? touchBook({ ...b, collectionId: choice.id }, now) : b));
                requestImmediateFirestoreSave();
            };
            const renameBook = (id, title) => {
                const now = Date.now();
                setBooks(books.map(b => b.id === id ? touchBook({ ...b, title }, now) : b));
                requestImmediateFirestoreSave();
            };
            const deleteBook = (id) => setBooks(books.filter(b => b.id !== id));
            const reorderBooksByIndex = useCallback((from, to) => {
                setBooks(prev => moveItem(prev, from, to));
                requestImmediateFirestoreSave();
            }, []);
            const reorderBook = (id, direction) => {
                const index = books.findIndex(b => b.id === id);
                const target = index + direction;
                if (target < 0 || target >= books.length) return;
                setBooks(moveItem(books, index, target));
                requestImmediateFirestoreSave();
            };
            const moveBookToPosition = async (bookId) => {
                if (books.length < 2) return;
                const options = books
                    .filter(b => b.id !== bookId)
                    .map((b, idx) => ({ label: `Después de ${b.title}`, value: idx + 1 }));
                options.unshift({ label: 'Al inicio', value: 0 });
                const choice = await openPickerWithOptions(options, 'Mover libro');
                if (!choice || typeof choice.value !== 'number') return;
                const fromIndex = books.findIndex(b => b.id === bookId);
                const list = [...books];
                const [item] = list.splice(fromIndex, 1);
                let targetIndex = choice.value;
                if (targetIndex > fromIndex) targetIndex -= 1;
                list.splice(targetIndex, 0, item);
                setBooks(list);
                requestImmediateFirestoreSave();
            };
            const duplicateBook = (bookId) => {
                const book = books.find(b => b.id === bookId);
                if (!book) return;
                const now = Date.now();
                const copy = touchBook({
                    ...book,
                    id: generateId(),
                    createdAt: now,
                    title: `${book.title} (copia)`,
                    notes: (book.notes || []).map(cloneNote),
                    chapters: book.chapters.map(ch => ({
                        ...ch,
                        id: generateId(),
                        notes: ch.notes.map(cloneNote)
                    }))
                }, now);
                setBooks([...books, copy]);
                requestImmediateFirestoreSave();
            };
            const addChapter = (bookId, title) => {
                const now = Date.now();
                setBooks(books.map(b => b.id === bookId ? touchBook({ ...b, chapters: [...b.chapters, { id: generateId(), title, notes: [] }] }, now) : b));
                requestImmediateFirestoreSave();
            };
            const renameChapter = (bookId, chapterId, title) => {
                const now = Date.now();
                setBooks(books.map(b => b.id === bookId ? touchBook({ ...b, chapters: b.chapters.map(c => c.id === chapterId ? { ...c, title } : c) }, now) : b));
                requestImmediateFirestoreSave();
            };
            const reorderChaptersByIndex = useCallback((bookId, from, to) => {
                const now = Date.now();
                setBooks(prev => prev.map(b => b.id === bookId ? touchBook({ ...b, chapters: moveItem(b.chapters, from, to) }, now) : b));
                requestImmediateFirestoreSave();
            }, []);
            const updateBookTempNotes = (bookId, updater) => {
                setBooks(prevBooks => {
                    const now = Date.now();
                    const ensured = ensureTempChapterInBook(prevBooks, bookId);
                    if (!ensured.chapterId) return prevBooks;
                    return updateChapterNotesInBooks(ensured.books, bookId, ensured.chapterId, updater, now);
                });
            };

            const buildNoteObject = (content, name) => {
                const cleanContent = normalizeContent(content);
                const finalName = (name && name.trim()) || extractNoteName(cleanContent);
                return { id: generateId(), name: finalName, content: cleanContent, timestamp: Date.now() };
            };

            const addNote = (bookId, chapterId, content, name) => {
                if (!content || !content.trim()) return;
                const note = buildNoteObject(content, name);
                const now = Date.now();
                setBooks(books.map(b => b.id === bookId ? touchBook({ ...b, chapters: b.chapters.map(c => c.id === chapterId ? { ...c, notes: [...c.notes, note] } : c) }, now) : b));
                requestImmediateFirestoreSave();
            };

            const addLinkNote = (bookId, chapterId, note) => {
                if (!note || !note.url) return;
                const now = Date.now();
                setBooks(books.map(b => b.id === bookId ? touchBook({
                    ...b,
                    chapters: b.chapters.map(c => c.id === chapterId ? { ...c, notes: [...c.notes, note] } : c)
                }, now) : b));
                requestImmediateFirestoreSave();
            };

            const addBookNote = (bookId, content, name) => {
                if (!content || !content.trim()) return;
                const note = buildNoteObject(content, name);
                updateBookTempNotes(bookId, (notes) => [...notes, note]);
                requestImmediateFirestoreSave();
            };

            const addRootNote = (content, name) => {
                if (!content || !content.trim()) return;
                const note = buildNoteObject(content, name);

                setBooks(prevBooks => {
                    let updated = [...prevBooks];
                    const hasActiveBook = !!activeBookId && updated.some(b => b.id === activeBookId);
                    const now = Date.now();

                    if (hasActiveBook) {
                        const ensured = ensureTempChapterInBook(updated, activeBookId);
                        if (!ensured.chapterId) return prevBooks;
                        updated = ensured.books;
                        const withNotes = updateChapterNotesInBooks(updated, activeBookId, ensured.chapterId, (notes) => [...notes, note], now);
                        requestImmediateFirestoreSave();
                        return withNotes;
                    }

                    const ensured = ensureTempBookAndChapter(updated);
                    if (!ensured.tempBookId || !ensured.tempChapterId) return prevBooks;
                    updated = ensured.books;
                    const withNotes = updateChapterNotesInBooks(updated, ensured.tempBookId, ensured.tempChapterId, (notes) => [...notes, note], now);
                    requestImmediateFirestoreSave();
                    return withNotes;
                });
            };

            const reorderRootNotesByIndex = useCallback((from, to) => {
                setRootNotes(prev => moveItem(prev, from, to));
                requestImmediateFirestoreSave();
            }, []);

            const reorderRootNote = (noteId, direction) => {
                const currentNotes = rootNotes;
                const index = currentNotes.findIndex(n => n.id === noteId);
                if (index < 0) return;
                const target = index + direction;
                if (target < 0 || target >= currentNotes.length) return;
                setRootNotes(prev => moveItem(prev, index, target));
                requestImmediateFirestoreSave();
            };
            const reorderBookNote = (bookId, noteId, direction) => {
                const book = books.find(b => b.id === bookId);
                if (!book) return;
                const index = book.notes?.findIndex(n => n.id === noteId) ?? -1;
                if (index < 0) return;
                const target = index + direction;
                if (target < 0 || !book.notes || target >= book.notes.length) return;
                updateBookNotes(bookId, moveItem(book.notes, index, target));
            };
            const reorderBookNotesByIndex = useCallback((bookId, from, to) => {
                const now = Date.now();
                setBooks(prev => prev.map(b => b.id === bookId ? touchBook({ ...b, notes: moveItem(b.notes || [], from, to) }, now) : b));
                requestImmediateFirestoreSave();
            }, []);
            const chooseDestination = async (source) => {
                const ensureDestinations = (currentBooks) => {
                    const ensuredTemp = ensureTempBookAndChapter(currentBooks);
                    let updatedBooks = ensuredTemp.books;
                    let changed = ensuredTemp.changed;

                    const ensuredPreliminary = ensurePreliminaryChaptersEverywhere(updatedBooks);
                    updatedBooks = ensuredPreliminary.books;
                    changed = changed || ensuredPreliminary.changed;

                    if (changed) setBooks(updatedBooks);
                    return updatedBooks;
                };

                const booksForOptions = ensureDestinations(books);
                const options = buildDestinations(booksForOptions, source);
                if (options.length === 0) { alert('No hay destinos disponibles.'); return null; }
                return await openPickerWithOptions(options, 'Elige dónde guardar');
            };
            const relocateNote = (source, destination, noteId, mode = 'move') => {
                const findNote = () => {
                    if (source.type === 'root') return rootNotes.find(n => n.id === noteId);
                    if (source.type === 'book') return books.find(b => b.id === source.bookId)?.notes?.find(n => n.id === noteId);
                    if (source.type === 'chapter') return books.find(b => b.id === source.bookId)?.chapters.find(c => c.id === source.chapterId)?.notes.find(n => n.id === noteId);
                    return null;
                };
                const note = findNote();
                if (!note) return;
                const noteForDestination = mode === 'copy' ? cloneNote(note) : note;

                if (destination.type === 'root') {
                    setRootNotes(notes => {
                        if (mode === 'move' && source.type === 'root') {
                            return [...notes.filter(n => n.id !== noteId), noteForDestination];
                        }
                        return [...notes, noteForDestination];
                    });
                }

                const now = Date.now();
                setBooks(prevBooks => prevBooks.map(book => {
                    let updatedBook = book;
                    let changed = false;

                    // Eliminar del origen si corresponde
                    if (mode === 'move') {
                        if (source.type === 'book' && book.id === source.bookId) {
                            updatedBook = { ...updatedBook, notes: (updatedBook.notes || []).filter(n => n.id !== noteId) };
                            changed = true;
                        }
                        if (source.type === 'chapter' && book.id === source.bookId) {
                            updatedBook = {
                                ...updatedBook,
                                chapters: updatedBook.chapters.map(c => c.id === source.chapterId ? { ...c, notes: c.notes.filter(n => n.id !== noteId) } : c)
                            };
                            changed = true;
                        }
                    }

                    // Agregar al destino
                    if (destination.type === 'book' && book.id === destination.bookId) {
                        updatedBook = { ...updatedBook, notes: [...(updatedBook.notes || []), noteForDestination] };
                        changed = true;
                    }
                    if (destination.type === 'chapter' && book.id === destination.bookId) {
                        updatedBook = {
                            ...updatedBook,
                            chapters: updatedBook.chapters.map(c => c.id === destination.chapterId ? { ...c, notes: [...c.notes, noteForDestination] } : c)
                        };
                        changed = true;
                    }

                    return changed ? touchBook(updatedBook, now) : updatedBook;
                }));

                if (source.type === 'root' && mode === 'move' && destination.type !== 'root') setRootNotes(notes => notes.filter(n => n.id !== noteId));
                requestImmediateFirestoreSave();
            };
            const editNote = (bookId, chapterId, noteId, content, name) => {
                const cleanContent = normalizeContent(content);
                const finalName = (name && name.trim()) || extractNoteName(cleanContent);
                const now = Date.now();
                setBooks(books.map(b => b.id === bookId ? touchBook({ ...b, chapters: b.chapters.map(c => c.id === chapterId ? { ...c, notes: c.notes.map(n => n.id === noteId ? { ...n, content: cleanContent, name: finalName } : n) } : c) }, now) : b));
                requestImmediateFirestoreSave();
            };
            const updateNotes = (bookId, chapterId, newNotes) => {
                const now = Date.now();
                setBooks(books.map(b => b.id === bookId ? touchBook({ ...b, chapters: b.chapters.map(c => c.id === chapterId ? { ...c, notes: newNotes } : c) }, now) : b));
                requestImmediateFirestoreSave();
            };
            const updateBookNotes = (bookId, newNotes) => {
                const now = Date.now();
                setBooks(books.map(b => b.id === bookId ? touchBook({ ...b, notes: newNotes }, now) : b));
                requestImmediateFirestoreSave();
            };
            const updateBookChapters = (bookId, newChapters) => {
                const now = Date.now();
                setBooks(books.map(b => b.id === bookId ? touchBook({ ...b, chapters: newChapters }, now) : b));
                requestImmediateFirestoreSave();
            };
            const deleteChapter = (bookId, chapterId) => {
                const now = Date.now();
                setBooks(books.map(b => b.id === bookId ? touchBook({ ...b, chapters: b.chapters.filter(c => c.id !== chapterId) }, now) : b));
                requestImmediateFirestoreSave();
            };
            const reorderChapter = (bookId, chapterId, direction) => {
                const book = books.find(b => b.id === bookId);
                const index = book?.chapters.findIndex(c => c.id === chapterId);
                if (index === undefined || index < 0) return;
                const target = index + direction;
                if (target < 0 || !book || target >= book.chapters.length) return;
                const newChapters = moveItem(book.chapters, index, target);
                updateBookChapters(bookId, newChapters);
            };
            const copyChapterToBook = (sourceBookId, chapterId, targetBookId) => {
                const source = books.find(b => b.id === sourceBookId);
                const target = books.find(b => b.id === targetBookId);
                if (!source || !target) return;
                const chapter = source.chapters.find(c => c.id === chapterId);
                if (!chapter) return;
                const cloned = { ...chapter, id: generateId(), notes: chapter.notes.map(cloneNote) };
                const now = Date.now();
                setBooks(books.map(b => b.id === targetBookId ? touchBook({ ...b, chapters: [...b.chapters, cloned] }, now) : b));
                requestImmediateFirestoreSave();
            };
            const moveChapterToBook = (sourceBookId, chapterId, targetBookId) => {
                if (sourceBookId === targetBookId) return;
                const source = books.find(b => b.id === sourceBookId);
                const chapter = source?.chapters.find(c => c.id === chapterId);
                if (!chapter) return;
                const cleanedSource = source.chapters.filter(c => c.id !== chapterId);
                const now = Date.now();
                setBooks(books.map(b => {
                    if (b.id === sourceBookId) return touchBook({ ...b, chapters: cleanedSource }, now);
                    if (b.id === targetBookId) return touchBook({ ...b, chapters: [...b.chapters, chapter] }, now);
                    return b;
                }));
                requestImmediateFirestoreSave();
            };

            const resetMoveModes = () => {
                booksMoveMode.exitMoveMode();
                rootNotesMoveMode.exitMoveMode();
                bookNotesMoveMode.exitMoveMode();
                chaptersMoveMode.exitMoveMode();
                setBookSelectionMode(false);
                setSelectedBookIds([]);
                setActiveSelectedBookId(null);
                setChapterSelectionMode(false);
                setSelectedChapterIds([]);
                setActiveSelectedChapterId(null);
            };

            const goHome = () => { resetMoveModes(); setView('home'); setActiveBookId(null); setActiveChapterId(null); };
            const goBook = (id) => { resetMoveModes(); setActiveBookId(id); setView('book'); };
            const goChapter = (id) => { resetMoveModes(); setActiveChapterId(id); setView('chapter'); };
            const goSettings = () => setView('settings');

        const buildCloudPayload = () => ({
            books,
            rootNotes,
            settings,
            collections,
            view,
            libraryView,
            activeCollectionId,
            collectionViewMode,
            activeBookId,
            activeChapterId,
            timestamp: Date.now()
        });

        const sanitizeForFirestore = (value) => {
            if (value === undefined) return null;
            if (Array.isArray(value)) return value.map(sanitizeForFirestore).filter((v) => v !== undefined);
            if (value && typeof value === 'object') {
                return Object.entries(value).reduce((cleaned, [key, val]) => {
                    const safeVal = sanitizeForFirestore(val);
                    if (safeVal !== undefined) cleaned[key] = safeVal;
                    return cleaned;
                }, {});
            }
            return value;
        };

            const handleFirebaseLogin = async () => {
                if (!firebaseReady || !authRef.current) {
                    return alert('Firebase no está listo aún.');
                }
                setCloudStatus('loading');
                setCloudMessage('Iniciando sesión...');
                try {
                    const provider = new firebase.auth.GoogleAuthProvider();
                    await authRef.current.signInWithPopup(provider);
                    setCloudStatus('success');
                    setCloudMessage('Sesión iniciada.');
                } catch (error) {
                    console.error('Firebase login error', error);
                    setCloudStatus('error');
                    setCloudMessage(error.message);
                }
            };

            const handleFirebaseLogout = async () => {
                if (!firebaseReady || !authRef.current) return;
                setCloudStatus('loading');
                setCloudMessage('Cerrando sesión...');
                try {
                    await authRef.current.signOut();
                    setCloudStatus('success');
                    setCloudMessage('Sesión cerrada.');
                } catch (error) {
                    setCloudStatus('error');
                    setCloudMessage(error.message);
                }
            };

            const handleFirestoreSave = async ({ silent = false } = {}) => {
                if (!firebaseReady || !dbRef.current) {
                    if (!silent) alert('Firebase no está listo.');
                    return;
                }
                if (!authUser) {
                    const message = 'Inicia sesión para guardar en Firestore.';
                    setCloudStatus('error');
                    setCloudMessage(message);
                    if (!silent) alert(message);
                    return;
                }
                setCloudStatus('loading');
                setCloudMessage(silent ? 'Guardado automático en progreso...' : 'Guardando en Firestore...');
                try {
                    const payload = sanitizeForFirestore(buildCloudPayload());
                    await dbRef.current.collection(FIRESTORE_COLLECTION).doc(authUser.uid).set(payload);
                    const now = Date.now();
                    localStorage.setItem(FIRESTORE_SYNC_KEY, String(now));
                    localStorage.setItem(LOCAL_USAGE_KEY, String(now));
                    setCloudStatus('success');
                    setCloudMessage(silent ? 'Guardado automático completado.' : 'Datos guardados en Firestore.');
                } catch (error) {
                    console.error('Firestore save error', error);
                    setCloudStatus('error');
                    setCloudMessage(error.message);
                    if (!silent) alert(error.message);
                }
            };

            const handleFirestoreLoad = async ({ silent = false } = {}) => {
                if (!firebaseReady || !dbRef.current) {
                    if (!silent) alert('Firebase no está listo.');
                    return;
                }
                if (!authUser) {
                    const message = 'Inicia sesión para cargar datos.';
                    setCloudStatus('error');
                    setCloudMessage(message);
                    if (!silent) alert(message);
                    return;
                }
                setCloudStatus('loading');
                setCloudMessage(silent ? 'Sincronizando con Firestore...' : 'Cargando desde Firestore...');
                try {
                    const snap = await dbRef.current.collection(FIRESTORE_COLLECTION).doc(authUser.uid).get();
                    if (!snap.exists) {
                        setCloudStatus('error');
                        setCloudMessage('No hay datos guardados en Firestore.');
                        return;
                    }
                    const data = snap.data();
                    setBooks(normalizeBooksData(data.books || []));
                    setRootNotes(data.rootNotes || []);
                    setSettings({
                        apiKey: data.settings?.apiKey || DEFAULT_API_KEY,
                        model: data.settings?.model || DEFAULT_MODEL,
                        prompts: { ...DEFAULT_PROMPTS, ...(data.settings?.prompts || {}) },
                        speechToText: { ...DEFAULT_SPEECH_CONFIG, ...(data.settings?.speechToText || {}) }
                    });
                    setCollections(ensureCollectionsWithDefault(data.collections || [DEFAULT_COLLECTION]));
                    setView(data.view || 'home');
                    setLibraryView(data.libraryView || 'list');
                    setActiveCollectionId(data.activeCollectionId || null);
                    setCollectionViewMode(data.collectionViewMode || 'grid');
                    setActiveBookId(data.activeBookId || null);
                    setActiveChapterId(data.activeChapterId || null);
                    setDataLoaded(true);
                    const now = data.timestamp || Date.now();
                    localStorage.setItem(FIRESTORE_SYNC_KEY, String(now));
                    localStorage.setItem(LOCAL_USAGE_KEY, String(Date.now()));
                    setCloudStatus('success');
                    setCloudMessage(silent ? 'Sincronización automática completada.' : 'Datos cargados desde Firestore.');
                } catch (error) {
                    console.error('Firestore load error', error);
                    setCloudStatus('error');
                    setCloudMessage(error.message);
                    if (!silent) alert(error.message);
                }
            };

            useEffect(() => {
                if (!shouldBootstrapFromCloud) return;
                if (!firebaseReady || !authUser) return;
                handleFirestoreLoad({ silent: true });
            }, [shouldBootstrapFromCloud, firebaseReady, authUser]);

            useEffect(() => {
                if (!dataLoaded) return;
                if (autoSaveTimeoutRef.current) clearTimeout(autoSaveTimeoutRef.current);

                autoSaveTimeoutRef.current = setTimeout(() => {
                    handleFirestoreSave({ silent: true });
                }, AUTO_FIRESTORE_SAVE_DELAY);

                return () => {
                    if (autoSaveTimeoutRef.current) clearTimeout(autoSaveTimeoutRef.current);
                };
            }, [books, rootNotes, settings, collections, view, libraryView, activeCollectionId, collectionViewMode, activeBookId, activeChapterId]);

            useEffect(() => {
                if (immediateSaveCounter === 0) return;
                handleFirestoreSave({ silent: true });
            }, [immediateSaveCounter]);

            const promptForName = (message, defaultValue = '') => {
                const response = prompt(message, defaultValue ?? '');
                const trimmed = response?.trim();
                return trimmed ? trimmed : null;
            };

            const renameBookWithPrompt = (book) => {
                const newTitle = promptForName('Rename book:', book?.title || '');
                if (!newTitle || !book?.id) return;
                renameBook(book.id, newTitle);
            };

            const renameChapterWithPrompt = (chapter) => {
                const newTitle = promptForName('Rename chapter:', chapter?.title || '');
                if (!newTitle || !activeBookId || !chapter?.id) return;
                renameChapter(activeBookId, chapter.id, newTitle);
            };

            const startDictation = (target) => {
                if (micSupportError) return alert(micSupportError);
                const { engine: engineForRecognition, language } = resolveRecognitionConfig(
                    speechEngines,
                    settings.speechToText
                );

                if (!engineForRecognition?.available && engineForRecognition?.id !== 'ai-assisted') {
                    alert(`${engineForRecognition?.label || 'Motor seleccionado'} no está disponible en este dispositivo. Se usará el motor del navegador.`);
                }

                if (!language) {
                    return alert('Selecciona al menos un idioma en la configuración de voz antes de dictar.');
                }

                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                const recognition = new SpeechRecognition();
                recognition.lang = language;
                recognition.continuous = false;
                recognition.onstart = () => setIsRecording(true);
                recognition.onresult = (e) => {
                    const transcript = e.results[0][0].transcript?.trim();
                    if (!transcript) return;
                    if (target.type === 'root') addRootNote(transcript);
                    if (target.type === 'book') addBookNote(target.bookId, transcript);
                };
                recognition.onerror = (event) => {
                    console.error(event);
                    setIsRecording(false);
                    setRecordingTarget(null);
                    if (event.error === 'not-allowed') alert("Microphone permission denied.");
                };
                recognition.onend = () => {
                    setIsRecording(false);
                    setRecordingTarget(null);
                };
                setRecordingTarget(target);
                recognition.start();
                recognitionRef.current = recognition;
            };

            const toggleDictation = (target) => {
                if (isRecording && recordingTarget?.type === target.type && recordingTarget?.bookId === target.bookId) {
                    recognitionRef.current?.stop();
                } else {
                    if (isRecording) recognitionRef.current?.stop();
                    startDictation(target);
                }
            };

            const openNoteModal = (target) => {
                const initialContent = target?.initialContent || '<p></p>';
                setNoteDraft(initialContent);
                setNoteTitleDraft(target?.initialName || extractNoteName(initialContent));
                setNoteModal({ open: true, target });
            };
            const closeNoteModal = () => { setNoteDraft('<p></p>'); setNoteTitleDraft(''); setNoteModal({ open: false, target: null }); };
            const handleSaveTypedNote = () => {
                const content = normalizeContent(noteDraft);
                const target = noteModal.target;
                if (!target?.onSave) return;
                const name = (noteTitleDraft && noteTitleDraft.trim()) || extractNoteName(content);
                target.onSave(content, name);
                closeNoteModal();
            };

            const closePicker = () => setPicker({ open: false, options: [], title: '', resolve: null });
            const openPickerWithOptions = (options, title = 'Select destination') => new Promise((resolve) => {
                setPicker({ open: true, options, title, resolve });
            });
            const handlePickOption = (option) => {
                if (picker.resolve) picker.resolve(option);
                closePicker();
            };

            const handleSaveSpeechSettings = (speechConfig) => {
                setSettings((prev) => ({
                    ...prev,
                    speechToText: { ...DEFAULT_SPEECH_CONFIG, ...(prev.speechToText || {}), ...speechConfig }
                }));
            };

            const presentAiActions = useCallback(async (options, title = 'Acciones con IA') => {
                if (!options || options.length === 0) return;
                const choice = await openPickerWithOptions(options, title);
                if (choice?.onSelect) {
                    choice.onSelect();
                }
            }, [openPickerWithOptions]);

            const activeBook = books.find(b => b.id === activeBookId);
            const activeChapter = activeBook?.chapters.find(c => c.id === activeChapterId);
            const activeChapterNumber = activeBook ? activeBook.chapters.findIndex(c => c.id === activeChapterId) + 1 : null;

            const pushAsLast = (list, id) => {
                const filtered = list.filter(item => item !== id);
                return [...filtered, id];
            };

            const booksMoveMode = useLongPressMoveMode(500, {
                onEnterMoveMode: (id) => {
                    setBookSelectionMode(true);
                    setSelectedBookIds((prev) => {
                        const updated = pushAsLast(prev, id);
                        setActiveSelectedBookId(id);
                        return updated;
                    });
                }
            });
            const rootNotesMoveMode = useLongPressMoveMode(500);
            const bookNotesMoveMode = useLongPressMoveMode(500);
            const chaptersMoveMode = useLongPressMoveMode(500, {
                onEnterMoveMode: (id) => {
                    setChapterSelectionMode(true);
                    setSelectedChapterIds((prev) => {
                        const updated = pushAsLast(prev, id);
                        setActiveSelectedChapterId(id);
                        return updated;
                    });
                }
            });

            const primaryBookId = selectedBookIds.includes(activeSelectedBookId)
                ? activeSelectedBookId
                : selectedBookIds[selectedBookIds.length - 1];
            const primaryChapterId = selectedChapterIds.includes(activeSelectedChapterId)
                ? activeSelectedChapterId
                : selectedChapterIds[selectedChapterIds.length - 1];
            const primaryChapter = activeBook?.chapters.find(c => c.id === primaryChapterId);

            const menuPortal = (
                <HamburgerMenu
                    open={menuOpen}
                    onClose={() => setMenuOpen(false)}
                    onSettings={() => { setMenuOpen(false); goSettings(); }}
                    onSpeechSettings={() => { setMenuOpen(false); setSpeechConfigOpen(true); }}
                    onLogin={() => { setMenuOpen(false); handleFirebaseLogin(); }}
                    onLogout={() => { setMenuOpen(false); handleFirebaseLogout(); }}
                    authUser={authUser}
                    status={cloudStatus}
                    message={cloudMessage}
                    firebaseReady={firebaseReady}
                    firebaseError={firebaseError}
                />
            );

            const pickerPortal = <OptionPicker state={picker} onSelect={handlePickOption} onClose={() => handlePickOption(null)} />;
            const speechConfigPortal = (
                <SpeechToTextConfig
                    open={speechConfigOpen}
                    onClose={() => setSpeechConfigOpen(false)}
                    engines={speechEngines}
                    selectedEngine={settings.speechToText?.preferredEngine}
                    aiAssistEnabled={settings.speechToText?.aiAssistEnabled}
                    languagePreferences={settings.speechToText?.languagePreferences}
                    onSave={(config) => {
                        handleSaveSpeechSettings(config);
                        setSpeechConfigOpen(false);
                    }}
                />
            );

            // Componente de Pantalla de Carga
            if (loading) {
                return (
                    <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center backdrop-blur-sm">
                        <div className="bg-white p-6 rounded-xl shadow-2xl flex flex-col items-center">
                            <div className="loader mb-4"></div>
                            <p className="text-gray-700 font-medium">Processing with AI...</p>
                        </div>
                    </div>
                );
            }

            // Header
            const Header = ({ title, subtitle = 'VoiceNotes', onBack, accentClass = 'text-slate-900', showMenu = false, rightContent = null }) => (
                <header className="safe-top sticky top-0 z-20 bg-[var(--color-bg)]/95 backdrop-blur border-b border-slate-100 px-4 py-3 flex items-center justify-between shadow-sm">
                    <div className="flex items-center gap-3 min-w-0">
                        {onBack && (
                            <button
                                onClick={onBack}
                                className="w-10 h-10 rounded-full border border-slate-200 bg-white text-slate-600 hover:text-indigo-700 shadow-sm flex items-center justify-center transition"
                            >
                                <Icons.ChevronLeft />
                            </button>
                        )}
                        <div className="min-w-0">
                            <p className="text-[11px] font-semibold text-slate-400 uppercase tracking-[0.16em]">{subtitle}</p>
                            <h1 className={`text-lg font-bold truncate leading-tight ${accentClass}`}>
                                {title}
                            </h1>
                        </div>
                    </div>
                    {rightContent ? rightContent : showMenu && (
                        <button
                            onClick={() => setMenuOpen(true)}
                            className="w-10 h-10 rounded-full border border-slate-200 bg-white text-slate-600 hover:text-indigo-700 shadow-sm flex items-center justify-center transition"
                            aria-label="Abrir menú"
                        >
                            <Icons.Menu />
                        </button>
                    )}
                </header>
            );

            const HomeHeader = ({ bookCount }) => (
                <header className="safe-top sticky top-0 z-20 bg-[var(--color-bg)] px-5 pt-5 pb-4 flex items-center justify-between">
                    <div className="flex flex-col gap-0.5">
                        <h1 className="text-2xl font-bold text-slate-900 leading-tight">Biblioteca</h1>
                        <p className="text-sm text-slate-500">{bookCount} {bookCount === 1 ? 'libro' : 'libros'}</p>
                    </div>
                    <button
                        onClick={() => setMenuOpen(true)}
                        className="w-11 h-11 rounded-full bg-white border border-slate-200 shadow-sm text-slate-600 hover:text-indigo-600 flex items-center justify-center"
                        aria-label="Abrir menú"
                    >
                        <Icons.Menu />
                    </button>
                </header>
            );

            // --- VISTA: SETTINGS (Mejorada) ---
            if (view === 'settings') {
                const testConnection = async () => {
                    setTestStatus('loading');
                    try {
                        await callGemini(settings.apiKey, settings.model, "Di hola", "Test de conexión");
                        setTestStatus('success');
                        setTestMsg("¡Conexión Exitosa!");
                    } catch (e) {
                        setTestStatus('error');
                        setTestMsg(e.message);
                    }
                };

                return (
                    <>
                    <div className="min-h-screen app-surface">
                        <Header title="Configuración" onBack={() => view === 'home' ? null : window.history.back() || goHome()} />
                        <div className="p-4 max-w-2xl mx-auto">
                            <div className="content-shell p-5 md:p-6 space-y-6">

                                {/* Sección API */}
                                <div className="section-card p-4 md:p-5 space-y-4">
                                    <div className="flex items-center justify-between gap-3">
                                        <div>
                                            <p className="text-xs uppercase tracking-[0.2em] text-slate-400 font-bold">Conexión</p>
                                            <h3 className="font-semibold text-slate-800">Gemini API</h3>
                                        </div>
                                        <span className="tag-chip">Configuración segura</span>
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-1">Gemini API Key</label>
                                        <input type="text" value={settings.apiKey} onChange={(e) => setSettings({...settings, apiKey: e.target.value})}
                                            className="w-full p-3 border rounded-lg bg-white text-sm font-mono focus:ring-2 focus:ring-indigo-500 outline-none shadow-inner" placeholder="AIzaSy..." />
                                    </div>

                                    <div className="grid grid-cols-1 gap-3">
                                        <div>
                                            <label className="block text-sm font-medium text-gray-700 mb-1">Modelo (Model Name)</label>
                                            <div className="flex gap-2">
                                                <select
                                                    value={settings.model}
                                                    onChange={(e) => setSettings({...settings, model: e.target.value})}
                                                    className="w-full p-3 border rounded-lg bg-white text-sm focus:ring-2 focus:ring-indigo-500 outline-none shadow-inner"
                                                >
                                                    <option value="gemini-2.0-flash-exp">gemini-2.0-flash-exp (Predeterminado)</option>
                                                    <option value="gemini-1.5-flash">gemini-1.5-flash (Estándar)</option>
                                                    <option value="gemini-1.5-pro">gemini-1.5-pro (Más inteligente)</option>
                                                    <option value="gemini-pro">gemini-pro (Legacy)</option>
                                                </select>
                                            </div>
                                            {/* Opción manual por si acaso */}
                                            <input
                                                type="text"
                                                value={settings.model}
                                                onChange={(e) => setSettings({...settings, model: e.target.value})}
                                                placeholder="Nombre manual del modelo..."
                                                className="w-full mt-2 p-2.5 border border-dashed rounded-md text-xs text-gray-500 bg-white shadow-inner"
                                            />
                                        </div>
                                    </div>

                                    <button onClick={testConnection} disabled={testStatus === 'loading'}
                                        className={`w-full py-3 px-4 rounded-lg text-sm font-semibold border transition flex items-center justify-center gap-2
                                        ${testStatus === 'success' ? 'bg-emerald-50 text-emerald-700 border-emerald-200 shadow-inner' :
                                          testStatus === 'error' ? 'bg-rose-50 text-rose-700 border-rose-200 shadow-inner' : 'bg-indigo-600 text-white border-indigo-700 hover:bg-indigo-700 shadow-md'}`}>
                                        {testStatus === 'loading' ? <div className="loader w-4 h-4 border-2 border-white/70 border-t-transparent"></div> :
                                         testStatus === 'success' ? <Icons.Check /> :
                                         testStatus === 'error' ? <Icons.Alert /> : "Probar Conexión"}
                                        {testStatus === 'loading' ? ' Probando...' : testStatus === 'success' ? ' Conectado' : testStatus === 'error' ? ' Error' : ' Probar Conexión'}
                                    </button>
                                    {testMsg && <p className={`text-xs ${testStatus === 'error' ? 'text-red-600' : 'text-green-600'}`}>{testMsg}</p>}
                                </div>

                                {/* Sección Prompts */}
                                <div className="section-card p-4 md:p-5">
                                    <div className="flex items-center justify-between mb-4">
                                        <div>
                                            <p className="text-xs uppercase tracking-[0.2em] text-slate-400 font-bold">Estilos</p>
                                            <h3 className="font-semibold text-gray-800">Prompts</h3>
                                        </div>
                                        <span className="tag-chip bg-amber-50 text-amber-700 border-amber-200">Personaliza el tono</span>
                                    </div>
                                    <div className="mb-4">
                                        <label className="block text-xs font-bold text-gray-500 uppercase mb-1">Fusión</label>
                                        <textarea value={settings.prompts.merge} onChange={(e) => setSettings({...settings, prompts: {...settings.prompts, merge: e.target.value}})}
                                            className="w-full p-3 border rounded-lg bg-white text-sm h-20 resize-none shadow-inner" />
                                    </div>
                                    <div>
                                        <label className="block text-xs font-bold text-gray-500 uppercase mb-1">Estilo</label>
                                        <textarea value={settings.prompts.style} onChange={(e) => setSettings({...settings, prompts: {...settings.prompts, style: e.target.value}})}
                                            className="w-full p-3 border rounded-lg bg-white text-sm h-20 resize-none shadow-inner" />
                                    </div>
                                    <div className="mt-4">
                                        <label className="block text-xs font-bold text-gray-500 uppercase mb-1">Generación de notas</label>
                                        <textarea value={settings.prompts.generate} onChange={(e) => setSettings({...settings, prompts: {...settings.prompts, generate: e.target.value}})}
                                            className="w-full p-3 border rounded-lg bg-white text-sm h-20 resize-none shadow-inner" />
                                    </div>
                                </div>

                                <button onClick={() => { if(activeChapterId) goChapter(activeChapterId); else if(activeBookId) goBook(activeBookId); else goHome(); }}
                                    className="w-full py-3 pill-button primary-cta font-semibold text-white bg-gradient-to-r from-indigo-600 to-violet-500 border-none shadow-lg">
                                    Guardar y Salir
                                </button>
                            </div>
                        </div>
                    </div>
                    {menuPortal}
                    {pickerPortal}
                    {speechConfigPortal}
                    </>
                );
            }

            const toggleBookSelection = (id) => {
                setBookSelectionMode(true);
                setSelectedBookIds(prev => {
                    const updated = prev.includes(id)
                        ? prev.filter(b => b !== id)
                        : [...prev, id];
                    const preferred = updated.includes(id) ? id : activeSelectedBookId;
                    const nextPrimary = preferred && updated.includes(preferred)
                        ? preferred
                        : (updated[updated.length - 1] || null);
                    setActiveSelectedBookId(nextPrimary);
                    return updated;
                });
                booksMoveMode.exitMoveMode();
            };

            const toggleChapterSelection = (id) => {
                setChapterSelectionMode(true);
                setSelectedChapterIds(prev => {
                    const updated = prev.includes(id)
                        ? prev.filter(c => c !== id)
                        : [...prev, id];
                    const preferred = updated.includes(id) ? id : activeSelectedChapterId;
                    const nextPrimary = preferred && updated.includes(preferred)
                        ? preferred
                        : (updated[updated.length - 1] || null);
                    setActiveSelectedChapterId(nextPrimary);
                    return updated;
                });
                chaptersMoveMode.exitMoveMode();
            };

            const cancelBookSelection = () => {
                setBookSelectionMode(false);
                setSelectedBookIds([]);
                setActiveSelectedBookId(null);
                booksMoveMode.exitMoveMode();
            };

            const cancelChapterSelection = () => {
                setChapterSelectionMode(false);
                setSelectedChapterIds([]);
                setActiveSelectedChapterId(null);
                chaptersMoveMode.exitMoveMode();
            };

            const handleBookBulkDelete = () => {
                if (selectedBookIds.length === 0) return;
                if (!confirm('¿Eliminar libros seleccionados?')) return;
                setBooks(prev => prev.filter(b => !selectedBookIds.includes(b.id)));
                cancelBookSelection();
            };

            const handleChapterBulkDelete = () => {
                if (selectedChapterIds.length === 0) return;
                if (!confirm('¿Eliminar capítulos seleccionados?')) return;
                const now = Date.now();
                setBooks(prev => prev.map(b => b.id === activeBookId ? touchBook({ ...b, chapters: b.chapters.filter(c => !selectedChapterIds.includes(c.id)) }, now) : b));
                cancelChapterSelection();
            };

            const handleBookReorder = (direction) => {
                if (!primaryBookId) return;
                reorderBook(primaryBookId, direction);
            };

            const handleChapterReorder = (direction) => {
                if (!primaryChapterId) return;
                reorderChapter(activeBookId, primaryChapterId, direction);
            };

            const handleBookMoveToPosition = () => {
                if (!primaryBookId) return;
                moveBookToPosition(primaryBookId);
            };

            const handleDuplicateBook = () => {
                if (!primaryBookId) return;
                duplicateBook(primaryBookId);
            };

            const handleRenameBook = () => {
                if (!primaryBookId) return;
                const book = books.find(b => b.id === primaryBookId);
                if (!book) return;
                renameBookWithPrompt(book);
                cancelBookSelection();
            };

            const handleRenameChapter = () => {
                if (!primaryChapterId) return;
                const chapter = activeBook?.chapters.find(c => c.id === primaryChapterId);
                if (!chapter) return;
                renameChapterWithPrompt(chapter);
                cancelChapterSelection();
            };

            const handleChapterMoveOrCopy = async (mode) => {
                if (!primaryChapterId) return;
                const available = books.filter(b => b.id !== activeBookId);
                if (available.length === 0) return alert('No hay otros libros disponibles.');
                const choice = await openPickerWithOptions(available.map(b => ({ label: b.title, bookId: b.id })), mode === 'move' ? 'Mover a libro' : 'Copiar en libro');
                if (!choice?.bookId) return;
                if (mode === 'move') {
                    moveChapterToBook(activeBookId, primaryChapterId, choice.bookId);
                    cancelChapterSelection();
                } else {
                    copyChapterToBook(activeBookId, primaryChapterId, choice.bookId);
                }
            };

            if (view === 'home') {
                const libraryViewOptions = [
                    { id: 'list', label: 'Lista', description: 'Vista detallada', icon: <Icons.Menu /> },
                    { id: 'grid', label: 'Grid', description: 'Vista compacta', icon: <Icons.Grid /> },
                    { id: 'collections', label: 'Colecciones', description: 'Agrupa y organiza', icon: <Icons.Folder /> },
                ];

                const sortOptions = [
                    { id: 'latest', label: 'Últimos modificados' },
                    { id: 'oldest', label: 'Más antiguos (creados)' },
                    { id: 'newest', label: 'Más nuevos (creados)' },
                    { id: 'name', label: 'Nombre (A-Z)' },
                ];

                const activeCollection = activeCollectionId
                    ? booksByCollection.find((collection) => collection.id === activeCollectionId)
                    : null;
                const activeCollectionBooks = activeCollection ? sortBookList(activeCollection.books) : [];
                const currentSortLabel = sortOptions.find(option => option.id === librarySort)?.label || sortOptions[0].label;

                const CollectionBadge = ({ book }) => (
                    <div className="flex items-center gap-2 text-[11px] text-slate-600 mt-0.5">
                        <span className="px-2 py-0.5 rounded-full bg-slate-100 border border-slate-200 font-semibold whitespace-nowrap">
                            {getCollectionName(book.collectionId)}
                        </span>
                        <button
                            onClick={(e) => {
                                e.stopPropagation();
                                moveBookToCollection(book.id);
                            }}
                            className="text-indigo-600 font-semibold"
                        >
                            Mover
                        </button>
                    </div>
                );

                const renderListCards = (bookList = sortedBooks) => (
                    <div className="space-y-2">
                        {bookList.map((book) => {
                            const moveProps = booksMoveMode.getItemProps(book.id);
                            const isSelected = selectedBookIds.includes(book.id);
                            const showMoveControls = bookSelectionMode && primaryBookId === book.id;
                            const totalNotes = (book.notes?.length || 0) + book.chapters.reduce((sum, c) => sum + (c.notes?.length || 0), 0);
                            return (
                                <div
                                    key={book.id}
                                    {...moveProps}
                                    onClick={(e) => {
                                        moveProps.onClick?.(e);
                                        if (e.defaultPrevented) return;
                                        if (bookSelectionMode) {
                                            toggleBookSelection(book.id);
                                        } else {
                                            goBook(book.id);
                                        }
                                    }}
                                    className={`relative overflow-hidden rounded-xl border ${isSelected ? 'ring-2 ring-indigo-200 bg-indigo-50/50 border-indigo-100' : 'border-slate-100 bg-white'} shadow-[0_8px_18px_rgba(15,23,42,0.07)] hover:shadow-[0_12px_24px_rgba(15,23,42,0.1)] transition card-tap`}
                                >
                                    <div className="flex items-center gap-3 p-3">
                                        <button
                                            onClick={(e) => {
                                                e.stopPropagation();
                                                if (bookSelectionMode) {
                                                    toggleBookSelection(book.id);
                                                } else {
                                                    goBook(book.id);
                                                }
                                            }}
                                            className="flex-shrink-0 w-10 h-10 rounded-lg border border-indigo-100 bg-indigo-50 text-indigo-700 flex items-center justify-center shadow-inner"
                                        >
                                            <Icons.Book />
                                        </button>

                                        <div className="flex-1 min-w-0 space-y-1">
                                            <div className="flex items-center justify-between gap-2">
                                                <button
                                                    onClick={(e) => {
                                                        e.stopPropagation();
                                                        if (bookSelectionMode) {
                                                            toggleBookSelection(book.id);
                                                        } else {
                                                            goBook(book.id);
                                                        }
                                                    }}
                                                    className="text-left flex-1"
                                                >
                                                    <h3 className="font-semibold text-slate-900 text-[15px] truncate">
                                                        {book.title}
                                                    </h3>
                                                    <p className="text-[12px] text-slate-500 truncate">{book.chapters.length} cap · {totalNotes} notas</p>
                                                </button>
                                                {showMoveControls && (
                                                    <div className="flex-shrink-0 flex items-center">
                                                        <MoveControls
                                                            onMoveUp={() => reorderBook(book.id, -1)}
                                                            onMoveDown={() => reorderBook(book.id, 1)}
                                                            accentClass="text-blue-800"
                                                        />
                                                    </div>
                                                )}
                                            </div>

                                            <div className="flex items-center justify-between gap-2 text-[11px] text-slate-600">
                                                <CollectionBadge book={book} />
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                );

                const renderGridCards = (bookList = sortedBooks) => (
                    <div className="grid grid-cols-2 sm:grid-cols-3 gap-3">
                        {bookList.map((book) => {
                            const moveProps = booksMoveMode.getItemProps(book.id);
                            const isSelected = selectedBookIds.includes(book.id);
                            const totalNotes = (book.notes?.length || 0) + book.chapters.reduce((sum, c) => sum + (c.notes?.length || 0), 0);
                            return (
                                <div
                                    key={book.id}
                                    {...moveProps}
                                    onClick={(e) => {
                                        moveProps.onClick?.(e);
                                        if (e.defaultPrevented) return;
                                        if (bookSelectionMode) {
                                            toggleBookSelection(book.id);
                                        } else {
                                            goBook(book.id);
                                        }
                                    }}
                                    className={`rounded-2xl border ${isSelected ? 'ring-2 ring-indigo-200 bg-indigo-50/60 border-indigo-100' : 'border-slate-100 bg-white'} shadow-[0_10px_24px_rgba(15,23,42,0.08)] p-3 space-y-2 card-tap transition hover:-translate-y-0.5`}
                                >
                                    <div className="flex items-start justify-between gap-2">
                                        <div className="w-10 h-10 rounded-xl bg-gradient-to-br from-indigo-500/20 to-violet-500/20 border border-indigo-100 text-indigo-700 font-bold flex items-center justify-center">
                                            {book.title.charAt(0).toUpperCase()}
                                        </div>
                                        <span className="text-[11px] font-semibold text-indigo-700 bg-indigo-50 border border-indigo-100 px-2 py-1 rounded-full">
                                            {totalNotes} notas
                                        </span>
                                    </div>
                                    <div>
                                        <p className="font-semibold text-slate-900 text-sm leading-tight truncate">{book.title}</p>
                                        <p className="text-[11px] text-slate-500">{book.chapters.length} cap</p>
                                    </div>
                                    <p className="text-[11px] text-slate-500 h-10 overflow-hidden">{getBookPreview(book)}</p>
                                    <div className="flex items-center justify-between gap-2">
                                        <span className="text-[11px] px-2 py-1 rounded-full bg-slate-100 text-slate-700 font-semibold border border-slate-200 truncate">
                                            {getCollectionName(book.collectionId)}
                                        </span>
                                        <button
                                            onClick={(e) => {
                                                e.stopPropagation();
                                                moveBookToCollection(book.id);
                                            }}
                                            className="text-[11px] font-semibold text-indigo-600"
                                        >
                                            Mover
                                        </button>
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                );

                const renderCollectionsGrid = () => (
                    <div className="grid grid-cols-1 sm:grid-cols-2 gap-2">
                        {booksByCollection.map((collection) => {
                            const previewBooks = sortBookList(collection.books).slice(0, 4);
                            return (
                                <div
                                    key={collection.id}
                                    onClick={() => {
                                        setActiveCollectionId(collection.id);
                                        setCollectionViewMode('grid');
                                    }}
                                    className="rounded-xl border border-slate-100 bg-white p-3 shadow-[0_10px_24px_rgba(15,23,42,0.08)] space-y-2 cursor-pointer transition hover:-translate-y-0.5 hover:border-indigo-100"
                                >
                                    <div className="flex items-center justify-between gap-3">
                                        <div className="min-w-0">
                                            <p className="text-[10px] uppercase tracking-[0.18em] text-slate-400 font-bold">Colección</p>
                                            <h3 className="text-base font-semibold text-slate-900 leading-tight truncate">{collection.name}</h3>
                                            <p className="text-[12px] text-slate-500">{collection.books.length} {collection.books.length === 1 ? 'libro' : 'libros'}</p>
                                        </div>
                                        <div className="w-10 h-10 rounded-lg bg-indigo-50 text-indigo-600 flex items-center justify-center font-bold border border-indigo-100 shadow-inner">
                                            {collection.name.charAt(0).toUpperCase()}
                                        </div>
                                    </div>

                                    <div className="grid grid-cols-2 gap-2">
                                        {previewBooks.length > 0 ? (
                                            previewBooks.map(book => (
                                                <div key={book.id} className="p-2 rounded-lg bg-slate-50 border border-slate-200 text-[12px] font-semibold text-slate-800 truncate">
                                                    {book.title}
                                                </div>
                                            ))
                                        ) : (
                                            <p className="col-span-2 text-sm text-slate-500">Mueve libros a esta colección para ver vistas previas.</p>
                                        )}
                                    </div>
                                    {collection.books.length > previewBooks.length && (
                                        <p className="text-[11px] font-semibold text-indigo-600">+{collection.books.length - previewBooks.length} más</p>
                                    )}
                                </div>
                            );
                        })}
                    </div>
                );

                const renderActiveCollectionView = () => {
                    if (!activeCollection) return null;

                    const collectionBooks = activeCollectionBooks;
                    const collectionViewOptions = [
                        { id: 'list', label: 'Lista', icon: <Icons.Menu /> },
                        { id: 'grid', label: 'Grid', icon: <Icons.Grid /> },
                    ];

                    return (
                        <div className="space-y-4">
                            <div className="flex items-center justify-between gap-3 flex-wrap">
                                <div>
                                    <p className="text-[11px] uppercase tracking-[0.2em] text-slate-400 font-bold">Colección activa</p>
                                    <h3 className="text-base font-semibold text-slate-900 leading-tight">{activeCollection.name}</h3>
                                    <p className="text-xs text-slate-500">{collectionBooks.length} {collectionBooks.length === 1 ? 'libro' : 'libros'}</p>
                                </div>
                                <div className="flex items-center gap-2 bg-slate-100 border border-slate-200 rounded-full p-1 overflow-x-auto w-full sm:w-auto">
                                    {collectionViewOptions.map((option) => (
                                        <button
                                            key={option.id}
                                            onClick={() => setCollectionViewMode(option.id)}
                                            className={`flex items-center gap-2 px-3 py-1.5 rounded-full text-sm font-semibold flex-shrink-0 ${collectionViewMode === option.id ? 'bg-white shadow text-indigo-700 border border-indigo-100' : 'text-slate-600'}`}
                                        >
                                            <span className={`w-8 h-8 rounded-full flex items-center justify-center ${collectionViewMode === option.id ? 'bg-indigo-50 text-indigo-700' : 'bg-white text-slate-500 border border-slate-200'}`}>
                                                {option.icon}
                                            </span>
                                            {option.label}
                                        </button>
                                    ))}
                                </div>
                            </div>

                            {collectionBooks.length === 0 ? (
                                <div className="p-4 rounded-2xl bg-white border border-slate-100 shadow-sm">
                                    <p className="text-sm text-slate-600">No hay libros en esta colección. Mueve libros existentes o crea nuevos para comenzar.</p>
                                </div>
                            ) : (
                                collectionViewMode === 'list'
                                    ? renderListCards(collectionBooks)
                                    : renderGridCards(collectionBooks)
                            )}
                        </div>
                    );
                };

                return (
                    <>
                    <div className="min-h-screen flex flex-col app-surface">
                        {(libraryView === 'collections' && activeCollection) ? (
                            <header className="safe-top sticky top-0 z-20 bg-[var(--color-bg)] px-5 pt-5 pb-4 flex items-center gap-3">
                                <button
                                    onClick={() => setActiveCollectionId(null)}
                                    className="icon-btn"
                                    aria-label="Volver a la biblioteca"
                                >
                                    <Icons.ChevronLeft />
                                </button>
                                <div className="flex flex-col gap-0.5">
                                    <p className="text-[11px] uppercase tracking-[0.2em] text-slate-400 font-bold">Colección</p>
                                    <h1 className="text-xl font-bold text-slate-900 leading-tight">Colección: {activeCollection.name}</h1>
                                    <p className="text-xs text-slate-500">{activeCollection.books.length} {activeCollection.books.length === 1 ? 'libro' : 'libros'}</p>
                                </div>
                            </header>
                        ) : (
                            <HomeHeader bookCount={books.length} />
                        )}

                        <main className="flex-1 px-5 pt-2 pb-28 max-w-xl mx-auto w-full space-y-4">
                            {!(libraryView === 'collections' && activeCollection) && (
                                <div className="flex flex-wrap items-center gap-2">
                                    <div className="bg-white border border-slate-100 rounded-xl shadow-sm p-1 flex gap-1 overflow-x-auto">
                                        {libraryViewOptions.map(option => (
                                            <button
                                                key={option.id}
                                                onClick={() => {
                                                    setLibraryView(option.id);
                                                    if (option.id !== 'collections') setActiveCollectionId(null);
                                                }}
                                                className={`flex-1 min-w-[110px] flex items-center gap-1.5 px-2 py-1.5 rounded-lg border text-[13px] font-semibold transition ${libraryView === option.id ? 'border-indigo-200 bg-indigo-50/80 text-indigo-700 shadow-inner' : 'border-slate-100 bg-slate-50 text-slate-600 hover:border-indigo-100 hover:text-indigo-700'}`}
                                            >
                                                <div className={`w-7 h-7 rounded-md flex items-center justify-center ${libraryView === option.id ? 'bg-white text-indigo-700' : 'bg-white/70 text-slate-500'} shadow-inner`}>
                                                    {option.icon}
                                                </div>
                                                <span className="truncate">{option.label}</span>
                                            </button>
                                        ))}
                                    </div>
                                    {libraryView !== 'collections' && (
                                        <button
                                            onClick={async () => {
                                                const choice = await openPickerWithOptions(sortOptions.map(option => ({ label: option.label, id: option.id })), 'Ordenar por');
                                                if (choice?.id) setLibrarySort(choice.id);
                                            }}
                                            className="shrink-0 inline-flex items-center gap-2 px-3 py-2 rounded-lg border border-slate-200 bg-white text-sm font-semibold text-slate-700 shadow-sm hover:border-indigo-200 hover:text-indigo-700"
                                        >
                                            <span className="w-7 h-7 rounded-md bg-indigo-50 text-indigo-700 border border-indigo-100 flex items-center justify-center"><Icons.Sort /></span>
                                            <span className="truncate">Ordenar</span>
                                            <span className="text-xs text-slate-500">{currentSortLabel}</span>
                                        </button>
                                    )}
                                </div>
                            )}

                            {libraryView !== 'collections' && bookSelectionMode && (
                                <div className="p-4 bg-white rounded-2xl shadow-sm border border-indigo-50 space-y-3">
                                    <div className="flex items-center justify-between gap-2 flex-wrap">
                                        <span className="text-sm font-semibold text-indigo-800">{selectedBookIds.length} seleccionados</span>
                                        <button onClick={cancelBookSelection} className="text-xs px-3 py-1.5 rounded-full bg-slate-100 text-slate-600 font-medium">Cancelar</button>
                                    </div>
                                    <div className="flex flex-wrap gap-2">
                                        <button disabled={!primaryBookId} onClick={handleBookMoveToPosition} className={`text-xs px-3 py-1.5 rounded-full border font-semibold ${primaryBookId ? 'bg-indigo-50 text-indigo-700 border-indigo-200' : 'bg-gray-50 text-gray-400 border-gray-200 cursor-not-allowed'}`}>Mover</button>
                                        <button disabled={!primaryBookId} onClick={handleRenameBook} className={`text-xs px-3 py-1.5 rounded-full border font-semibold ${primaryBookId ? 'bg-blue-100 text-blue-800 border-blue-200' : 'bg-gray-50 text-gray-400 border-gray-200 cursor-not-allowed'}`}>Renombrar</button>
                                        <button disabled={!primaryBookId} onClick={handleDuplicateBook} className={`text-xs px-3 py-1.5 rounded-full border font-semibold ${primaryBookId ? 'bg-purple-50 text-purple-700 border-purple-200' : 'bg-gray-50 text-gray-400 border-gray-200 cursor-not-allowed'}`}>Copiar</button>
                                        <button disabled={selectedBookIds.length === 0} onClick={handleBookBulkDelete} className={`text-xs px-3 py-1.5 rounded-full border font-semibold ${selectedBookIds.length > 0 ? 'bg-red-50 text-red-700 border-red-200' : 'bg-gray-50 text-gray-400 border-gray-200 cursor-not-allowed'}`}>Eliminar</button>
                                    </div>
                                </div>
                            )}

                            {libraryView === 'collections' ? (
                                <div className="space-y-3">
                                    {activeCollection ? renderActiveCollectionView() : renderCollectionsGrid()}
                                    <div className="pt-2 space-y-2">
                                        {activeCollection ? (
                                            <button
                                                onClick={() => {
                                                    const title = promptForName("Nuevo libro:");
                                                    if (title) addBook(title, activeCollection.id);
                                                }}
                                                className="w-full flex items-center justify-center gap-2 border-2 border-dashed border-slate-200 rounded-xl py-4 text-slate-500 bg-white shadow-sm hover:border-indigo-200 hover:text-indigo-600 transition"
                                            >
                                                <Icons.Plus />
                                                <span>Crear Libro</span>
                                            </button>
                                        ) : (
                                            <>
                                                <button
                                                    onClick={handleCreateCollection}
                                                    className="w-full flex items-center justify-center gap-2 border-2 border-dashed border-slate-200 rounded-xl py-4 text-slate-600 bg-white shadow-sm hover:border-indigo-200 hover:text-indigo-700 transition"
                                                >
                                                    <Icons.Plus />
                                                    <span>Crear colección</span>
                                                </button>
                                                <button
                                                    onClick={() => {
                                                        const title = promptForName("Nuevo libro:");
                                                        if (title) addBook(title);
                                                    }}
                                                    className="w-full flex items-center justify-center gap-2 border-2 border-dashed border-slate-200 rounded-xl py-4 text-slate-500 bg-white shadow-sm hover:border-indigo-200 hover:text-indigo-600 transition"
                                                >
                                                    <Icons.Plus />
                                                    <span>Crear Libro</span>
                                                </button>
                                            </>
                                        )}
                                    </div>
                                </div>
                            ) : (
                                <>
                                    {books.length === 0 && (
                                        <div className="text-center py-10 text-gray-400">
                                            <p>No tienes libros creados.</p>
                                        </div>
                                    )}

                                    {libraryView === 'list' ? renderListCards() : renderGridCards()}

                                    {rootNotes.length > 0 && (
                                        <div className="space-y-2">
                                            {rootNotes.map(note => {
                                                const moveProps = rootNotesMoveMode.getItemProps(note.id);
                                                return (
                                                    <NoteChip
                                                        key={note.id}
                                                        note={note}
                                                        moveHandlers={moveProps}
                                                        moveModeActive={rootNotesMoveMode.moveModeId === note.id}
                                                        actions={{
                                                            onEdit: () => openNoteModal({
                                                                title: 'Editar nota',
                                                                initialContent: note.content,
                                                                initialName: note.name,
                                                                onSave: (html, name) => setRootNotes((notes) => notes.map(n => n.id === note.id ? { ...n, content: html, name } : n))
                                                            }),
                                                            onMoveUp: () => reorderRootNote(note.id, -1),
                                                            onMoveDown: () => reorderRootNote(note.id, 1)
                                                        }}
                                                    />
                                                );
                                            })}
                                        </div>
                                    )}

                                    <div className="pt-2">
                                        <button
                                            onClick={() => {
                                                const title = promptForName("Nuevo libro:");
                                                if (title) addBook(title);
                                            }}
                                            className="w-full flex items-center justify-center gap-2 border-2 border-dashed border-slate-200 rounded-xl py-4 text-slate-500 bg-white shadow-sm hover:border-indigo-200 hover:text-indigo-600 transition"
                                        >
                                            <Icons.Plus />
                                            <span>Crear Libro</span>
                                        </button>
                                    </div>
                                </>
                            )}
                        </main>

                        <div className="fixed bottom-6 left-1/2 transform -translate-x-1/2 z-20 flex flex-col items-center gap-2">
                            {isRecording && recordingTarget?.type === 'root' && <p className="bg-black/70 text-white text-xs px-2 py-1 rounded whitespace-nowrap animate-pulse">Escuchando...</p>}
                            <div className="flex items-center gap-3">
                                <button onClick={() => openNoteModal({ title: 'Nueva nota rápida', onSave: (html, name) => addRootNote(html, name) })} className="w-12 h-12 rounded-full bg-white border border-slate-200 text-slate-700 flex items-center justify-center shadow-lg hover:-translate-y-0.5 transition" title="Escribir nota">
                                    <Icons.Pencil />
                                </button>
                                <button
                                    onClick={() => toggleDictation({ type: 'root' })}
                                    disabled={!!micSupportError}
                                    className={`w-14 h-14 rounded-full flex items-center justify-center shadow-[0_14px_36px_rgba(59,130,246,0.45)] transition-all duration-300 text-white ${isRecording && recordingTarget?.type === 'root' ? 'bg-red-500 pulse-ring scale-110' : 'bg-gradient-to-br from-indigo-500 to-blue-600 hover:scale-105'} ${micSupportError ? 'bg-gray-400 cursor-not-allowed hover:scale-100 hover:from-gray-400 hover:to-gray-400' : ''}`}
                                >
                                    {isRecording && recordingTarget?.type === 'root' ? <div className="w-6 h-6 bg-white rounded-sm" /> : <Icons.Mic />}
                                </button>
                            </div>
                        </div>

                        <NoteEditorModal
                            isOpen={noteModal.open}
                            title={noteModal.target?.title || 'Nueva nota'}
                            value={noteDraft}
                            nameValue={noteTitleDraft}
                            onNameChange={setNoteTitleDraft}
                            onChange={setNoteDraft}
                            onSave={handleSaveTypedNote}
                            onClose={closeNoteModal}
                        />

                    </div>
                    {menuPortal}
                    {pickerPortal}
                    {speechConfigPortal}
                    </>
                );
            }
            if (view === 'book' && activeBook) {
                const handleStyleBook = async () => {
                    if(activeBook.chapters.length === 0) return alert("Libro vacío.");
                    const styleDesc = prompt("Describe el estilo para todo el libro:");
                    if (!styleDesc) return;
                    setLoading(true);
                    try {
                        let newChapters = JSON.parse(JSON.stringify(activeBook.chapters));
                        for (let chapter of newChapters) {
                            if (chapter.notes.length === 0) continue;
                            const chapterText = chapter.notes.map(n => n.content).join("\n");
                            const finalPrompt = settings.prompts.style.replace('{STYLE}', styleDesc);
                            const newText = await callGemini(settings.apiKey, settings.model, finalPrompt, chapterText);
                            chapter.notes = [buildNoteObject(newText)];
                        }
                        updateBookChapters(activeBook.id, newChapters);
                        alert("¡Libro reescrito!");
                    } catch (e) { alert("Error: " + e.message); } finally { setLoading(false); }
                };

                const handleGenerateBook = async () => {
                    if(activeBook.chapters.length === 0) return alert("Libro vacío.");
                    const promptText = prompt("¿Qué necesitas generar a partir del libro?");
                    if (!promptText) return;
                    setLoading(true);
                    try {
                        const bookContent = activeBook.chapters.map(ch => `Capítulo: ${ch.title}\n${ch.notes.map(n => n.content).join('\n')}`).join('\n\n');
                        const finalPrompt = `${settings.prompts.generate}\n\nPetición: ${promptText}`;
                        const newText = await callGemini(settings.apiKey, settings.model, finalPrompt, bookContent);
                        const newChapterId = generateId();
                        const newNote = buildNoteObject(newText);
                        const now = Date.now();
                        setBooks(books.map(b => b.id === activeBook.id ? touchBook({
                            ...b,
                            chapters: [...b.chapters, { id: newChapterId, title: `Generado ${new Date().toLocaleTimeString()}`, notes: [newNote] }]
                        }, now) : b));
                        alert("Nueva nota generada y guardada en un capítulo nuevo.");
                    } catch (e) { alert("Error: " + e.message); } finally { setLoading(false); }
                };

                const openBookAiMenu = () => {
                    const options = [
                        { label: 'Generar nuevo capítulo', onSelect: handleGenerateBook },
                        { label: 'Re-estilar libro', onSelect: handleStyleBook }
                    ];
                    presentAiActions(options, 'Acciones IA de libro');
                };

                return (
                    <>
                    <div className="min-h-screen flex flex-col app-surface">
                        <Header
                            title={activeBook.title}
                            subtitle="Vista de Libro"
                            onBack={goHome}
                            accentClass="text-slate-900"
                            rightContent={<AiCornerButton onClick={openBookAiMenu} title="Acciones IA del libro" />}
                        />
                        <main className="flex-1 px-4 pt-5 pb-28 max-w-md mx-auto w-full">
                            <div className="space-y-4">
                                {chapterSelectionMode && (
                                    <div className="p-3 bg-white rounded-xl shadow border border-violet-100 space-y-2">
                                        <div className="flex items-center justify-between gap-2 flex-wrap">
                                            <span className="text-sm font-semibold text-violet-800">{selectedChapterIds.length} seleccionados</span>
                                            <button onClick={cancelChapterSelection} className="text-xs px-3 py-1.5 rounded-full bg-gray-100 text-gray-600 font-medium">Cancelar</button>
                                        </div>
                                        <div className="flex flex-wrap gap-2">
                                            <button disabled={!primaryChapterId} onClick={() => handleChapterMoveOrCopy('move')} className={`text-xs px-3 py-1.5 rounded-full border font-semibold ${primaryChapterId ? 'bg-indigo-50 text-indigo-700 border-indigo-200' : 'bg-gray-50 text-gray-400 border-gray-200 cursor-not-allowed'}`}>Mover de libro</button>
                                            <button disabled={!primaryChapterId} onClick={() => handleChapterMoveOrCopy('copy')} className={`text-xs px-3 py-1.5 rounded-full border font-semibold ${primaryChapterId ? 'bg-purple-50 text-purple-700 border-purple-200' : 'bg-gray-50 text-gray-400 border-gray-200 cursor-not-allowed'}`}>Copiar</button>
                                            <button disabled={!primaryChapterId} onClick={handleRenameChapter} className={`text-xs px-3 py-1.5 rounded-full border font-semibold ${primaryChapterId ? 'bg-violet-100 text-violet-900 border-violet-200' : 'bg-gray-50 text-gray-400 border-gray-200 cursor-not-allowed'}`}>Renombrar</button>
                                            <button disabled={selectedChapterIds.length === 0} onClick={handleChapterBulkDelete} className={`text-xs px-3 py-1.5 rounded-full border font-semibold ${selectedChapterIds.length > 0 ? 'bg-red-50 text-red-700 border-red-200' : 'bg-gray-50 text-gray-400 border-gray-200 cursor-not-allowed'}`}>Eliminar</button>
                                        </div>
                                    </div>
                                )}

                                {activeBook.chapters.length === 0 && <div className="text-center py-10 text-gray-400"><p>Libro vacío.</p></div>}
                                <div className="space-y-3">
                                    {activeBook.chapters.map((chap, idx) => {
                                        const moveProps = chaptersMoveMode.getItemProps(chap.id);
                                        const isSelected = selectedChapterIds.includes(chap.id);
                                        const showMoveControls = chapterSelectionMode && primaryChapterId === chap.id;
                                        const chapterNumber = idx + 1;
                                        return (
                                        <div
                                            key={chap.id}
                                            {...moveProps}
                                            onClick={(e) => {
                                                moveProps.onClick?.(e);
                                                if (e.defaultPrevented) return;
                                                if (chapterSelectionMode) {
                                                    toggleChapterSelection(chap.id);
                                                } else {
                                                    goChapter(chap.id);
                                                }
                                            }}
                                            className={`relative overflow-hidden rounded-2xl border border-slate-100 bg-white shadow-md p-4 flex items-center gap-3 transition ${isSelected ? 'ring-2 ring-violet-200 bg-violet-50' : 'hover:-translate-y-0.5 hover:shadow-lg'}`}
                                        >
                                            <button
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    if (chapterSelectionMode) {
                                                        toggleChapterSelection(chap.id);
                                                    } else {
                                                        goChapter(chap.id);
                                                    }
                                                }}
                                                className="flex-shrink-0 w-12 h-12 rounded-xl bg-indigo-50 text-indigo-600 flex items-center justify-center shadow-inner"
                                            >
                                                <span className="text-xl font-extrabold text-indigo-600 leading-none">{chapterNumber}.</span>
                                            </button>

                                            <div className="flex-1 min-w-0">
                                                <h3 className="font-semibold text-slate-900 text-base truncate">
                                                    {chap.title}
                                                </h3>
                                                <p className="text-xs text-slate-400">Capítulo {chapterNumber}</p>
                                            </div>

                                            <span className="text-[11px] font-semibold text-indigo-700 bg-indigo-50 border border-indigo-100 px-3 py-1 rounded-full">
                                                {chap.notes.length} notas
                                            </span>

                                            {showMoveControls && (
                                                <div className="flex-shrink-0 flex items-center">
                                                    <MoveControls
                                                        onMoveUp={() => reorderChapter(activeBook.id, chap.id, -1)}
                                                        onMoveDown={() => reorderChapter(activeBook.id, chap.id, 1)}
                                                        accentClass="text-violet-800"
                                                    />
                                                </div>
                                            )}
                                        </div>
                                        );
                                    })}

                                    <button
                                        onClick={() => {
                                            const title = promptForName("Nuevo capítulo:");
                                            if (title) addChapter(activeBook.id, title);
                                        }}
                                        className="w-full border-2 border-dashed border-slate-300 rounded-2xl bg-white text-slate-500 py-3 shadow-sm hover:border-indigo-300 active:scale-[0.99] transition"
                                    >
                                        <div className="flex items-center justify-center gap-3">
                                            <span className="w-10 h-10 rounded-full bg-indigo-50 text-indigo-600 flex items-center justify-center">
                                                <Icons.Plus />
                                            </span>
                                            <span className="font-semibold text-slate-500">Nuevo Capítulo</span>
                                        </div>
                                    </button>
                                </div>

                                {activeBook.notes?.length > 0 && (
                                    <div className="space-y-2">
                                        {activeBook.notes.map(note => {
                                            const moveProps = bookNotesMoveMode.getItemProps(note.id);
                                            return (
                                                <NoteChip
                                                    key={note.id}
                                                    note={note}
                                                    moveHandlers={moveProps}
                                                    moveModeActive={bookNotesMoveMode.moveModeId === note.id}
                                                    actions={{
                                                        onEdit: () => openNoteModal({
                                                            title: 'Editar nota',
                                                            initialContent: note.content,
                                                            initialName: note.name,
                                                            onSave: (html, name) => updateBookNotes(activeBook.id, activeBook.notes.map(n => n.id === note.id ? { ...n, content: html, name } : n))
                                                        }),
                                                        onMoveUp: () => reorderBookNote(activeBook.id, note.id, -1),
                                                        onMoveDown: () => reorderBookNote(activeBook.id, note.id, 1)
                                                    }}
                                                />
                                            );
                                        })}
                                    </div>
                                )}

                            </div>
                        </main>

                        <div className="fixed bottom-6 left-1/2 transform -translate-x-1/2 z-20 flex flex-col items-center gap-2">
                            {isRecording && recordingTarget?.bookId === activeBook.id && <p className="bg-black/70 text-white text-xs px-2 py-1 rounded whitespace-nowrap animate-pulse">Escuchando...</p>}
                            <div className="flex items-center gap-3">
                                <button onClick={() => openNoteModal({ title: 'Nueva nota del libro', onSave: (html, name) => addBookNote(activeBook.id, html, name) })} className="w-12 h-12 rounded-full bg-white text-indigo-700 border border-indigo-100 flex items-center justify-center shadow-lg hover:-translate-y-0.5 transition" title="Escribir nota del libro">
                                    <Icons.Pencil />
                                </button>
                                <button
                                    onClick={() => toggleDictation({ type: 'book', bookId: activeBook.id })}
                                    disabled={!!micSupportError}
                                    className={`w-14 h-14 rounded-full flex items-center justify-center shadow-[0_14px_36px_rgba(59,130,246,0.45)] transition-all duration-300 text-white ${isRecording && recordingTarget?.bookId === activeBook.id ? 'bg-red-500 pulse-ring scale-110' : 'bg-gradient-to-br from-indigo-500 to-blue-600 hover:scale-105'} ${micSupportError ? 'bg-gray-400 cursor-not-allowed hover:scale-100' : ''}`}
                                >
                                    {isRecording && recordingTarget?.bookId === activeBook.id ? <div className="w-6 h-6 bg-white rounded-sm" /> : <Icons.Mic />}
                                </button>
                            </div>
                        </div>

                        <NoteEditorModal
                            isOpen={noteModal.open}
                            title={noteModal.target?.title || 'Nota'}
                            value={noteDraft}
                            nameValue={noteTitleDraft}
                            onNameChange={setNoteTitleDraft}
                            onChange={setNoteDraft}
                            onSave={handleSaveTypedNote}
                            onClose={closeNoteModal}
                        />

                </div>
                {menuPortal}
                {pickerPortal}
                {speechConfigPortal}
                </>
            );
        }

        if (view === 'chapter' && activeChapter) {
                return (
                    <>
                    <NoteManager bookId={activeBookId} chapter={activeChapter} chapterNumber={activeChapterNumber} onBack={() => goBook(activeBookId)}
                        onAddNote={(text, name) => addNote(activeBookId, activeChapter.id, text, name)}
                        onAddLinkNote={(note) => addLinkNote(activeBookId, activeChapter.id, note)}
                        onUpdateNotes={(newNotes) => updateNotes(activeBookId, activeChapter.id, newNotes)}
                        editNote={editNote}
                        settings={settings} speechEngines={speechEngines} setLoading={setLoading}
                        chooseDestination={chooseDestination}
                        relocateNote={relocateNote}
                        presentAiActions={presentAiActions} />
                    {menuPortal}
                    {pickerPortal}
                    {speechConfigPortal}
                    </>
                );
            }
            return null;
        }

        // --- NOTE MANAGER (Optimized) ---
        function NoteManager({ bookId, chapter, chapterNumber, onBack, onAddNote, onAddLinkNote, onUpdateNotes, editNote, settings, speechEngines, setLoading, chooseDestination, relocateNote, presentAiActions }) {
            const [isRecording, setIsRecording] = useState(false);
            const [selectedIds, setSelectedIds] = useState([]);
            const [selectionMode, setSelectionMode] = useState(false);
            const [noteDraft, setNoteDraft] = useState('<p></p>');
            const [noteNameDraft, setNoteNameDraft] = useState('');
            const [noteModalOpen, setNoteModalOpen] = useState(false);
            const [editingNoteId, setEditingNoteId] = useState(null);
            const recognitionRef = useRef(null);
            const [supportError, setSupportError] = useState(null);
            const [linkLoading, setLinkLoading] = useState(false);

            const reorderNotesByIndex = useCallback((from, to) => {
                onUpdateNotes(moveItem(chapter.notes, from, to));
            }, [chapter.notes, onUpdateNotes]);
            const noteMoveMode = useLongPressMoveMode(500, {
                onEnterMoveMode: (id) => {
                    setSelectionMode(true);
                    setSelectedIds((prev) => prev.includes(id) ? prev : [...prev, id]);
                }
            });

            useEffect(() => {
                if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) setSupportError("Navegador sin soporte de voz");
                return () => { if (recognitionRef.current) recognitionRef.current.stop(); }
            }, []);

            const startRecording = () => {
                if (supportError) return alert(supportError);
                const { engine: engineForRecognition, language } = resolveRecognitionConfig(
                    speechEngines,
                    settings.speechToText
                );

                if (!engineForRecognition?.available && engineForRecognition?.id !== 'ai-assisted') {
                    alert(`${engineForRecognition?.label || 'Motor seleccionado'} no está disponible en este dispositivo. Se usará el motor del navegador.`);
                }

                if (!language) {
                    return alert('Selecciona al menos un idioma en la configuración de voz antes de dictar.');
                }
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                const recognition = new SpeechRecognition();
                recognition.lang = language;
                recognition.continuous = false;
                recognition.onstart = () => setIsRecording(true);
                recognition.onresult = (event) => { if(event.results[0][0].transcript) onAddNote(event.results[0][0].transcript); };
                recognition.onerror = (event) => { console.error(event); setIsRecording(false); if(event.error === 'not-allowed') alert("Microphone permission denied."); };
                recognition.onend = () => setIsRecording(false);
                recognition.start();
                recognitionRef.current = recognition;
            };

            const toggleRecording = () => isRecording ? recognitionRef.current?.stop() : startRecording();
            const toggleSelect = (id) => setSelectedIds(prev => prev.includes(id) ? prev.filter(sid => sid !== id) : [...prev, id]);
            const handleSelectClick = (id) => {
                toggleSelect(id);
                noteMoveMode.activateMoveMode(id);
            };

            const openNoteModal = (note = null) => {
                const initialContent = note?.content || '<p></p>';
                setNoteDraft(initialContent);
                setNoteNameDraft(note?.name || extractNoteName(initialContent));
                setEditingNoteId(note?.id || null);
                setNoteModalOpen(true);
            };
            const closeNoteModal = () => { setNoteDraft('<p></p>'); setNoteNameDraft(''); setEditingNoteId(null); setNoteModalOpen(false); };
            const saveTypedNote = () => {
                if (!noteDraft.trim()) return;
                const name = (noteNameDraft && noteNameDraft.trim()) || extractNoteName(noteDraft);
                if (editingNoteId) {
                    editNote(bookId, chapter.id, editingNoteId, noteDraft, name);
                } else {
                    onAddNote(noteDraft, name);
                }
                closeNoteModal();
            };

            const handleAddLinkFromClipboard = async () => {
                if (!navigator?.clipboard?.readText) {
                    alert('Tu navegador no permite leer el portapapeles automáticamente.');
                    return;
                }
                try {
                    setLinkLoading(true);
                    const clipboardText = await navigator.clipboard.readText();
                    const linkNote = await buildLinkNote(clipboardText);
                    onAddLinkNote?.(linkNote);
                    setSelectionMode(false);
                    setSelectedIds([]);
                } catch (e) {
                    alert(e.message || 'No se pudo crear la nota de enlace.');
                } finally {
                    setLinkLoading(false);
                }
            };

            const reorderNote = (id, direction) => {
                const index = chapter.notes.findIndex(n => n.id === id);
                const target = index + direction;
                if (target < 0 || target >= chapter.notes.length) return;
                onUpdateNotes(moveItem(chapter.notes, index, target));
            };

            const processAI = async (type, scope) => {
                const notes = scope === 'selection' ? chapter.notes.filter(n => selectedIds.includes(n.id)) : chapter.notes;
                if (notes.length === 0) return alert("Sin notas seleccionadas.");
                if (type === 'merge' && notes.length < 2) return alert("Selecciona 2+ notas.");

                const extraPrompt = type === 'style' ? prompt("Describe el estilo:") : type === 'generate' ? prompt("¿Qué necesitas generar?") : null;
                if ((type === 'style' || type === 'generate') && !extraPrompt) return;

                setLoading(true);
                try {
                    const text = notes.map(n => type === 'merge' ? `- ${n.content}` : n.content).join("\n\n");
                    let promptText = settings.prompts.merge;
                    if (type === 'style') promptText = settings.prompts.style.replace('{STYLE}', extraPrompt);
                    if (type === 'generate') promptText = `${settings.prompts.generate}\n\nPetición: ${extraPrompt}`;
                    const result = await callGemini(settings.apiKey, settings.model, promptText, text);

                    const cleanResult = normalizeContent(result);
                    const newNote = { id: generateId(), name: extractNoteName(cleanResult), content: cleanResult, timestamp: Date.now() };
                    if (scope === 'selection') {
                        const remaining = chapter.notes.filter(n => !selectedIds.includes(n.id));
                        onUpdateNotes([...remaining, newNote]);
                        setSelectedIds([]); setSelectionMode(false);
                    } else {
                        onUpdateNotes([newNote]);
                    }
                } catch (e) { alert(e.message); } finally { setLoading(false); }
            };

            const openChapterAiMenu = () => {
                const options = [];
                if (selectionMode && selectedIds.length > 1) {
                    options.push({ label: 'Fusionar selección', onSelect: () => processAI('merge', 'selection') });
                }
                if (selectionMode && selectedIds.length > 0) {
                    options.push({ label: 'Re-estilar selección', onSelect: () => processAI('style', 'selection') });
                    options.push({ label: 'Generar desde selección', onSelect: () => processAI('generate', 'selection') });
                }
                if (!selectionMode && chapter.notes.length > 0) {
                    options.push({ label: 'Re-estilar capítulo', onSelect: () => processAI('style', 'chapter') });
                    options.push({ label: 'Generar nuevo desde capítulo', onSelect: () => processAI('generate', 'chapter') });
                }
                presentAiActions?.(options, 'Acciones IA del capítulo');
            };

            const deleteSelectedNotes = () => {
                if (selectedIds.length === 0) return;
                if (!confirm("¿Eliminar notas seleccionadas?")) return;
                onUpdateNotes(chapter.notes.filter(n => !selectedIds.includes(n.id)));
                setSelectedIds([]);
                setSelectionMode(false);
                noteMoveMode.exitMoveMode();
            };

            const concatenateSelectedNotes = () => {
                if (selectedIds.length < 2) return alert('Selecciona al menos 2 notas para concatenar.');

                const orderedSelectedNotes = chapter.notes.filter(n => selectedIds.includes(n.id));
                if (orderedSelectedNotes.length < 2) return;

                const concatenatedContent = orderedSelectedNotes
                    .map(note => `<div>${note.content}</div>`)
                    .join('');

                const cleanContent = normalizeContent(concatenatedContent);
                const newNote = { id: generateId(), name: extractNoteName(cleanContent), content: cleanContent, timestamp: Date.now() };

                const mergedNotes = [];
                let inserted = false;
                chapter.notes.forEach(note => {
                    if (selectedIds.includes(note.id)) {
                        if (!inserted) {
                            mergedNotes.push(newNote);
                            inserted = true;
                        }
                        return;
                    }
                    mergedNotes.push(note);
                });

                onUpdateNotes(mergedNotes);
                setSelectedIds([]);
                setSelectionMode(false);
                noteMoveMode.exitMoveMode();
            };

            const bulkRelocate = async (mode) => {
                if (selectedIds.length === 0) return alert("Sin notas seleccionadas.");
                const destination = await chooseDestination({ type: 'chapter', bookId, chapterId: chapter.id });
                if (!destination) return;

                const isSameDestination = destination.type === 'chapter' && destination.bookId === bookId && destination.chapterId === chapter.id;
                if (isSameDestination) return alert('Elige un destino diferente.');

                selectedIds.forEach(id => relocateNote({ type: 'chapter', bookId, chapterId: chapter.id }, destination, id, mode));
                setSelectedIds([]);
                setSelectionMode(false);
                noteMoveMode.exitMoveMode();
            };

            const renameSelectedNote = () => {
                if (selectedIds.length !== 1) return alert('Selecciona una única nota para renombrar.');

                const noteToRename = chapter.notes.find((note) => selectedIds.includes(note.id));
                if (!noteToRename) return alert('No se encontró la nota seleccionada.');

                const currentTitle = noteToRename.name || extractNoteName(noteToRename.content);
                const newTitle = prompt('Nuevo título para la nota:', currentTitle);
                if (!newTitle || !newTitle.trim()) return;

                const normalizedTitle = newTitle.trim();
                const updatedNotes = chapter.notes.map((note) =>
                    note.id === noteToRename.id
                        ? {
                            ...note,
                            name: normalizedTitle,
                            meta: note.type === 'link' ? { ...note.meta, title: normalizedTitle } : note.meta,
                        }
                        : note
                );

                onUpdateNotes(updatedNotes);
                setSelectedIds([]);
                setSelectionMode(false);
                noteMoveMode.exitMoveMode();
            };

            const hasSingleNoteSelected = selectedIds.length === 1;

            return (
                <div className="min-h-screen flex flex-col app-surface">
                    <header className="safe-top sticky top-0 z-20 bg-[var(--color-bg)]/95 backdrop-blur border-b border-slate-100 px-4 py-3 shadow-sm">
                        <div className="flex items-center justify-between gap-3">
                            <div className="flex items-center gap-3 min-w-0">
                                <button onClick={onBack} className="w-10 h-10 rounded-full border border-slate-200 bg-white text-slate-600 hover:text-indigo-700 shadow-sm flex items-center justify-center transition" aria-label="Volver">
                                    <Icons.ChevronLeft />
                                </button>
                                <div className="overflow-hidden">
                                    <p className="text-[11px] uppercase tracking-[0.2em] text-slate-400 font-semibold">Capítulo {chapterNumber || ''}</p>
                                    <h1 className="text-lg font-bold text-slate-900 truncate leading-tight">{chapter.title}</h1>
                                    <p className="text-xs text-slate-500 truncate">{selectedIds.length} seleccionadas</p>
                                </div>
                            </div>
                            <AiCornerButton onClick={openChapterAiMenu} title="Acciones IA del capítulo" />
                        </div>
                    </header>

                    <main className="flex-1 p-4 pb-32 w-full max-w-2xl mx-auto">
                        <div className="space-y-4">
                            {selectionMode && selectedIds.length > 0 && (
                                <div className="flex gap-2 overflow-x-auto pb-2 scrollbar-hide">
                                    <button onClick={deleteSelectedNotes} className="whitespace-nowrap text-xs flex items-center gap-1 bg-red-50 text-red-700 px-3 py-2 rounded-lg border border-red-200 font-semibold active:scale-95 transition"><Icons.Trash className="w-3 h-3" /> Eliminar</button>
                                    <button onClick={() => bulkRelocate('move')} className="whitespace-nowrap text-xs flex items-center gap-1 bg-indigo-50 text-indigo-700 px-3 py-2 rounded-lg border border-indigo-200 font-semibold active:scale-95 transition"><Icons.Folder className="w-3 h-3" /> Mover</button>
                                    <button onClick={() => bulkRelocate('copy')} className="whitespace-nowrap text-xs flex items-center gap-1 bg-purple-50 text-purple-700 px-3 py-2 rounded-lg border border-purple-200 font-semibold active:scale-95 transition"><Icons.Plus className="w-3 h-3" /> Duplicar</button>
                                    <button
                                        onClick={renameSelectedNote}
                                        disabled={!hasSingleNoteSelected}
                                        className={`whitespace-nowrap text-xs flex items-center gap-1 px-3 py-2 rounded-lg border font-semibold active:scale-95 transition ${hasSingleNoteSelected ? 'bg-blue-50 text-blue-700 border-blue-200' : 'bg-gray-50 text-gray-400 border-gray-200 cursor-not-allowed'}`}
                                    >
                                        <Icons.Pencil /> Renombrar nota
                                    </button>
                                    {selectedIds.length > 1 && (
                                        <button
                                            onClick={concatenateSelectedNotes}
                                            className="whitespace-nowrap text-xs flex items-center gap-1 bg-amber-50 text-amber-800 px-3 py-2 rounded-lg border border-amber-200 font-semibold active:scale-95 transition"
                                        >
                                            <Icons.Merge className="w-3 h-3" /> Concatenar
                                        </button>
                                    )}
                                </div>
                            )}

                            {chapter.notes.length === 0 && <div className="flex flex-col items-center justify-center h-64 text-gray-400"><Icons.Mic className="w-12 h-12 mb-2 opacity-20" /><p>Graba una nota</p></div>}

                            <div className="space-y-3">
                                {chapter.notes.map(note => {
                                    const moveProps = noteMoveMode.getItemProps(note.id);
                                    const baseActions = {
                                        onMoveUp: () => reorderNote(note.id, -1),
                                        onMoveDown: () => reorderNote(note.id, 1),
                                    };
                                    return (
                                        <NoteChip
                                            key={note.id}
                                            note={note}
                                            moveHandlers={moveProps}
                                            moveModeActive={noteMoveMode.moveModeId === note.id}
                                            selectionMode={selectionMode}
                                            isSelected={selectedIds.includes(note.id)}
                                            onCardClick={selectionMode ? () => handleSelectClick(note.id) : undefined}
                                            collapsed
                                            actions={selectionMode ? baseActions : {
                                                ...baseActions,
                                                onEdit: () => openNoteModal(note)
                                            }}
                                        />
                                    );
                                })}
                            </div>
                        </div>
                    </main>

                    <div className="fixed bottom-6 left-1/2 transform -translate-x-1/2 z-20 flex flex-col items-center gap-2">
                        {isRecording && <p className="bg-black/70 text-white text-xs px-2 py-1 rounded whitespace-nowrap animate-pulse">Escuchando...</p>}
                        <div className="flex items-center gap-3">
                            <button
                                onClick={handleAddLinkFromClipboard}
                                disabled={linkLoading}
                                className={`w-12 h-12 rounded-full bg-white border border-emerald-200 text-emerald-700 flex items-center justify-center shadow-lg hover:-translate-y-0.5 transition ${linkLoading ? 'opacity-80 cursor-wait' : ''}`}
                                title="Añadir enlace desde portapapeles"
                            >
                                {linkLoading ? <span className="w-5 h-5 border-2 border-emerald-300 border-t-emerald-700 rounded-full animate-spin"></span> : <Icons.Link />}
                            </button>
                            <button onClick={openNoteModal} className="w-12 h-12 rounded-full bg-white border border-slate-200 text-slate-700 flex items-center justify-center shadow-lg hover:-translate-y-0.5 transition" title="Escribir nota">
                                <Icons.Pencil />
                            </button>
                            <button onClick={toggleRecording} disabled={!!supportError} className={`w-14 h-14 rounded-full flex items-center justify-center shadow-[0_14px_36px_rgba(59,130,246,0.45)] transition-all duration-300 text-white ${isRecording ? 'bg-red-500 pulse-ring scale-110' : 'bg-gradient-to-br from-indigo-500 to-blue-600 hover:scale-105'} ${supportError ? 'bg-gray-400 cursor-not-allowed hover:scale-100' : ''}`}>
                                {isRecording ? <div className="w-6 h-6 bg-white rounded-sm shadow-sm" /> : <Icons.Mic className="text-white" />}
                            </button>
                        </div>
                    </div>

                    <NoteEditorModal
                        isOpen={noteModalOpen}
                        title={editingNoteId ? 'Editar nota' : 'Añadir nota escrita'}
                        value={noteDraft}
                        nameValue={noteNameDraft}
                        onNameChange={setNoteNameDraft}
                        onChange={setNoteDraft}
                        onSave={saveTypedNote}
                        onClose={closeNoteModal}
                    />
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
