<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>VoiceNotes AI Manager</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel para JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>

    <style>
        :root {
            --color-bg: #e8eaf6;
            --color-surface: #ffffff;
            --color-primary: #3f51b5;
            --color-secondary: #7986cb;
            --color-accent: #ff9800;
            --color-soft: #f5f7fb;
            --radius-lg: 0.75rem;
            --radius-xl: 1rem;
            --shadow-md: 0 6px 16px rgba(0, 0, 0, 0.08);
            --shadow-lg: 0 12px 30px rgba(0, 0, 0, 0.12);
            --gradient-aurora: linear-gradient(120deg, rgba(63, 81, 181, 0.1), rgba(255, 152, 0, 0.08));
        }

        /* Estilos base y utilidades */
        body {
            font-family: 'Roboto', 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: radial-gradient(circle at 15% 20%, rgba(63, 81, 181, 0.08), transparent 26%),
                        radial-gradient(circle at 85% 10%, rgba(255, 152, 0, 0.1), transparent 28%),
                        radial-gradient(circle at 60% 80%, rgba(121, 134, 203, 0.12), transparent 24%),
                        var(--color-bg);
            margin: 0;
            color: #212121;
            -webkit-tap-highlight-color: transparent;
        }

        body::after {
            content: "";
            position: fixed;
            inset: 0;
            pointer-events: none;
            background: radial-gradient(circle at 30% 50%, rgba(63, 81, 181, 0.05), transparent 30%),
                        radial-gradient(circle at 70% 40%, rgba(255, 152, 0, 0.06), transparent 26%);
            filter: blur(32px);
            z-index: -1;
        }

        .safe-top {
            padding-top: env(safe-area-inset-top, 0);
        }
        .safe-bottom {
            padding-bottom: env(safe-area-inset-bottom, 0);
        }

        .card {
            background: var(--color-surface);
            border-radius: var(--radius-xl);
            border: 1px solid rgba(63, 81, 181, 0.08);
            box-shadow: var(--shadow-md);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .card-tap {
            transition: transform 0.12s ease, box-shadow 0.12s ease, border-color 0.12s ease;
        }
        .card-tap:hover {
            box-shadow: var(--shadow-lg);
            transform: translateY(-2px);
        }
        .card-tap:active {
            transform: scale(0.98);
            box-shadow: 0 4px 12px rgba(15, 23, 42, 0.08);
        }

        .icon-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 9999px;
            padding: 0.35rem;
            font-size: 0.85rem;
            background: linear-gradient(135deg, rgba(63, 81, 181, 0.08), rgba(255, 152, 0, 0.08));
            border: 1px solid rgba(63, 81, 181, 0.08);
        }
        .icon-btn-sm {
            padding: 0.25rem;
        }

        /* Animación de carga */
        .loader {
            border: 4px solid #e0e7ff;
            border-top: 4px solid var(--color-primary);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Animación de grabación */
        .pulse-ring {
            box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
            animation: pulse-red 1.5s infinite cubic-bezier(0.66, 0, 0, 1);
        }
        @keyframes pulse-red {
            to { box-shadow: 0 0 0 15px rgba(239, 68, 68, 0); }
        }

        /* Scrollbar bonita */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        
        .glass-panel {
            background: linear-gradient(120deg, rgba(255,255,255,0.92), rgba(255,255,255,0.88)) padding-box,
                        linear-gradient(120deg, rgba(63,81,181,0.18), rgba(255,152,0,0.12)) border-box;
            border: 1px solid transparent;
            box-shadow: 0 12px 28px rgba(15, 23, 42, 0.08);
            backdrop-filter: blur(18px);
        }

        /* Estilos del editor y visualización de notas */
        .editor-content h1 {
            font-size: 22px;
            font-weight: 800;
            color: #1f2937;
            margin: 0 0 0.5rem;
        }
        .editor-content h2 {
            font-size: 18px;
            font-weight: 800;
            color: #111827;
            text-decoration: underline;
            margin: 0 0 0.4rem;
        }
        .editor-content p,
        .editor-content li {
            font-size: 16px;
            line-height: 1.65;
        }
        .editor-content ul {
            list-style-type: disc;
            padding-left: 1.25rem;
            margin: 0.25rem 0 0.5rem;
        }
        .editor-content ol {
            list-style-type: decimal;
            padding-left: 1.25rem;
            margin: 0.25rem 0 0.5rem;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- ICONOS SVG ---
        const Icons = {
            Book: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></svg>,
            Folder: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg>,
            Mic: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>,
            Settings: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.72v-.51a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>,
            ChevronLeft: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="15 18 9 12 15 6"/></svg>,
            Plus: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>,
            Wand: () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M15 4V2"/><path d="M15 16v-2"/><path d="M8 9h2"/><path d="M20 9h2"/><path d="M17.8 11.8 19 13"/><path d="M15 9h0"/><path d="M17.8 6.2 19 5"/><path d="M3 21l9-9"/><path d="M12.2 6.2 11 5"/></svg>,
            Merge: () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m8 6 4-4 4 4"/><path d="M12 2v10.3"/><path d="M12 12.3v9.3"/><path d="m8 18 4 4 4-4"/></svg>,
            Trash: () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>,
            Check: () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="20 6 9 17 4 12"/></svg>,
            Alert: () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>,
            Menu: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/></svg>,
            Cloud: () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M17.5 19H9a5 5 0 1 1 .9-9.9A7 7 0 0 1 21 12a4 4 0 0 1-3.5 7Z"/></svg>
        };

        // --- CONFIGURACIÓN INICIAL ---
        const DEFAULT_API_KEY = "";
        const DEFAULT_MODEL = "gemini-2.0-flash-exp";
        const DEFAULT_PROMPTS = {
            merge: "Combina las siguientes notas en un único texto coherente, bien estructurado y resumido. Usa Markdown para dar formato si es necesario.",
            style: "Reescribe el siguiente contenido aplicando estrictamente el siguiente estilo o tono: {STYLE}. Mantén la información original pero cambia la forma de expresarla.",
            generate: "Crea una nota nueva usando el siguiente contexto. Respeta el idioma y el nivel de detalle del material."
        };
        const TEMP_CHAPTER_TITLE = 'temporary';
        const TEMP_BOOK_TITLE = 'temp notes';
        const FIRESTORE_COLLECTION = 'voiceNotes_appData';
        const LOCAL_USAGE_KEY = 'voiceNotes_lastUse';
        const FIRESTORE_SYNC_KEY = 'voiceNotes_lastFirestoreSync';
        const SESSION_KEY = 'voiceNotes_sessionId';
        const LOCAL_RECENCY_WINDOW_MS = 5 * 60 * 1000; // 5 minutos
        const AUTO_FIRESTORE_SAVE_DELAY = 2 * 60 * 1000; // 2 minutos

        const firebaseConfig = {
            apiKey: "AIzaSyA-wfyW4A1x0OhlBnnPhN2xwgs8N0e_3ek",
            authDomain: "smartbookwriter-f6dd5.firebaseapp.com",
            projectId: "smartbookwriter-f6dd5",
            storageBucket: "smartbookwriter-f6dd5.firebasestorage.app",
            messagingSenderId: "924785765286",
            appId: "1:924785765286:web:42b733d5914b095bbf7d67"
        };

        const normalizeBooksData = (bookList = []) => bookList.map(b => ({
            ...b,
            notes: b.notes || [],
            chapters: (b.chapters || []).map(c => ({ ...c, notes: c.notes || [] }))
        }));

        const generateId = () => Date.now().toString(36) + Math.random().toString(36).substr(2);
        const moveItem = (array, from, to) => {
            const arr = [...array];
            const [item] = arr.splice(from, 1);
            arr.splice(to, 0, item);
            return arr;
        };
        const matchTitle = (value, target) => (value || '').trim().toLowerCase() === target;
        const isPreliminaryChapterTitle = (title) => ['preliminary', 'preliminar', TEMP_CHAPTER_TITLE].some(t => matchTitle(title, t));
        const cloneNote = (note) => ({ ...note, id: generateId(), timestamp: Date.now() });
        const escapeHtml = (text) => text.replace(/[&<>"]/g, (c) => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;' }[c]));
        const normalizeContent = (content) => {
            if (!content || typeof content !== 'string') return '<p></p>';
            const trimmed = content.trim();
            const looksLikeHtml = /<[^>]+>/.test(trimmed);
            if (looksLikeHtml) return trimmed;
            return `<p>${escapeHtml(trimmed).replace(/\n/g, '<br>')}</p>`;
        };
        const buildDestinations = (books, source) => {
            const options = [];

            const tempBook = books.find(b => matchTitle(b.title, TEMP_BOOK_TITLE));
            const tempChapter = tempBook?.chapters.find(c => isPreliminaryChapterTitle(c.title));
            const isFromTempPreliminary = source?.type === 'chapter' && tempBook && source.bookId === tempBook.id && source.chapterId === tempChapter?.id;

            const addChapterOption = (book, chapter) => {
                if (!chapter) return;
                if (options.some(opt => opt.chapterId === chapter.id)) return;
                options.push({ label: `${book.title} → ${chapter.title}`, type: 'chapter', bookId: book.id, chapterId: chapter.id });
            };

            const addTempChapterFromOtherBooks = (currentBookId) => {
                books
                    .filter(book => book.id !== currentBookId)
                    .forEach(book => {
                        const preliminary = book.chapters.find(ch => isPreliminaryChapterTitle(ch.title));
                        addChapterOption(book, preliminary);
                    });
            };

            if (isFromTempPreliminary) {
                tempBook?.chapters.forEach(chapter => addChapterOption(tempBook, chapter));
                addTempChapterFromOtherBooks(tempBook?.id);
            } else if (source?.bookId) {
                const currentBook = books.find(b => b.id === source.bookId);
                currentBook?.chapters.forEach(chapter => addChapterOption(currentBook, chapter));
                addTempChapterFromOtherBooks(currentBook?.id);
            } else {
                books.forEach(book => book.chapters.forEach(chapter => addChapterOption(book, chapter)));
            }

            if (tempBook && tempChapter) {
                addChapterOption(tempBook, tempChapter);
            }

            return options;
        };

        const ensureTempChapterInBook = (currentBooks, bookId) => {
            let updated = [...currentBooks];
            const bookIndex = updated.findIndex(b => b.id === bookId);
            if (bookIndex < 0) return { books: updated, chapterId: null, changed: false };

            const book = updated[bookIndex];
            let chapter = book.chapters.find(c => isPreliminaryChapterTitle(c.title));
            let changed = false;

            if (!chapter) {
                chapter = { id: generateId(), title: TEMP_CHAPTER_TITLE, notes: [] };
                updated[bookIndex] = { ...book, chapters: [...book.chapters, chapter] };
                changed = true;
            }

            return { books: updated, chapterId: chapter.id, changed };
        };

        const ensureTempBookAndChapter = (currentBooks) => {
            let updated = [...currentBooks];
            let tempBook = updated.find(b => matchTitle(b.title, TEMP_BOOK_TITLE));
            let changed = false;

            if (!tempBook) {
                tempBook = { id: generateId(), title: TEMP_BOOK_TITLE, chapters: [] };
                updated = [...updated, tempBook];
                changed = true;
            }

            const { books: withChapter, chapterId, changed: chapterChanged } = ensureTempChapterInBook(updated, tempBook.id);
            const refreshedBook = withChapter.find(b => b.id === tempBook.id);

            return {
                books: withChapter,
                tempBookId: refreshedBook?.id || tempBook.id,
                tempChapterId: chapterId,
                changed: changed || chapterChanged
            };
        };

        const ensurePreliminaryChaptersEverywhere = (currentBooks) => {
            let updated = [...currentBooks];
            let changed = false;

            updated.forEach(book => {
                const ensured = ensureTempChapterInBook(updated, book.id);
                if (ensured.changed) {
                    updated = ensured.books;
                    changed = true;
                }
            });

            return { books: updated, changed };
        };

        const updateChapterNotesInBooks = (bookList, bookId, chapterId, updater) => bookList.map(book => {
            if (book.id !== bookId) return book;
            return {
                ...book,
                chapters: book.chapters.map(chapter => chapter.id === chapterId ? { ...chapter, notes: updater(chapter.notes || []) } : chapter)
            };
        });

        const useLongPressMoveMode = (duration = 500, { onEnterMoveMode } = {}) => {
            const [moveModeId, setMoveModeId] = useState(null);
            const pressTimer = useRef(null);
            const longPressTriggered = useRef(false);

            const clearPressTimer = () => {
                if (pressTimer.current) {
                    clearTimeout(pressTimer.current);
                    pressTimer.current = null;
                }
            };

            const startPress = (id) => {
                clearPressTimer();
                longPressTriggered.current = false;
                pressTimer.current = setTimeout(() => {
                    longPressTriggered.current = true;
                    setMoveModeId(prev => {
                        const nextId = prev === id ? null : id;
                        if (nextId) onEnterMoveMode?.(nextId);
                        return nextId;
                    });
                }, duration);
            };

            const cancelPress = () => {
                clearPressTimer();
            };

            const getItemProps = (id) => ({
                onPointerDown: () => startPress(id),
                onPointerUp: cancelPress,
                onPointerLeave: cancelPress,
                onPointerCancel: cancelPress,
                onClick: (e) => {
                    if (longPressTriggered.current) {
                        e.preventDefault();
                        e.stopPropagation();
                        longPressTriggered.current = false;
                    }
                },
            });

            useEffect(() => () => clearPressTimer(), []);

            const activateMoveMode = (id) => {
                setMoveModeId(prev => {
                    const nextId = id ?? null;
                    if (nextId && nextId !== prev) onEnterMoveMode?.(nextId);
                    return nextId;
                });
            };

            const exitMoveMode = () => {
                setMoveModeId(null);
                longPressTriggered.current = false;
                clearPressTimer();
            };

            return { moveModeId, getItemProps, exitMoveMode, activateMoveMode };
        };

        const NoteEditorModal = ({ isOpen, title, value, onChange, onSave, onClose }) => {
            const editorRef = useRef(null);
            const [fontFamily, setFontFamily] = useState('Calibri');
            const [fontSize, setFontSize] = useState(16);
            const [highlightColor, setHighlightColor] = useState('#fef3c7');
            const [textColor, setTextColor] = useState('#7c3aed');
            const [activeFormats, setActiveFormats] = useState({
                bold: false,
                italic: false,
                underline: false,
                unorderedList: false,
                orderedList: false,
                alignLeft: true,
                alignCenter: false,
                alignRight: false,
                alignJustify: false,
                highlight: false,
                textColor: false,
            });

            useEffect(() => {
                if (isOpen && editorRef.current) {
                    if (value && editorRef.current.innerHTML !== value) {
                        editorRef.current.innerHTML = value;
                    } else if (!value) {
                        editorRef.current.innerHTML = '<p></p>';
                    }
                    editorRef.current.focus();
                    syncCommandStates();
                }
            }, [isOpen, value]);

            useEffect(() => {
                if (!isOpen) return;
                const handleSelectionChange = () => syncCommandStates();
                document.addEventListener('selectionchange', handleSelectionChange);
                return () => document.removeEventListener('selectionchange', handleSelectionChange);
            }, [isOpen]);

            const normalizeHex = (value) => {
                if (!value) return '';
                const temp = document.createElement('div');
                temp.style.color = value;
                document.body.appendChild(temp);
                const rgb = getComputedStyle(temp).color;
                document.body.removeChild(temp);

                const match = rgb.match(/(\d+)/g);
                if (!match) return value.toLowerCase();
                const toHex = (n) => Number(n).toString(16).padStart(2, '0');
                const [r, g, b] = match;
                return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
            };

            const colorsEqual = (a, b) => normalizeHex(a) === normalizeHex(b);

            const syncCommandStates = () => {
                if (!editorRef.current) return;
                const highlightValue = document.queryCommandValue('hiliteColor');
                const textColorValue = document.queryCommandValue('foreColor');

                setActiveFormats({
                    bold: document.queryCommandState('bold'),
                    italic: document.queryCommandState('italic'),
                    underline: document.queryCommandState('underline'),
                    unorderedList: document.queryCommandState('insertUnorderedList'),
                    orderedList: document.queryCommandState('insertOrderedList'),
                    alignLeft: document.queryCommandState('justifyLeft'),
                    alignCenter: document.queryCommandState('justifyCenter'),
                    alignRight: document.queryCommandState('justifyRight'),
                    alignJustify: document.queryCommandState('justifyFull'),
                    highlight: colorsEqual(highlightValue, highlightColor),
                    textColor: colorsEqual(textColorValue, textColor),
                });
            };

            const format = (command, arg = null) => {
                if (!editorRef.current) return;
                document.execCommand(command, false, arg);
                editorRef.current.focus();
                onChange(editorRef.current.innerHTML);
                syncCommandStates();
            };

            const applyFontFamily = (family) => {
                setFontFamily(family);
                format('fontName', family);
            };

            const applyFontSize = (size) => {
                if (!editorRef.current) return;
                setFontSize(size);
                const sizeMap = { 10: 2, 11: 2, 12: 3, 14: 4, 16: 5, 18: 6, 20: 7 };
                const commandSize = sizeMap[size] || 3;
                document.execCommand('fontSize', false, commandSize);

                const fonts = editorRef.current.getElementsByTagName('font');
                Array.from(fonts).forEach((font) => {
                    if (font.size == commandSize) {
                        font.removeAttribute('size');
                        font.style.fontSize = `${size}px`;
                    }
                });

                editorRef.current.focus();
                onChange(editorRef.current.innerHTML);
            };

            const applyHighlight = (color) => {
                const current = document.queryCommandValue('hiliteColor');
                const shouldClear = colorsEqual(current, color);
                setHighlightColor(color);
                format('hiliteColor', shouldClear ? 'transparent' : color);
            };

            const applyTextColor = (color) => {
                const current = document.queryCommandValue('foreColor');
                const shouldClear = colorsEqual(current, color);
                setTextColor(color);
                format('foreColor', shouldClear ? '#000000' : color);
            };

            const handleInput = () => {
                if (editorRef.current) onChange(editorRef.current.innerHTML);
                syncCommandStates();
            };

            const toolbarButtonClass = "p-3 rounded-md border bg-white shadow-sm text-sm text-slate-700 hover:bg-slate-100 flex items-center gap-1 min-w-[2.75rem] min-h-[2.75rem]";
            const activeToolbarClass = "bg-violet-50 border-violet-500 text-violet-700 shadow-inner";
            const getButtonClasses = (isActive = false) => `${toolbarButtonClass} ${isActive ? activeToolbarClass : ''}`;

            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 z-50 bg-slate-900/60 backdrop-blur flex flex-col">
                    <div className="flex items-center justify-between p-4 bg-white shadow-md border-b">
                        <div>
                            <p className="text-xs uppercase tracking-wide text-slate-400">Editor de nota</p>
                            <p className="text-sm font-semibold text-slate-900">{title}</p>
                        </div>
                        <div className="flex gap-2">
                            <button onClick={onClose} className="px-4 py-2 rounded-lg border text-slate-700 hover:bg-slate-50">Cancelar</button>
                            <button onClick={onSave} className="px-4 py-2 rounded-lg bg-indigo-600 text-white font-semibold shadow hover:bg-indigo-700">Guardar</button>
                        </div>
                    </div>
                    <div className="px-4 py-3 bg-slate-50 border-b space-y-2">
                        <div className="flex flex-nowrap items-center gap-2 overflow-x-auto pb-1">
                            <select
                                value={fontFamily}
                                onChange={(e) => applyFontFamily(e.target.value)}
                                className="h-9 rounded-md border bg-white px-2 text-sm shadow-sm"
                            >
                                {['Calibri', 'Arial', 'Georgia', 'Times New Roman', 'Segoe UI', 'Roboto'].map((font) => (
                                    <option key={font} value={font}>{font}</option>
                                ))}
                            </select>
                            <select
                                value={fontSize}
                                onChange={(e) => applyFontSize(Number(e.target.value))}
                                className="h-9 rounded-md border bg-white px-2 text-sm shadow-sm"
                            >
                                {[10, 11, 12, 14, 16, 18, 20].map((size) => (
                                    <option key={size} value={size}>{size}</option>
                                ))}
                            </select>
                            <button
                                onClick={() => applyHighlight('#fff59d')}
                                className={getButtonClasses(activeFormats.highlight)}
                                title="Resaltar"
                            >
                                <span className="inline-flex h-4 w-4 rounded-sm border" style={{ backgroundColor: highlightColor }}></span>
                                <span>Resaltar</span>
                            </button>
                            <button
                                onClick={() => applyTextColor('#7c3aed')}
                                className={getButtonClasses(activeFormats.textColor)}
                                title="Color de texto"
                            >
                                <span className="inline-flex h-4 w-4 rounded-sm border" style={{ backgroundColor: textColor }}></span>
                                <span>Color</span>
                            </button>
                        </div>

                        <div className="flex flex-nowrap items-center gap-2 overflow-x-auto pb-1">
                            <button onClick={() => format('bold')} className={getButtonClasses(activeFormats.bold) + ' font-semibold'}><strong>B</strong></button>
                            <button onClick={() => format('italic')} className={getButtonClasses(activeFormats.italic) + ' italic'}>I</button>
                            <button onClick={() => format('underline')} className={getButtonClasses(activeFormats.underline) + ' underline'}>U</button>
                        </div>

                        <div className="flex flex-nowrap items-center gap-2 overflow-x-auto pb-1">
                            <button onClick={() => format('justifyLeft')} className={getButtonClasses(activeFormats.alignLeft)}>
                                <svg xmlns="http://www.w3.org/2000/svg" className="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                    <path d="M4 6h16" /><path d="M4 10h10" /><path d="M4 14h16" /><path d="M4 18h10" />
                                </svg>
                                <span className="sr-only">Alinear a la izquierda</span>
                            </button>
                            <button onClick={() => format('justifyCenter')} className={getButtonClasses(activeFormats.alignCenter)}>
                                <svg xmlns="http://www.w3.org/2000/svg" className="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                    <path d="M6 6h12" /><path d="M4 10h16" /><path d="M6 14h12" /><path d="M4 18h16" />
                                </svg>
                                <span className="sr-only">Centrar</span>
                            </button>
                            <button onClick={() => format('justifyRight')} className={getButtonClasses(activeFormats.alignRight)}>
                                <svg xmlns="http://www.w3.org/2000/svg" className="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                    <path d="M4 6h16" /><path d="M10 10h10" /><path d="M4 14h16" /><path d="M10 18h10" />
                                </svg>
                                <span className="sr-only">Alinear a la derecha</span>
                            </button>
                            <button onClick={() => format('justifyFull')} className={getButtonClasses(activeFormats.alignJustify)}>
                                <svg xmlns="http://www.w3.org/2000/svg" className="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                    <path d="M4 6h16" /><path d="M4 10h16" /><path d="M4 14h16" /><path d="M4 18h16" />
                                </svg>
                                <span className="sr-only">Justificar</span>
                            </button>
                            <button onClick={() => format('insertUnorderedList')} className={getButtonClasses(activeFormats.unorderedList)}>
                                <svg xmlns="http://www.w3.org/2000/svg" className="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                    <circle cx="5" cy="6" r="1" /><circle cx="5" cy="12" r="1" /><circle cx="5" cy="18" r="1" />
                                    <path d="M9 6h10" /><path d="M9 12h10" /><path d="M9 18h10" />
                                </svg>
                                <span className="sr-only">Lista con viñetas</span>
                            </button>
                            <button onClick={() => format('insertOrderedList')} className={getButtonClasses(activeFormats.orderedList)}>
                                <svg xmlns="http://www.w3.org/2000/svg" className="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                    <path d="M5 5h2" /><path d="M6 4v6" /><path d="M5 11h2" /><path d="M4 14h2l-2 3h3" /><path d="M4 20h3" />
                                    <path d="M9 6h10" /><path d="M9 12h10" /><path d="M9 18h10" />
                                </svg>
                                <span className="sr-only">Lista numerada</span>
                            </button>
                        </div>
                    </div>
                    <div className="flex-1 overflow-y-auto bg-white">
                        <div
                            ref={editorRef}
                            contentEditable
                            onInput={handleInput}
                            className="max-w-4xl mx-auto p-6 min-h-[60vh] prose prose-slate focus:outline-none editor-content"
                            placeholder="Escribe o pega tu nota con formato..."
                        ></div>
                    </div>
                </div>
            );
        };

        const MoveControls = ({ onMoveUp, onMoveDown, accentClass = 'text-slate-700' }) => (
            <div className="flex flex-col items-center justify-center gap-1 bg-white/90 rounded-full border border-slate-200 shadow-sm p-1">
                <button
                    onPointerDown={(e) => e.stopPropagation()}
                    onClick={(e) => { e.stopPropagation(); onMoveUp?.(); }}
                    className={`w-8 h-8 rounded-full flex items-center justify-center hover:bg-slate-100 active:scale-95 ${accentClass}`}
                    aria-label="Mover hacia arriba"
                >
                    ▲
                </button>
                <button
                    onPointerDown={(e) => e.stopPropagation()}
                    onClick={(e) => { e.stopPropagation(); onMoveDown?.(); }}
                    className={`w-8 h-8 rounded-full flex items-center justify-center hover:bg-slate-100 active:scale-95 ${accentClass}`}
                    aria-label="Mover hacia abajo"
                >
                    ▼
                </button>
            </div>
        );

        const getNotePreview = (htmlContent, limit = 140) => {
            const temp = document.createElement('div');
            temp.innerHTML = htmlContent || '';
            const text = (temp.textContent || temp.innerText || '').trim();
            return text.length > limit ? `${text.slice(0, limit).trim()}...` : text;
        };

        const NoteChip = ({ note, actions = {}, selectionMode = false, isSelected = false, onCardClick, moveHandlers = {}, moveModeActive = false, collapsed = false, previewLength = 140 }) => {
            const { onEdit, onMoveUp, onMoveDown } = actions;
            const showMoveControls = moveModeActive && (onMoveUp || onMoveDown);
            const previewText = collapsed ? getNotePreview(note.content, previewLength) : null;

            return (
                <div
                    {...moveHandlers}
                    className={`p-4 rounded-xl shadow-md border transition relative cursor-pointer select-none backdrop-blur-sm ${isSelected ? 'bg-gradient-to-r from-indigo-50 via-rose-50 to-amber-50 border-indigo-300 ring-2 ring-rose-200' : 'bg-white/90 border-white/60 hover:shadow-lg'}`}
                    onClick={(e) => {
                        moveHandlers.onClick?.(e);
                        if (e.defaultPrevented) return;
                        if (selectionMode) {
                            onCardClick?.(e);
                            return;
                        }
                        if (onEdit && !moveModeActive) {
                            onEdit();
                            return;
                        }
                        onCardClick?.(e);
                    }}
                >
                    {collapsed ? (
                        <p className="text-sm text-gray-800 leading-relaxed whitespace-pre-wrap">{previewText}</p>
                    ) : (
                        <div className="text-sm text-gray-800 prose prose-slate max-w-none leading-relaxed editor-content" dangerouslySetInnerHTML={{ __html: note.content }} />
                    )}
                    <div className="mt-2 flex justify-between items-center text-[10px] text-gray-400">
                        <span>{new Date(note.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>
                        {showMoveControls && (
                            <div className="relative">
                                <MoveControls onMoveUp={onMoveUp} onMoveDown={onMoveDown} />
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const OptionPicker = ({ state, onSelect, onClose }) => {
            if (!state.open) return null;
            return (
                <div className="fixed inset-0 z-40 flex items-center justify-center bg-black/40 p-4" onClick={onClose}>
                    <div className="w-full max-w-md bg-white rounded-2xl shadow-2xl border p-4" onClick={(e) => e.stopPropagation()}>
                        <div className="flex items-center justify-between mb-3">
                            <p className="text-sm font-semibold text-slate-800">{state.title || 'Selecciona una opción'}</p>
                            <button onClick={onClose} className="text-slate-400 hover:text-slate-600">✕</button>
                        </div>
                        <div className="space-y-2 max-h-64 overflow-y-auto">
                            {state.options.map((opt, idx) => (
                                <button
                                    key={`${opt.label}-${idx}`}
                                    onClick={() => onSelect(opt)}
                                    className="w-full text-left px-3 py-2 rounded-xl border border-slate-200 hover:border-blue-400 hover:bg-blue-50 transition"
                                >
                                    {opt.label}
                                </button>
                            ))}
                        </div>
                    </div>
                </div>
            );
        };

        const HamburgerMenu = ({
            open,
            onClose,
            onSettings,
            onLogin,
            onLogout,
            onSave,
            onLoad,
            authUser,
            status,
            message,
            firebaseReady,
            firebaseError
        }) => {
            if (!open) return null;
            const statusColor = status === 'success' ? 'text-green-700 bg-green-50 border-green-200' : status === 'error' ? 'text-red-700 bg-red-50 border-red-200' : 'text-blue-700 bg-blue-50 border-blue-200';
            return (
                <div className="fixed inset-0 z-50 bg-black/40" onClick={onClose}>
                    <div className="absolute top-3 right-3 w-72 bg-white rounded-2xl shadow-2xl border border-slate-100 p-4 space-y-3" onClick={(e) => e.stopPropagation()}>
                        <div className="flex items-start justify-between gap-2">
                            <div>
                                <p className="text-sm font-semibold text-slate-800">Menú</p>
                                <p className="text-xs text-slate-500">Firebase {firebaseReady ? 'listo' : 'no inicializado'}</p>
                                {firebaseError && <p className="text-[11px] text-red-600">{firebaseError}</p>}
                                {authUser && <p className="text-[11px] text-slate-500">{authUser.email}</p>}
                            </div>
                            <button onClick={onClose} className="icon-btn text-slate-400 hover:text-slate-700">✕</button>
                        </div>

                        <div className="space-y-2">
                            <button onClick={onSettings} className="w-full flex items-center justify-between px-3 py-2 rounded-xl border bg-slate-50 hover:bg-slate-100">
                                <span className="text-sm font-medium text-slate-800">Configuración</span>
                                <Icons.Settings />
                            </button>
                            <button onClick={authUser ? onLogout : onLogin} className="w-full flex items-center justify-between px-3 py-2 rounded-xl border bg-indigo-50 hover:bg-indigo-100 text-indigo-800 font-semibold">
                                <span>{authUser ? 'Cerrar sesión Firebase' : 'Iniciar sesión Firebase'}</span>
                                <Icons.Cloud />
                            </button>
                            <button onClick={onSave} className="w-full flex items-center justify-between px-3 py-2 rounded-xl border bg-green-50 hover:bg-green-100 text-green-800 font-semibold">
                                <span>Guardar en Firestore</span>
                                <Icons.Check />
                            </button>
                            <button onClick={onLoad} className="w-full flex items-center justify-between px-3 py-2 rounded-xl border bg-blue-50 hover:bg-blue-100 text-blue-800 font-semibold">
                                <span>Cargar desde Firestore</span>
                                <Icons.Folder />
                            </button>
                        </div>

                        {status && (
                            <div className={`text-xs px-3 py-2 rounded-xl border ${statusColor}`}>
                                <p className="font-semibold">{status === 'loading' ? 'Procesando...' : status === 'success' ? 'Éxito' : 'Alerta'}</p>
                                <p>{message}</p>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // --- API GEMINI ---
        async function callGemini(apiKey, model, prompt, content) {
            if (!apiKey || apiKey.length < 10) throw new Error("Falta la API Key.");

            // Usar el modelo configurado
            const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
            const fullText = `${prompt}\n\n--- CONTENIDO ---\n${content}`;
            const payload = { contents: [{ parts: [{ text: fullText }] }] };

            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const data = await response.json();

                if (!response.ok) {
                    if (data.error?.code === 404) {
                        throw new Error(`Modelo '${model}' no encontrado. Revisa el nombre en Configuración.`);
                    }
                    throw new Error(data.error?.message || 'Error desconocido en la API');
                }

                return data.candidates?.[0]?.content?.parts?.[0]?.text || "No se generó respuesta.";
            } catch (error) {
                console.error("API Error:", error);
                throw error;
            }
        }

        // --- COMPONENTE PRINCIPAL ---
        function App() {
            const [books, setBooks] = useState([]);
            const [rootNotes, setRootNotes] = useState([]);
            const [settings, setSettings] = useState({
                apiKey: DEFAULT_API_KEY,
                model: DEFAULT_MODEL,
                prompts: { ...DEFAULT_PROMPTS }
            });
            const [dataLoaded, setDataLoaded] = useState(false);
            const [view, setView] = useState('home');
            const [activeBookId, setActiveBookId] = useState(null);
            const [activeChapterId, setActiveChapterId] = useState(null);
            const [loading, setLoading] = useState(false);
            const [testStatus, setTestStatus] = useState(null); // null, 'loading', 'success', 'error'
            const [testMsg, setTestMsg] = useState("");
            const [selectedBookIds, setSelectedBookIds] = useState([]);
            const [bookSelectionMode, setBookSelectionMode] = useState(false);
            const [activeSelectedBookId, setActiveSelectedBookId] = useState(null);
            const [selectedChapterIds, setSelectedChapterIds] = useState([]);
            const [chapterSelectionMode, setChapterSelectionMode] = useState(false);
            const [activeSelectedChapterId, setActiveSelectedChapterId] = useState(null);
            const [noteModal, setNoteModal] = useState({ open: false, target: null });
            const [noteDraft, setNoteDraft] = useState('<p></p>');
            const recognitionRef = useRef(null);
            const [recordingTarget, setRecordingTarget] = useState(null);
            const [isRecording, setIsRecording] = useState(false);
            const [micSupportError, setMicSupportError] = useState(null);
            const [picker, setPicker] = useState({ open: false, options: [], title: '', resolve: null });
            const [menuOpen, setMenuOpen] = useState(false);
            const [firebaseReady, setFirebaseReady] = useState(false);
            const [firebaseError, setFirebaseError] = useState(null);
            const [authUser, setAuthUser] = useState(null);
            const [cloudStatus, setCloudStatus] = useState(null);
            const [cloudMessage, setCloudMessage] = useState('');
            const [shouldBootstrapFromCloud, setShouldBootstrapFromCloud] = useState(false);
            const firebaseAppRef = useRef(null);
            const authRef = useRef(null);
            const dbRef = useRef(null);
            const autoSaveTimeoutRef = useRef(null);

            useEffect(() => {
                if (!window.firebase) {
                    setFirebaseError('Firebase SDK no está disponible.');
                    return;
                }
                try {
                    if (!firebase.apps.length) {
                        firebase.initializeApp(firebaseConfig);
                    }
                    firebaseAppRef.current = firebase.app();
                    authRef.current = firebase.auth();
                    dbRef.current = firebase.firestore();
                    setFirebaseReady(true);
                    const unsubscribe = authRef.current.onAuthStateChanged((user) => setAuthUser(user));
                    return () => unsubscribe?.();
                } catch (error) {
                    console.error('Firebase init error', error);
                    setFirebaseError(error.message);
                }
            }, []);

            useEffect(() => {
                const sessionId = sessionStorage.getItem(SESSION_KEY) || generateId();
                const hasLoadedThisSession = sessionStorage.getItem('voiceNotes_hasLoaded') === 'true';
                sessionStorage.setItem(SESSION_KEY, sessionId);
                sessionStorage.setItem('voiceNotes_hasLoaded', 'true');

                const savedBooks = localStorage.getItem('voiceNotes_books');
                const savedSettings = localStorage.getItem('voiceNotes_settings');
                if (savedBooks) {
                    const parsed = JSON.parse(savedBooks);
                    setBooks(normalizeBooksData(parsed));
                }
                const savedRoot = localStorage.getItem('voiceNotes_rootNotes');
                if (savedRoot) setRootNotes(JSON.parse(savedRoot));
                if (savedSettings) {
                    const parsed = JSON.parse(savedSettings);
                    setSettings({
                        apiKey: parsed.apiKey || DEFAULT_API_KEY,
                        model: parsed.model || DEFAULT_MODEL,
                        prompts: { ...DEFAULT_PROMPTS, ...(parsed.prompts || {}) }
                    });
                }

                const lastUse = parseInt(localStorage.getItem(LOCAL_USAGE_KEY) || '0', 10);
                const lastFirestoreSync = parseInt(localStorage.getItem(FIRESTORE_SYNC_KEY) || '0', 10);
                const navigationEntry = (performance.getEntriesByType?.('navigation') || [])[0];
                const isReload = navigationEntry?.type === 'reload' || performance?.navigation?.type === performance?.navigation?.TYPE_RELOAD;
                const now = Date.now();
                const isRecentUse = lastUse > 0 && (now - lastUse) < LOCAL_RECENCY_WINDOW_MS;
                const shouldLoadFromCloud = isReload || !isRecentUse || !lastFirestoreSync || !hasLoadedThisSession;
                setShouldBootstrapFromCloud(shouldLoadFromCloud);

                localStorage.setItem(LOCAL_USAGE_KEY, String(now));
                setDataLoaded(true);
            }, []);

            useEffect(() => { localStorage.setItem('voiceNotes_books', JSON.stringify(books)); }, [books]);
            useEffect(() => { localStorage.setItem('voiceNotes_settings', JSON.stringify(settings)); }, [settings]);
            useEffect(() => { localStorage.setItem('voiceNotes_rootNotes', JSON.stringify(rootNotes)); }, [rootNotes]);
            useEffect(() => {
                if (!dataLoaded) return;
                localStorage.setItem(LOCAL_USAGE_KEY, String(Date.now()));
            }, [books, rootNotes, settings, view, activeBookId, activeChapterId]);
            useEffect(() => {
                if (!dataLoaded) return;
                setBooks(prevBooks => {
                    let updatedBooks = [...prevBooks];
                    let changed = false;

                    const ensuredTemp = ensureTempBookAndChapter(updatedBooks);
                    updatedBooks = ensuredTemp.books;
                    changed = changed || ensuredTemp.changed;

                    for (let i = 0; i < updatedBooks.length; i++) {
                        const book = updatedBooks[i];
                        if ((book.notes || []).length === 0) continue;

                        const ensuredChapter = ensureTempChapterInBook(updatedBooks, book.id);
                        updatedBooks = ensuredChapter.books;

                        const refreshedBookIndex = updatedBooks.findIndex(b => b.id === book.id);
                        const refreshedBook = updatedBooks[refreshedBookIndex];
                        const tempChapterId = ensuredChapter.chapterId;
                        const migratedNotes = (refreshedBook.chapters.find(c => c.id === tempChapterId)?.notes || []).concat(book.notes);

                        updatedBooks[refreshedBookIndex] = {
                            ...refreshedBook,
                            notes: [],
                            chapters: refreshedBook.chapters.map(ch => ch.id === tempChapterId ? { ...ch, notes: migratedNotes } : ch)
                        };
                        changed = true;
                    }

                    return changed ? updatedBooks : prevBooks;
                });
            }, [dataLoaded]);

            useEffect(() => {
                if (!dataLoaded || rootNotes.length === 0) return;

                setBooks(prevBooks => {
                    const noteCopies = rootNotes.map(note => ({ ...note }));
                    const ensured = ensureTempBookAndChapter(prevBooks);
                    const { books: withTemp, tempBookId, tempChapterId } = ensured;

                    if (!tempBookId || !tempChapterId) return prevBooks;

                    return updateChapterNotesInBooks(
                        withTemp,
                        tempBookId,
                        tempChapterId,
                        (notes) => [...notes, ...noteCopies]
                    );
                });

                setRootNotes([]);
            }, [dataLoaded, rootNotes]);

            useEffect(() => {
                if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                    setMicSupportError("Navegador sin soporte de voz");
                }
                return () => { if (recognitionRef.current) recognitionRef.current.stop(); };
            }, []);

            // Helpers de navegación y datos
            const addBook = (title) => setBooks([...books, { id: generateId(), title, chapters: [], notes: [] }]);
            const renameBook = (id, title) => setBooks(books.map(b => b.id === id ? { ...b, title } : b));
            const deleteBook = (id) => setBooks(books.filter(b => b.id !== id));
            const reorderBooksByIndex = useCallback((from, to) => {
                setBooks(prev => moveItem(prev, from, to));
            }, []);
            const reorderBook = (id, direction) => {
                const index = books.findIndex(b => b.id === id);
                const target = index + direction;
                if (target < 0 || target >= books.length) return;
                setBooks(moveItem(books, index, target));
            };
            const moveBookToPosition = async (bookId) => {
                if (books.length < 2) return;
                const options = books
                    .filter(b => b.id !== bookId)
                    .map((b, idx) => ({ label: `Después de ${b.title}`, value: idx + 1 }));
                options.unshift({ label: 'Al inicio', value: 0 });
                const choice = await openPickerWithOptions(options, 'Mover libro');
                if (!choice || typeof choice.value !== 'number') return;
                const fromIndex = books.findIndex(b => b.id === bookId);
                const list = [...books];
                const [item] = list.splice(fromIndex, 1);
                let targetIndex = choice.value;
                if (targetIndex > fromIndex) targetIndex -= 1;
                list.splice(targetIndex, 0, item);
                setBooks(list);
            };
            const duplicateBook = (bookId) => {
                const book = books.find(b => b.id === bookId);
                if (!book) return;
                const copy = {
                    ...book,
                    id: generateId(),
                    title: `${book.title} (copia)`,
                    notes: (book.notes || []).map(cloneNote),
                    chapters: book.chapters.map(ch => ({
                        ...ch,
                        id: generateId(),
                        notes: ch.notes.map(cloneNote)
                    }))
                };
                setBooks([...books, copy]);
            };
            const addChapter = (bookId, title) => {
                setBooks(books.map(b => b.id === bookId ? { ...b, chapters: [...b.chapters, { id: generateId(), title, notes: [] }] } : b));
            };
            const renameChapter = (bookId, chapterId, title) => {
                setBooks(books.map(b => b.id === bookId ? { ...b, chapters: b.chapters.map(c => c.id === chapterId ? { ...c, title } : c) } : b));
            };
            const reorderChaptersByIndex = useCallback((bookId, from, to) => {
                setBooks(prev => prev.map(b => b.id === bookId ? { ...b, chapters: moveItem(b.chapters, from, to) } : b));
            }, []);
            const updateBookTempNotes = (bookId, updater) => {
                setBooks(prevBooks => {
                    const ensured = ensureTempChapterInBook(prevBooks, bookId);
                    if (!ensured.chapterId) return prevBooks;
                    return updateChapterNotesInBooks(ensured.books, bookId, ensured.chapterId, updater);
                });
            };

            const addNote = (bookId, chapterId, content) => {
                if (!content || !content.trim()) return;
                const cleanContent = normalizeContent(content);
                setBooks(books.map(b => b.id === bookId ? { ...b, chapters: b.chapters.map(c => c.id === chapterId ? { ...c, notes: [...c.notes, { id: generateId(), content: cleanContent, timestamp: Date.now() }] } : c) } : b));
            };

            const addBookNote = (bookId, content) => {
                if (!content || !content.trim()) return;
                const cleanContent = normalizeContent(content);
                const note = { id: generateId(), content: cleanContent, timestamp: Date.now() };
                updateBookTempNotes(bookId, (notes) => [...notes, note]);
            };

            const addRootNote = (content) => {
                if (!content || !content.trim()) return;
                const cleanContent = normalizeContent(content);
                const note = { id: generateId(), content: cleanContent, timestamp: Date.now() };

                setBooks(prevBooks => {
                    let updated = [...prevBooks];
                    const hasActiveBook = !!activeBookId && updated.some(b => b.id === activeBookId);

                    if (hasActiveBook) {
                        const ensured = ensureTempChapterInBook(updated, activeBookId);
                        if (!ensured.chapterId) return prevBooks;
                        updated = ensured.books;
                        return updateChapterNotesInBooks(updated, activeBookId, ensured.chapterId, (notes) => [...notes, note]);
                    }

                    const ensured = ensureTempBookAndChapter(updated);
                    if (!ensured.tempBookId || !ensured.tempChapterId) return prevBooks;
                    updated = ensured.books;
                    return updateChapterNotesInBooks(updated, ensured.tempBookId, ensured.tempChapterId, (notes) => [...notes, note]);
                });
            };

            const reorderRootNotesByIndex = useCallback((from, to) => {
                setRootNotes(prev => moveItem(prev, from, to));
            }, []);

            const reorderRootNote = (noteId, direction) => {
                const currentNotes = rootNotes;
                const index = currentNotes.findIndex(n => n.id === noteId);
                if (index < 0) return;
                const target = index + direction;
                if (target < 0 || target >= currentNotes.length) return;
                setRootNotes(prev => moveItem(prev, index, target));
            };
            const reorderBookNote = (bookId, noteId, direction) => {
                const book = books.find(b => b.id === bookId);
                if (!book) return;
                const index = book.notes?.findIndex(n => n.id === noteId) ?? -1;
                if (index < 0) return;
                const target = index + direction;
                if (target < 0 || !book.notes || target >= book.notes.length) return;
                updateBookNotes(bookId, moveItem(book.notes, index, target));
            };
            const reorderBookNotesByIndex = useCallback((bookId, from, to) => {
                setBooks(prev => prev.map(b => b.id === bookId ? { ...b, notes: moveItem(b.notes || [], from, to) } : b));
            }, []);
            const chooseDestination = async (source) => {
                const ensureDestinations = (currentBooks) => {
                    const ensuredTemp = ensureTempBookAndChapter(currentBooks);
                    let updatedBooks = ensuredTemp.books;
                    let changed = ensuredTemp.changed;

                    const ensuredPreliminary = ensurePreliminaryChaptersEverywhere(updatedBooks);
                    updatedBooks = ensuredPreliminary.books;
                    changed = changed || ensuredPreliminary.changed;

                    if (changed) setBooks(updatedBooks);
                    return updatedBooks;
                };

                const booksForOptions = ensureDestinations(books);
                const options = buildDestinations(booksForOptions, source);
                if (options.length === 0) { alert('No hay destinos disponibles.'); return null; }
                return await openPickerWithOptions(options, 'Elige dónde guardar');
            };
            const relocateNote = (source, destination, noteId, mode = 'move') => {
                const findNote = () => {
                    if (source.type === 'root') return rootNotes.find(n => n.id === noteId);
                    if (source.type === 'book') return books.find(b => b.id === source.bookId)?.notes?.find(n => n.id === noteId);
                    if (source.type === 'chapter') return books.find(b => b.id === source.bookId)?.chapters.find(c => c.id === source.chapterId)?.notes.find(n => n.id === noteId);
                    return null;
                };
                const note = findNote();
                if (!note) return;
                const noteForDestination = mode === 'copy' ? cloneNote(note) : note;

                if (destination.type === 'root') {
                    setRootNotes(notes => {
                        if (mode === 'move' && source.type === 'root') {
                            return [...notes.filter(n => n.id !== noteId), noteForDestination];
                        }
                        return [...notes, noteForDestination];
                    });
                }

                setBooks(prevBooks => prevBooks.map(book => {
                    let updatedBook = book;

                    // Eliminar del origen si corresponde
                    if (mode === 'move') {
                        if (source.type === 'book' && book.id === source.bookId) {
                            updatedBook = { ...updatedBook, notes: (updatedBook.notes || []).filter(n => n.id !== noteId) };
                        }
                        if (source.type === 'chapter' && book.id === source.bookId) {
                            updatedBook = {
                                ...updatedBook,
                                chapters: updatedBook.chapters.map(c => c.id === source.chapterId ? { ...c, notes: c.notes.filter(n => n.id !== noteId) } : c)
                            };
                        }
                    }

                    // Agregar al destino
                    if (destination.type === 'book' && book.id === destination.bookId) {
                        updatedBook = { ...updatedBook, notes: [...(updatedBook.notes || []), noteForDestination] };
                    }
                    if (destination.type === 'chapter' && book.id === destination.bookId) {
                        updatedBook = {
                            ...updatedBook,
                            chapters: updatedBook.chapters.map(c => c.id === destination.chapterId ? { ...c, notes: [...c.notes, noteForDestination] } : c)
                        };
                    }

                    return updatedBook;
                }));

                if (source.type === 'root' && mode === 'move' && destination.type !== 'root') setRootNotes(notes => notes.filter(n => n.id !== noteId));
            };
            const editNote = (bookId, chapterId, noteId, content) => {
                const cleanContent = normalizeContent(content);
                setBooks(books.map(b => b.id === bookId ? { ...b, chapters: b.chapters.map(c => c.id === chapterId ? { ...c, notes: c.notes.map(n => n.id === noteId ? { ...n, content: cleanContent } : n) } : c) } : b));
            };
            const updateNotes = (bookId, chapterId, newNotes) => {
                setBooks(books.map(b => b.id === bookId ? { ...b, chapters: b.chapters.map(c => c.id === chapterId ? { ...c, notes: newNotes } : c) } : b));
            };
            const updateBookNotes = (bookId, newNotes) => setBooks(books.map(b => b.id === bookId ? { ...b, notes: newNotes } : b));
            const updateBookChapters = (bookId, newChapters) => {
                setBooks(books.map(b => b.id === bookId ? { ...b, chapters: newChapters } : b));
            };
            const deleteChapter = (bookId, chapterId) => {
                setBooks(books.map(b => b.id === bookId ? { ...b, chapters: b.chapters.filter(c => c.id !== chapterId) } : b));
            };
            const reorderChapter = (bookId, chapterId, direction) => {
                const book = books.find(b => b.id === bookId);
                const index = book?.chapters.findIndex(c => c.id === chapterId);
                if (index === undefined || index < 0) return;
                const target = index + direction;
                if (target < 0 || !book || target >= book.chapters.length) return;
                const newChapters = moveItem(book.chapters, index, target);
                updateBookChapters(bookId, newChapters);
            };
            const copyChapterToBook = (sourceBookId, chapterId, targetBookId) => {
                const source = books.find(b => b.id === sourceBookId);
                const target = books.find(b => b.id === targetBookId);
                if (!source || !target) return;
                const chapter = source.chapters.find(c => c.id === chapterId);
                if (!chapter) return;
                const cloned = { ...chapter, id: generateId(), notes: chapter.notes.map(cloneNote) };
                setBooks(books.map(b => b.id === targetBookId ? { ...b, chapters: [...b.chapters, cloned] } : b));
            };
            const moveChapterToBook = (sourceBookId, chapterId, targetBookId) => {
                if (sourceBookId === targetBookId) return;
                const source = books.find(b => b.id === sourceBookId);
                const chapter = source?.chapters.find(c => c.id === chapterId);
                if (!chapter) return;
                const cleanedSource = source.chapters.filter(c => c.id !== chapterId);
                setBooks(books.map(b => {
                    if (b.id === sourceBookId) return { ...b, chapters: cleanedSource };
                    if (b.id === targetBookId) return { ...b, chapters: [...b.chapters, chapter] };
                    return b;
                }));
            };

            const resetMoveModes = () => {
                booksMoveMode.exitMoveMode();
                rootNotesMoveMode.exitMoveMode();
                bookNotesMoveMode.exitMoveMode();
                chaptersMoveMode.exitMoveMode();
                setBookSelectionMode(false);
                setSelectedBookIds([]);
                setActiveSelectedBookId(null);
                setChapterSelectionMode(false);
                setSelectedChapterIds([]);
                setActiveSelectedChapterId(null);
            };

            const goHome = () => { resetMoveModes(); setView('home'); setActiveBookId(null); setActiveChapterId(null); };
            const goBook = (id) => { resetMoveModes(); setActiveBookId(id); setView('book'); };
            const goChapter = (id) => { resetMoveModes(); setActiveChapterId(id); setView('chapter'); };
            const goSettings = () => setView('settings');

            const buildCloudPayload = () => ({
                books,
                rootNotes,
                settings,
                view,
                activeBookId,
                activeChapterId,
                timestamp: Date.now()
            });

            const handleFirebaseLogin = async () => {
                if (!firebaseReady || !authRef.current) {
                    return alert('Firebase no está listo aún.');
                }
                setCloudStatus('loading');
                setCloudMessage('Iniciando sesión...');
                try {
                    const provider = new firebase.auth.GoogleAuthProvider();
                    await authRef.current.signInWithPopup(provider);
                    setCloudStatus('success');
                    setCloudMessage('Sesión iniciada.');
                } catch (error) {
                    console.error('Firebase login error', error);
                    setCloudStatus('error');
                    setCloudMessage(error.message);
                }
            };

            const handleFirebaseLogout = async () => {
                if (!firebaseReady || !authRef.current) return;
                setCloudStatus('loading');
                setCloudMessage('Cerrando sesión...');
                try {
                    await authRef.current.signOut();
                    setCloudStatus('success');
                    setCloudMessage('Sesión cerrada.');
                } catch (error) {
                    setCloudStatus('error');
                    setCloudMessage(error.message);
                }
            };

            const handleFirestoreSave = async ({ silent = false } = {}) => {
                if (!firebaseReady || !dbRef.current) {
                    if (!silent) alert('Firebase no está listo.');
                    return;
                }
                if (!authUser) {
                    const message = 'Inicia sesión para guardar en Firestore.';
                    setCloudStatus('error');
                    setCloudMessage(message);
                    if (!silent) alert(message);
                    return;
                }
                setCloudStatus('loading');
                setCloudMessage(silent ? 'Guardado automático en progreso...' : 'Guardando en Firestore...');
                try {
                    const payload = buildCloudPayload();
                    await dbRef.current.collection(FIRESTORE_COLLECTION).doc(authUser.uid).set(payload);
                    const now = Date.now();
                    localStorage.setItem(FIRESTORE_SYNC_KEY, String(now));
                    localStorage.setItem(LOCAL_USAGE_KEY, String(now));
                    setCloudStatus('success');
                    setCloudMessage(silent ? 'Guardado automático completado.' : 'Datos guardados en Firestore.');
                } catch (error) {
                    console.error('Firestore save error', error);
                    setCloudStatus('error');
                    setCloudMessage(error.message);
                    if (!silent) alert(error.message);
                }
            };

            const handleFirestoreLoad = async ({ silent = false } = {}) => {
                if (!firebaseReady || !dbRef.current) {
                    if (!silent) alert('Firebase no está listo.');
                    return;
                }
                if (!authUser) {
                    const message = 'Inicia sesión para cargar datos.';
                    setCloudStatus('error');
                    setCloudMessage(message);
                    if (!silent) alert(message);
                    return;
                }
                setCloudStatus('loading');
                setCloudMessage(silent ? 'Sincronizando con Firestore...' : 'Cargando desde Firestore...');
                try {
                    const snap = await dbRef.current.collection(FIRESTORE_COLLECTION).doc(authUser.uid).get();
                    if (!snap.exists) {
                        setCloudStatus('error');
                        setCloudMessage('No hay datos guardados en Firestore.');
                        return;
                    }
                    const data = snap.data();
                    setBooks(normalizeBooksData(data.books || []));
                    setRootNotes(data.rootNotes || []);
                    setSettings({
                        apiKey: data.settings?.apiKey || DEFAULT_API_KEY,
                        model: data.settings?.model || DEFAULT_MODEL,
                        prompts: { ...DEFAULT_PROMPTS, ...(data.settings?.prompts || {}) }
                    });
                    setView(data.view || 'home');
                    setActiveBookId(data.activeBookId || null);
                    setActiveChapterId(data.activeChapterId || null);
                    setDataLoaded(true);
                    const now = data.timestamp || Date.now();
                    localStorage.setItem(FIRESTORE_SYNC_KEY, String(now));
                    localStorage.setItem(LOCAL_USAGE_KEY, String(Date.now()));
                    setCloudStatus('success');
                    setCloudMessage(silent ? 'Sincronización automática completada.' : 'Datos cargados desde Firestore.');
                } catch (error) {
                    console.error('Firestore load error', error);
                    setCloudStatus('error');
                    setCloudMessage(error.message);
                    if (!silent) alert(error.message);
                }
            };

            useEffect(() => {
                if (!shouldBootstrapFromCloud) return;
                if (!firebaseReady || !authUser) return;
                handleFirestoreLoad({ silent: true });
            }, [shouldBootstrapFromCloud, firebaseReady, authUser]);

            useEffect(() => {
                if (!dataLoaded) return;
                if (autoSaveTimeoutRef.current) clearTimeout(autoSaveTimeoutRef.current);

                autoSaveTimeoutRef.current = setTimeout(() => {
                    handleFirestoreSave({ silent: true });
                }, AUTO_FIRESTORE_SAVE_DELAY);

                return () => {
                    if (autoSaveTimeoutRef.current) clearTimeout(autoSaveTimeoutRef.current);
                };
            }, [books, rootNotes, settings, view, activeBookId, activeChapterId]);

            const promptForName = (message, defaultValue = '') => {
                const response = prompt(message, defaultValue ?? '');
                const trimmed = response?.trim();
                return trimmed ? trimmed : null;
            };

            const renameBookWithPrompt = (book) => {
                const newTitle = promptForName('Renombra el libro:', book?.title || '');
                if (!newTitle || !book?.id) return;
                renameBook(book.id, newTitle);
            };

            const renameChapterWithPrompt = (chapter) => {
                const newTitle = promptForName('Renombra el capítulo:', chapter?.title || '');
                if (!newTitle || !activeBookId || !chapter?.id) return;
                renameChapter(activeBookId, chapter.id, newTitle);
            };

            const startDictation = (target) => {
                if (micSupportError) return alert(micSupportError);
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                const recognition = new SpeechRecognition();
                recognition.lang = 'es-ES';
                recognition.continuous = false;
                recognition.onstart = () => setIsRecording(true);
                recognition.onresult = (e) => {
                    const transcript = e.results[0][0].transcript?.trim();
                    if (!transcript) return;
                    if (target.type === 'root') addRootNote(transcript);
                    if (target.type === 'book') addBookNote(target.bookId, transcript);
                };
                recognition.onerror = (event) => {
                    console.error(event);
                    setIsRecording(false);
                    setRecordingTarget(null);
                    if (event.error === 'not-allowed') alert("Permiso de micrófono denegado.");
                };
                recognition.onend = () => {
                    setIsRecording(false);
                    setRecordingTarget(null);
                };
                setRecordingTarget(target);
                recognition.start();
                recognitionRef.current = recognition;
            };

            const toggleDictation = (target) => {
                if (isRecording && recordingTarget?.type === target.type && recordingTarget?.bookId === target.bookId) {
                    recognitionRef.current?.stop();
                } else {
                    if (isRecording) recognitionRef.current?.stop();
                    startDictation(target);
                }
            };

            const openNoteModal = (target) => {
                setNoteDraft(target?.initialContent || '<p></p>');
                setNoteModal({ open: true, target });
            };
            const closeNoteModal = () => { setNoteDraft('<p></p>'); setNoteModal({ open: false, target: null }); };
            const handleSaveTypedNote = () => {
                const content = normalizeContent(noteDraft);
                const target = noteModal.target;
                if (!target?.onSave) return;
                target.onSave(content);
                closeNoteModal();
            };

            const closePicker = () => setPicker({ open: false, options: [], title: '', resolve: null });
            const openPickerWithOptions = (options, title = 'Selecciona destino') => new Promise((resolve) => {
                setPicker({ open: true, options, title, resolve });
            });
            const handlePickOption = (option) => {
                if (picker.resolve) picker.resolve(option);
                closePicker();
            };

            const activeBook = books.find(b => b.id === activeBookId);
            const activeChapter = activeBook?.chapters.find(c => c.id === activeChapterId);

            const pushAsLast = (list, id) => {
                const filtered = list.filter(item => item !== id);
                return [...filtered, id];
            };

            const booksMoveMode = useLongPressMoveMode(500, {
                onEnterMoveMode: (id) => {
                    setBookSelectionMode(true);
                    setSelectedBookIds((prev) => {
                        const updated = pushAsLast(prev, id);
                        setActiveSelectedBookId(id);
                        return updated;
                    });
                }
            });
            const rootNotesMoveMode = useLongPressMoveMode(500);
            const bookNotesMoveMode = useLongPressMoveMode(500);
            const chaptersMoveMode = useLongPressMoveMode(500, {
                onEnterMoveMode: (id) => {
                    setChapterSelectionMode(true);
                    setSelectedChapterIds((prev) => {
                        const updated = pushAsLast(prev, id);
                        setActiveSelectedChapterId(id);
                        return updated;
                    });
                }
            });

            const primaryBookId = selectedBookIds.includes(activeSelectedBookId)
                ? activeSelectedBookId
                : selectedBookIds[selectedBookIds.length - 1];
            const primaryChapterId = selectedChapterIds.includes(activeSelectedChapterId)
                ? activeSelectedChapterId
                : selectedChapterIds[selectedChapterIds.length - 1];
            const primaryChapter = activeBook?.chapters.find(c => c.id === primaryChapterId);

            const menuPortal = (
                <HamburgerMenu
                    open={menuOpen}
                    onClose={() => setMenuOpen(false)}
                    onSettings={() => { setMenuOpen(false); goSettings(); }}
                    onLogin={() => { setMenuOpen(false); handleFirebaseLogin(); }}
                    onLogout={() => { setMenuOpen(false); handleFirebaseLogout(); }}
                    onSave={() => { setMenuOpen(false); handleFirestoreSave(); }}
                    onLoad={() => { setMenuOpen(false); handleFirestoreLoad(); }}
                    authUser={authUser}
                    status={cloudStatus}
                    message={cloudMessage}
                    firebaseReady={firebaseReady}
                    firebaseError={firebaseError}
                />
            );

            const pickerPortal = <OptionPicker state={picker} onSelect={handlePickOption} onClose={() => handlePickOption(null)} />;

            // Componente de Pantalla de Carga
            if (loading) {
                return (
                    <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center backdrop-blur-sm">
                        <div className="bg-white p-6 rounded-xl shadow-2xl flex flex-col items-center">
                            <div className="loader mb-4"></div>
                            <p className="text-gray-700 font-medium">Procesando con IA...</p>
                        </div>
                    </div>
                );
            }

            // Header
            const Header = ({ title, onBack, accentClass = 'text-slate-900' }) => (
                <header
                    className="glass-panel safe-top sticky top-0 z-20 px-4 py-3 flex items-center justify-between border-b border-slate-200 shadow-sm"
                >
                    <div className="flex items-center gap-2 overflow-hidden">
                        {onBack && (
                            <button
                                onClick={onBack}
                                className="icon-btn text-slate-600 hover:text-slate-900"
                            >
                                <Icons.ChevronLeft />
                            </button>
                        )}
                        <div className="flex flex-col min-w-0">
                            <h1 className={`text-base font-semibold truncate ${accentClass}`}>
                                {title}
                            </h1>
                        </div>
                    </div>

                    <button
                        onClick={() => setMenuOpen(true)}
                        className="icon-btn text-slate-500 hover:text-blue-600"
                    >
                        <Icons.Menu />
                    </button>
                </header>
            );

            // --- VISTA: SETTINGS (Mejorada) ---
            if (view === 'settings') {
                const testConnection = async () => {
                    setTestStatus('loading');
                    try {
                        await callGemini(settings.apiKey, settings.model, "Di hola", "Test de conexión");
                        setTestStatus('success');
                        setTestMsg("¡Conexión Exitosa!");
                    } catch (e) {
                        setTestStatus('error');
                        setTestMsg(e.message);
                    }
                };

                return (
                    <>
                    <div className="min-h-screen bg-gradient-to-b from-indigo-50 via-blue-50 to-amber-50">
                        <Header title="Configuración" onBack={() => view === 'home' ? null : window.history.back() || goHome()} />
                        <div className="p-4 max-w-md mx-auto space-y-6">
                            
                            {/* Sección API */}
                            <div className="bg-white p-4 rounded-lg shadow space-y-4">
                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-1">Gemini API Key</label>
                                    <input type="text" value={settings.apiKey} onChange={(e) => setSettings({...settings, apiKey: e.target.value})}
                                        className="w-full p-2 border rounded-md bg-gray-50 text-sm font-mono focus:ring-2 focus:ring-blue-500 outline-none" placeholder="AIzaSy..." />
                                </div>

                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-1">Modelo (Model Name)</label>
                                    <div className="flex gap-2">
                                        <select 
                                            value={settings.model} 
                                            onChange={(e) => setSettings({...settings, model: e.target.value})}
                                            className="w-full p-2 border rounded-md bg-gray-50 text-sm focus:ring-2 focus:ring-blue-500 outline-none"
                                        >
                                            <option value="gemini-2.0-flash-exp">gemini-2.0-flash-exp (Predeterminado)</option>
                                            <option value="gemini-1.5-flash">gemini-1.5-flash (Estándar)</option>
                                            <option value="gemini-1.5-pro">gemini-1.5-pro (Más inteligente)</option>
                                            <option value="gemini-pro">gemini-pro (Legacy)</option>
                                        </select>
                                    </div>
                                    {/* Opción manual por si acaso */}
                                    <input 
                                        type="text" 
                                        value={settings.model}
                                        onChange={(e) => setSettings({...settings, model: e.target.value})}
                                        placeholder="Nombre manual del modelo..."
                                        className="w-full mt-2 p-2 border border-dashed rounded-md text-xs text-gray-500"
                                    />
                                </div>

                                <button onClick={testConnection} disabled={testStatus === 'loading'}
                                    className={`w-full py-2 px-4 rounded text-sm font-medium border transition flex items-center justify-center gap-2
                                    ${testStatus === 'success' ? 'bg-green-50 text-green-700 border-green-200' : 
                                      testStatus === 'error' ? 'bg-red-50 text-red-700 border-red-200' : 'bg-gray-100 text-gray-600 hover:bg-gray-200'}`}>
                                    {testStatus === 'loading' ? <div className="loader w-4 h-4 border-2 border-gray-400 border-t-transparent"></div> : 
                                     testStatus === 'success' ? <Icons.Check /> : 
                                     testStatus === 'error' ? <Icons.Alert /> : "Probar Conexión"}
                                    {testStatus === 'loading' ? ' Probando...' : testStatus === 'success' ? ' Conectado' : testStatus === 'error' ? ' Error' : ' Probar Conexión'}
                                </button>
                                {testMsg && <p className={`text-xs ${testStatus === 'error' ? 'text-red-600' : 'text-green-600'}`}>{testMsg}</p>}
                            </div>

                            {/* Sección Prompts */}
                            <div className="bg-white p-4 rounded-lg shadow">
                                <h3 className="font-medium text-gray-800 mb-3 border-b pb-2">Prompts</h3>
                                <div className="mb-4">
                                    <label className="block text-xs font-bold text-gray-500 uppercase mb-1">Fusión</label>
                                    <textarea value={settings.prompts.merge} onChange={(e) => setSettings({...settings, prompts: {...settings.prompts, merge: e.target.value}})}
                                        className="w-full p-2 border rounded-md bg-gray-50 text-sm h-20 resize-none" />
                                </div>
                                <div>
                                    <label className="block text-xs font-bold text-gray-500 uppercase mb-1">Estilo</label>
                                    <textarea value={settings.prompts.style} onChange={(e) => setSettings({...settings, prompts: {...settings.prompts, style: e.target.value}})}
                                        className="w-full p-2 border rounded-md bg-gray-50 text-sm h-20 resize-none" />
                                </div>
                                <div className="mt-4">
                                    <label className="block text-xs font-bold text-gray-500 uppercase mb-1">Generación de notas</label>
                                    <textarea value={settings.prompts.generate} onChange={(e) => setSettings({...settings, prompts: {...settings.prompts, generate: e.target.value}})}
                                        className="w-full p-2 border rounded-md bg-gray-50 text-sm h-20 resize-none" />
                                </div>
                            </div>

                            <button onClick={() => { if(activeChapterId) goChapter(activeChapterId); else if(activeBookId) goBook(activeBookId); else goHome(); }}
                                className="w-full py-3 bg-blue-600 text-white rounded-lg font-medium hover:bg-blue-700 transition shadow-lg">
                                Guardar y Salir
                            </button>
                        </div>
                    </div>
                    {menuPortal}
                    </>
                );
            }

            const toggleBookSelection = (id) => {
                setBookSelectionMode(true);
                setSelectedBookIds(prev => {
                    const updated = prev.includes(id)
                        ? prev.filter(b => b !== id)
                        : [...prev, id];
                    const preferred = updated.includes(id) ? id : activeSelectedBookId;
                    const nextPrimary = preferred && updated.includes(preferred)
                        ? preferred
                        : (updated[updated.length - 1] || null);
                    setActiveSelectedBookId(nextPrimary);
                    return updated;
                });
                booksMoveMode.exitMoveMode();
            };

            const toggleChapterSelection = (id) => {
                setChapterSelectionMode(true);
                setSelectedChapterIds(prev => {
                    const updated = prev.includes(id)
                        ? prev.filter(c => c !== id)
                        : [...prev, id];
                    const preferred = updated.includes(id) ? id : activeSelectedChapterId;
                    const nextPrimary = preferred && updated.includes(preferred)
                        ? preferred
                        : (updated[updated.length - 1] || null);
                    setActiveSelectedChapterId(nextPrimary);
                    return updated;
                });
                chaptersMoveMode.exitMoveMode();
            };

            const cancelBookSelection = () => {
                setBookSelectionMode(false);
                setSelectedBookIds([]);
                setActiveSelectedBookId(null);
                booksMoveMode.exitMoveMode();
            };

            const cancelChapterSelection = () => {
                setChapterSelectionMode(false);
                setSelectedChapterIds([]);
                setActiveSelectedChapterId(null);
                chaptersMoveMode.exitMoveMode();
            };

            const handleBookBulkDelete = () => {
                if (selectedBookIds.length === 0) return;
                if (!confirm('¿Eliminar libros seleccionados?')) return;
                setBooks(prev => prev.filter(b => !selectedBookIds.includes(b.id)));
                cancelBookSelection();
            };

            const handleChapterBulkDelete = () => {
                if (selectedChapterIds.length === 0) return;
                if (!confirm('¿Eliminar capítulos seleccionados?')) return;
                setBooks(prev => prev.map(b => b.id === activeBookId ? { ...b, chapters: b.chapters.filter(c => !selectedChapterIds.includes(c.id)) } : b));
                cancelChapterSelection();
            };

            const handleBookReorder = (direction) => {
                if (!primaryBookId) return;
                reorderBook(primaryBookId, direction);
            };

            const handleChapterReorder = (direction) => {
                if (!primaryChapterId) return;
                reorderChapter(activeBookId, primaryChapterId, direction);
            };

            const handleBookMoveToPosition = () => {
                if (!primaryBookId) return;
                moveBookToPosition(primaryBookId);
            };

            const handleDuplicateBook = () => {
                if (!primaryBookId) return;
                duplicateBook(primaryBookId);
            };

            const handleRenameBook = () => {
                if (!primaryBookId) return;
                const book = books.find(b => b.id === primaryBookId);
                if (!book) return;
                renameBookWithPrompt(book);
                cancelBookSelection();
            };

            const handleRenameChapter = () => {
                if (!primaryChapterId) return;
                const chapter = activeBook?.chapters.find(c => c.id === primaryChapterId);
                if (!chapter) return;
                renameChapterWithPrompt(chapter);
                cancelChapterSelection();
            };

            const handleChapterMoveOrCopy = async (mode) => {
                if (!primaryChapterId) return;
                const available = books.filter(b => b.id !== activeBookId);
                if (available.length === 0) return alert('No hay otros libros disponibles.');
                const choice = await openPickerWithOptions(available.map(b => ({ label: b.title, bookId: b.id })), mode === 'move' ? 'Mover a libro' : 'Copiar en libro');
                if (!choice?.bookId) return;
                if (mode === 'move') {
                    moveChapterToBook(activeBookId, primaryChapterId, choice.bookId);
                    cancelChapterSelection();
                } else {
                    copyChapterToBook(activeBookId, primaryChapterId, choice.bookId);
                }
            };

            if (view === 'home') {
                return (
                    <>
                    <div className="min-h-screen flex flex-col bg-gradient-to-b from-indigo-50 via-blue-50 to-amber-50">
                        <Header title="Mis Libros" accentClass="text-blue-800" />

                        <main className="flex-1 px-4 pt-4 pb-24 max-w-md mx-auto w-full">
                            {bookSelectionMode && (
                                <div className="mb-4 p-3 bg-white rounded-xl shadow border border-blue-100 space-y-2">
                                    <div className="flex items-center justify-between gap-2 flex-wrap">
                                        <span className="text-sm font-semibold text-blue-800">{selectedBookIds.length} seleccionados</span>
                                        <button onClick={cancelBookSelection} className="text-xs px-3 py-1.5 rounded-full bg-gray-100 text-gray-600 font-medium">Cancelar</button>
                                    </div>
                                    <div className="flex flex-wrap gap-2">
                                        <button disabled={!primaryBookId} onClick={handleBookMoveToPosition} className={`text-xs px-3 py-1.5 rounded-full border font-semibold ${primaryBookId ? 'bg-indigo-50 text-indigo-700 border-indigo-200' : 'bg-gray-50 text-gray-400 border-gray-200 cursor-not-allowed'}`}>Mover</button>
                                        <button disabled={!primaryBookId} onClick={handleRenameBook} className={`text-xs px-3 py-1.5 rounded-full border font-semibold ${primaryBookId ? 'bg-blue-100 text-blue-800 border-blue-200' : 'bg-gray-50 text-gray-400 border-gray-200 cursor-not-allowed'}`}>Renombrar</button>
                                        <button disabled={!primaryBookId} onClick={handleDuplicateBook} className={`text-xs px-3 py-1.5 rounded-full border font-semibold ${primaryBookId ? 'bg-purple-50 text-purple-700 border-purple-200' : 'bg-gray-50 text-gray-400 border-gray-200 cursor-not-allowed'}`}>Copiar</button>
                                        <button disabled={selectedBookIds.length === 0} onClick={handleBookBulkDelete} className={`text-xs px-3 py-1.5 rounded-full border font-semibold ${selectedBookIds.length > 0 ? 'bg-red-50 text-red-700 border-red-200' : 'bg-gray-50 text-gray-400 border-gray-200 cursor-not-allowed'}`}>Eliminar</button>
                                    </div>
                                </div>
                            )}
                            {books.length === 0 && (
                                <div className="text-center py-10 text-gray-400">
                                    <p>No tienes libros creados.</p>
                                </div>
                            )}

                            <div className="space-y-3 mt-4">
                                {books.map((book) => {
                                    const moveProps = booksMoveMode.getItemProps(book.id);
                                    const isSelected = selectedBookIds.includes(book.id);
                                    const showMoveControls = bookSelectionMode && primaryBookId === book.id;
                                    return (
                                    <div
                                        key={book.id}
                                        {...moveProps}
                                        onClick={(e) => {
                                            moveProps.onClick?.(e);
                                            if (e.defaultPrevented) return;
                                            if (bookSelectionMode) {
                                                toggleBookSelection(book.id);
                                            } else {
                                                goBook(book.id);
                                            }
                                        }}
                                        className={`card card-tap p-4 flex items-center gap-3 ${isSelected ? 'ring-2 ring-rose-200 bg-gradient-to-r from-indigo-50 via-rose-50 to-amber-50' : 'hover:shadow-lg'}`}
                                    >
                                        <button
                                            onClick={(e) => {
                                                e.stopPropagation();
                                                if (bookSelectionMode) {
                                                    toggleBookSelection(book.id);
                                                } else {
                                                    goBook(book.id);
                                                }
                                            }}
                                            className="flex-shrink-0 w-10 h-10 rounded-xl bg-gradient-to-br from-indigo-100 via-rose-100 to-amber-100 text-indigo-600 flex items-center justify-center shadow-inner"
                                        >
                                            <Icons.Book />
                                        </button>

                                        <div className="flex-1">
                                            <button
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    if (bookSelectionMode) {
                                                        toggleBookSelection(book.id);
                                                    } else {
                                                        goBook(book.id);
                                                    }
                                                }}
                                                className="w-full text-left"
                                            >
                                                <h3 className="font-semibold text-slate-900 text-sm truncate">
                                                    {book.title}
                                                </h3>
                                                <p className="text-xs text-slate-500">
                                                    {book.chapters.length} capítulos
                                                </p>
                                            </button>
                                        </div>

                                        {showMoveControls && (
                                            <div className="flex-shrink-0 flex items-center">
                                                <MoveControls
                                                    onMoveUp={() => reorderBook(book.id, -1)}
                                                    onMoveDown={() => reorderBook(book.id, 1)}
                                                    accentClass="text-blue-800"
                                                />
                                            </div>
                                        )}
                                    </div>
                                    );
                                })}
                            </div>

                            {rootNotes.length > 0 && (
                                <div className="space-y-2 mt-4">
                                    {rootNotes.map(note => {
                                        const moveProps = rootNotesMoveMode.getItemProps(note.id);
                                        return (
                                            <NoteChip
                                                key={note.id}
                                                note={note}
                                                moveHandlers={moveProps}
                                                moveModeActive={rootNotesMoveMode.moveModeId === note.id}
                                                actions={{
                                                    onEdit: () => openNoteModal({
                                                        title: 'Editar nota',
                                                        initialContent: note.content,
                                                        onSave: (html) => setRootNotes((notes) => notes.map(n => n.id === note.id ? { ...n, content: html } : n))
                                                    }),
                                                    onMoveUp: () => reorderRootNote(note.id, -1),
                                                    onMoveDown: () => reorderRootNote(note.id, 1)
                                                }}
                                            />
                                        );
                                    })}
                                </div>
                            )}

                            <div className="mt-6">
                                <button
                                    onClick={() => {
                                        const title = promptForName("Nuevo libro:");
                                        if (title) addBook(title);
                                    }}
                                    className="w-full flex items-center justify-center gap-2 bg-blue-700 text-white py-3 rounded-2xl font-medium shadow-lg hover:bg-blue-800 active:scale-[0.98] transition"
                                >
                                    <Icons.Plus />
                                    <span>Nuevo Libro</span>
                                </button>
                            </div>
                        </main>

                        <div className="fixed bottom-6 left-1/2 transform -translate-x-1/2 z-20 flex flex-col items-center gap-2">
                            {isRecording && recordingTarget?.type === 'root' && <p className="bg-black/70 text-white text-xs px-2 py-1 rounded whitespace-nowrap animate-pulse">Escuchando...</p>}
                            <div className="flex items-center gap-3 bg-white/85 backdrop-blur rounded-full shadow-lg border px-3 py-2">
                                <button onClick={() => openNoteModal({ title: 'Nueva nota rápida', onSave: (html) => addRootNote(html) })} className="w-12 h-12 rounded-full bg-blue-200 text-blue-900 flex items-center justify-center text-lg shadow hover:bg-blue-300" title="Escribir nota">
                                    📝
                                </button>
                                <button
                                    onClick={() => toggleDictation({ type: 'root' })}
                                    disabled={!!micSupportError}
                                    className={`w-16 h-16 rounded-full flex items-center justify-center shadow-2xl transition-all duration-300 text-white ${isRecording && recordingTarget?.type === 'root' ? 'bg-red-500 pulse-ring scale-110' : 'bg-blue-700 hover:bg-blue-800 hover:scale-105'} ${micSupportError ? 'bg-gray-400 cursor-not-allowed hover:scale-100 hover:bg-gray-400' : ''}`}
                                >
                                    {isRecording && recordingTarget?.type === 'root' ? <div className="w-6 h-6 bg-white rounded-sm" /> : <Icons.Mic />}
                                </button>
                            </div>
                        </div>

                        <NoteEditorModal
                            isOpen={noteModal.open}
                            title={noteModal.target?.title || 'Nueva nota'}
                            value={noteDraft}
                            onChange={setNoteDraft}
                            onSave={handleSaveTypedNote}
                            onClose={closeNoteModal}
                        />

                    </div>
                    {menuPortal}
                    {pickerPortal}
                    </>
                );
            }
            if (view === 'book' && activeBook) {
                const handleStyleBook = async () => {
                    if(activeBook.chapters.length === 0) return alert("Libro vacío.");
                    const styleDesc = prompt("Describe el estilo para todo el libro:");
                    if (!styleDesc) return;
                    setLoading(true);
                    try {
                        let newChapters = JSON.parse(JSON.stringify(activeBook.chapters));
                        for (let chapter of newChapters) {
                            if (chapter.notes.length === 0) continue;
                            const chapterText = chapter.notes.map(n => n.content).join("\n");
                            const finalPrompt = settings.prompts.style.replace('{STYLE}', styleDesc);
                            const newText = await callGemini(settings.apiKey, settings.model, finalPrompt, chapterText);
                            chapter.notes = [{ id: generateId(), content: normalizeContent(newText), timestamp: Date.now() }];
                        }
                        updateBookChapters(activeBook.id, newChapters);
                        alert("¡Libro reescrito!");
                    } catch (e) { alert("Error: " + e.message); } finally { setLoading(false); }
                };

                const handleGenerateBook = async () => {
                    if(activeBook.chapters.length === 0) return alert("Libro vacío.");
                    const promptText = prompt("¿Qué necesitas generar a partir del libro?");
                    if (!promptText) return;
                    setLoading(true);
                    try {
                        const bookContent = activeBook.chapters.map(ch => `Capítulo: ${ch.title}\n${ch.notes.map(n => n.content).join('\n')}`).join('\n\n');
                        const finalPrompt = `${settings.prompts.generate}\n\nPetición: ${promptText}`;
                        const newText = await callGemini(settings.apiKey, settings.model, finalPrompt, bookContent);
                        const newChapterId = generateId();
                        const newNoteId = generateId();
                        setBooks(books.map(b => b.id === activeBook.id ? {
                            ...b,
                            chapters: [...b.chapters, { id: newChapterId, title: `Generado ${new Date().toLocaleTimeString()}`, notes: [{ id: newNoteId, content: normalizeContent(newText), timestamp: Date.now() }] }]
                        } : b));
                        alert("Nueva nota generada y guardada en un capítulo nuevo.");
                    } catch (e) { alert("Error: " + e.message); } finally { setLoading(false); }
                };

                return (
                    <>
                    <div className="min-h-screen flex flex-col bg-gradient-to-b from-indigo-50 via-blue-50 to-cyan-50">
                        <Header title={activeBook.title} onBack={goHome} accentClass="text-violet-800" />
                        <main className="flex-1 px-4 pt-4 pb-24 max-w-md mx-auto w-full space-y-4">
                            <div className="flex flex-wrap items-center justify-between gap-2">
                                <button onClick={handleGenerateBook} className="text-xs flex items-center gap-2 bg-violet-100 text-violet-800 px-4 py-2 rounded-full font-semibold border border-violet-200 shadow-sm">💡 Generar resumen</button>
                                <button onClick={handleStyleBook} className="text-xs flex items-center gap-2 bg-violet-200 text-violet-900 px-4 py-2 rounded-full font-semibold border border-violet-300 shadow-sm"><Icons.Wand className="w-3 h-3" /> Estilo del libro</button>
                            </div>

                            {chapterSelectionMode && (
                                <div className="p-3 bg-white rounded-xl shadow border border-violet-100 space-y-2">
                                    <div className="flex items-center justify-between gap-2 flex-wrap">
                                        <span className="text-sm font-semibold text-violet-800">{selectedChapterIds.length} seleccionados</span>
                                        <button onClick={cancelChapterSelection} className="text-xs px-3 py-1.5 rounded-full bg-gray-100 text-gray-600 font-medium">Cancelar</button>
                                    </div>
                                    <div className="flex flex-wrap gap-2">
                                        <button disabled={!primaryChapterId} onClick={() => handleChapterMoveOrCopy('move')} className={`text-xs px-3 py-1.5 rounded-full border font-semibold ${primaryChapterId ? 'bg-indigo-50 text-indigo-700 border-indigo-200' : 'bg-gray-50 text-gray-400 border-gray-200 cursor-not-allowed'}`}>Mover de libro</button>
                                        <button disabled={!primaryChapterId} onClick={() => handleChapterMoveOrCopy('copy')} className={`text-xs px-3 py-1.5 rounded-full border font-semibold ${primaryChapterId ? 'bg-purple-50 text-purple-700 border-purple-200' : 'bg-gray-50 text-gray-400 border-gray-200 cursor-not-allowed'}`}>Copiar</button>
                                        <button disabled={!primaryChapterId} onClick={handleRenameChapter} className={`text-xs px-3 py-1.5 rounded-full border font-semibold ${primaryChapterId ? 'bg-violet-100 text-violet-900 border-violet-200' : 'bg-gray-50 text-gray-400 border-gray-200 cursor-not-allowed'}`}>Renombrar</button>
                                        <button disabled={selectedChapterIds.length === 0} onClick={handleChapterBulkDelete} className={`text-xs px-3 py-1.5 rounded-full border font-semibold ${selectedChapterIds.length > 0 ? 'bg-red-50 text-red-700 border-red-200' : 'bg-gray-50 text-gray-400 border-gray-200 cursor-not-allowed'}`}>Eliminar</button>
                                    </div>
                                </div>
                            )}

                            {activeBook.chapters.length === 0 && <div className="text-center py-10 text-gray-400"><p>Libro vacío.</p></div>}
                            <div className="space-y-3">
                                {activeBook.chapters.map((chap) => {
                                    const moveProps = chaptersMoveMode.getItemProps(chap.id);
                                    const isSelected = selectedChapterIds.includes(chap.id);
                                    const showMoveControls = chapterSelectionMode && primaryChapterId === chap.id;
                                    return (
                                    <div
                                        key={chap.id}
                                        {...moveProps}
                                        onClick={(e) => {
                                            moveProps.onClick?.(e);
                                            if (e.defaultPrevented) return;
                                            if (chapterSelectionMode) {
                                                toggleChapterSelection(chap.id);
                                            } else {
                                                goChapter(chap.id);
                                            }
                                        }}
                                        className={`card card-tap p-4 flex items-center gap-3 ${isSelected ? 'ring-2 ring-violet-300 bg-violet-50' : ''}`}
                                    >
                                        <button
                                            onClick={(e) => {
                                                e.stopPropagation();
                                                if (chapterSelectionMode) {
                                                    toggleChapterSelection(chap.id);
                                                } else {
                                                    goChapter(chap.id);
                                                }
                                            }}
                                            className="flex-shrink-0 w-10 h-10 rounded-xl bg-violet-100 text-violet-700 flex items-center justify-center"
                                        >
                                            <Icons.Folder />
                                        </button>

                                        <div className="flex-1">
                                            <button
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    if (chapterSelectionMode) {
                                                        toggleChapterSelection(chap.id);
                                                    } else {
                                                        goChapter(chap.id);
                                                    }
                                                }}
                                                className="w-full text-left"
                                            >
                                                <h3 className="font-semibold text-slate-900 text-sm truncate">
                                                    {chap.title}
                                                </h3>
                                                <p className="text-xs text-slate-500">
                                                    {chap.notes.length} notas
                                                </p>
                                            </button>
                                        </div>

                                        {showMoveControls && (
                                            <div className="flex-shrink-0 flex items-center">
                                                <MoveControls
                                                    onMoveUp={() => reorderChapter(activeBook.id, chap.id, -1)}
                                                    onMoveDown={() => reorderChapter(activeBook.id, chap.id, 1)}
                                                    accentClass="text-violet-800"
                                                />
                                            </div>
                                        )}
                                    </div>
                                    );
                                })}
                            </div>

                            {activeBook.notes?.length > 0 && (
                                <div className="space-y-2">
                                    {activeBook.notes.map(note => {
                                        const moveProps = bookNotesMoveMode.getItemProps(note.id);
                                        return (
                                            <NoteChip
                                                key={note.id}
                                                note={note}
                                                moveHandlers={moveProps}
                                                moveModeActive={bookNotesMoveMode.moveModeId === note.id}
                                                actions={{
                                                    onEdit: () => openNoteModal({
                                                        title: 'Editar nota',
                                                        initialContent: note.content,
                                                        onSave: (html) => updateBookNotes(activeBook.id, activeBook.notes.map(n => n.id === note.id ? { ...n, content: html } : n))
                                                    }),
                                                    onMoveUp: () => reorderBookNote(activeBook.id, note.id, -1),
                                                    onMoveDown: () => reorderBookNote(activeBook.id, note.id, 1)
                                                }}
                                            />
                                        );
                                    })}
                                </div>
                            )}

                            <div className="mt-6">
                                <button
                                    onClick={() => {
                                        const title = promptForName("Nuevo capítulo:");
                                        if (title) addChapter(activeBook.id, title);
                                    }}
                                    className="w-full flex items-center justify-center gap-2 bg-violet-700 text-white py-3 rounded-2xl font-medium shadow-lg hover:bg-violet-800 active:scale-[0.98] transition"
                                >
                                    <Icons.Plus />
                                    <span>Nuevo Capítulo</span>
                                </button>
                            </div>
                        </main>

                        <div className="fixed bottom-6 left-1/2 transform -translate-x-1/2 z-20 flex flex-col items-center gap-2">
                            {isRecording && recordingTarget?.bookId === activeBook.id && <p className="bg-black/70 text-white text-xs px-2 py-1 rounded whitespace-nowrap animate-pulse">Escuchando...</p>}
                            <div className="flex items-center gap-3 bg-white/85 backdrop-blur rounded-full shadow-lg border px-3 py-2">
                                <button onClick={() => openNoteModal({ title: 'Nueva nota del libro', onSave: (html) => addBookNote(activeBook.id, html) })} className="w-12 h-12 rounded-full bg-violet-200 text-violet-900 flex items-center justify-center text-lg shadow hover:bg-violet-300" title="Escribir nota del libro">
                                    📝
                                </button>
                                <button
                                    onClick={() => toggleDictation({ type: 'book', bookId: activeBook.id })}
                                    disabled={!!micSupportError}
                                    className={`w-16 h-16 rounded-full flex items-center justify-center shadow-2xl transition-all duration-300 text-white ${isRecording && recordingTarget?.bookId === activeBook.id ? 'bg-red-500 pulse-ring scale-110' : 'bg-violet-700 hover:bg-violet-800 hover:scale-105'} ${micSupportError ? 'bg-gray-400 cursor-not-allowed hover:scale-100 hover:bg-gray-400' : ''}`}
                                >
                                    {isRecording && recordingTarget?.bookId === activeBook.id ? <div className="w-6 h-6 bg-white rounded-sm" /> : <Icons.Mic />}
                                </button>
                            </div>
                        </div>

                        <NoteEditorModal
                            isOpen={noteModal.open}
                            title={noteModal.target?.title || 'Nota'}
                            value={noteDraft}
                            onChange={setNoteDraft}
                            onSave={handleSaveTypedNote}
                        onClose={closeNoteModal}
                    />

                </div>
                {menuPortal}
                {pickerPortal}
                </>
            );
        }

        if (view === 'chapter' && activeChapter) {
                return (
                    <>
                    <NoteManager bookId={activeBookId} chapter={activeChapter} onBack={() => goBook(activeBookId)}
                        onAddNote={(text) => addNote(activeBookId, activeChapter.id, text)}
                        onUpdateNotes={(newNotes) => updateNotes(activeBookId, activeChapter.id, newNotes)}
                        editNote={editNote}
                        settings={settings} setLoading={setLoading}
                        chooseDestination={chooseDestination}
                        relocateNote={relocateNote} />
                    {menuPortal}
                    {pickerPortal}
                    </>
                );
            }
            return null;
        }

        // --- NOTE MANAGER (Optimized) ---
        function NoteManager({ bookId, chapter, onBack, onAddNote, onUpdateNotes, editNote, settings, setLoading, chooseDestination, relocateNote }) {
            const [isRecording, setIsRecording] = useState(false);
            const [selectedIds, setSelectedIds] = useState([]);
            const [selectionMode, setSelectionMode] = useState(false);
            const [noteDraft, setNoteDraft] = useState('<p></p>');
            const [noteModalOpen, setNoteModalOpen] = useState(false);
            const [editingNoteId, setEditingNoteId] = useState(null);
            const recognitionRef = useRef(null);
            const [supportError, setSupportError] = useState(null);

            const reorderNotesByIndex = useCallback((from, to) => {
                onUpdateNotes(moveItem(chapter.notes, from, to));
            }, [chapter.notes, onUpdateNotes]);
            const noteMoveMode = useLongPressMoveMode(500, {
                onEnterMoveMode: (id) => {
                    setSelectionMode(true);
                    setSelectedIds((prev) => prev.includes(id) ? prev : [...prev, id]);
                }
            });

            useEffect(() => {
                if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) setSupportError("Navegador sin soporte de voz");
                return () => { if (recognitionRef.current) recognitionRef.current.stop(); }
            }, []);

            const startRecording = () => {
                if (supportError) return alert(supportError);
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                const recognition = new SpeechRecognition();
                recognition.lang = 'es-ES';
                recognition.continuous = false;
                recognition.onstart = () => setIsRecording(true);
                recognition.onresult = (event) => { if(event.results[0][0].transcript) onAddNote(event.results[0][0].transcript); };
                recognition.onerror = (event) => { console.error(event); setIsRecording(false); if(event.error === 'not-allowed') alert("Permiso de micrófono denegado."); };
                recognition.onend = () => setIsRecording(false);
                recognition.start();
                recognitionRef.current = recognition;
            };

            const toggleRecording = () => isRecording ? recognitionRef.current?.stop() : startRecording();
            const toggleSelect = (id) => setSelectedIds(prev => prev.includes(id) ? prev.filter(sid => sid !== id) : [...prev, id]);
            const handleSelectClick = (id) => {
                toggleSelect(id);
                noteMoveMode.activateMoveMode(id);
            };

            const openNoteModal = (note = null) => { setNoteDraft(note?.content || '<p></p>'); setEditingNoteId(note?.id || null); setNoteModalOpen(true); };
            const closeNoteModal = () => { setNoteDraft('<p></p>'); setEditingNoteId(null); setNoteModalOpen(false); };
            const saveTypedNote = () => {
                if (!noteDraft.trim()) return;
                if (editingNoteId) {
                    editNote(bookId, chapter.id, editingNoteId, noteDraft);
                } else {
                    onAddNote(noteDraft);
                }
                closeNoteModal();
            };

            const reorderNote = (id, direction) => {
                const index = chapter.notes.findIndex(n => n.id === id);
                const target = index + direction;
                if (target < 0 || target >= chapter.notes.length) return;
                onUpdateNotes(moveItem(chapter.notes, index, target));
            };

            const processAI = async (type, scope) => {
                const notes = scope === 'selection' ? chapter.notes.filter(n => selectedIds.includes(n.id)) : chapter.notes;
                if (notes.length === 0) return alert("Sin notas seleccionadas.");
                if (type === 'merge' && notes.length < 2) return alert("Selecciona 2+ notas.");

                const extraPrompt = type === 'style' ? prompt("Describe el estilo:") : type === 'generate' ? prompt("¿Qué necesitas generar?") : null;
                if ((type === 'style' || type === 'generate') && !extraPrompt) return;

                setLoading(true);
                try {
                    const text = notes.map(n => type === 'merge' ? `- ${n.content}` : n.content).join("\n\n");
                    let promptText = settings.prompts.merge;
                    if (type === 'style') promptText = settings.prompts.style.replace('{STYLE}', extraPrompt);
                    if (type === 'generate') promptText = `${settings.prompts.generate}\n\nPetición: ${extraPrompt}`;
                    const result = await callGemini(settings.apiKey, settings.model, promptText, text);

                    const newNote = { id: generateId(), content: normalizeContent(result), timestamp: Date.now() };
                    if (scope === 'selection') {
                        const remaining = chapter.notes.filter(n => !selectedIds.includes(n.id));
                        onUpdateNotes([...remaining, newNote]);
                        setSelectedIds([]); setSelectionMode(false);
                    } else {
                        onUpdateNotes([newNote]);
                    }
                } catch (e) { alert(e.message); } finally { setLoading(false); }
            };

            const deleteSelectedNotes = () => {
                if (selectedIds.length === 0) return;
                if (!confirm("¿Eliminar notas seleccionadas?")) return;
                onUpdateNotes(chapter.notes.filter(n => !selectedIds.includes(n.id)));
                setSelectedIds([]);
                setSelectionMode(false);
                noteMoveMode.exitMoveMode();
            };

            const concatenateSelectedNotes = () => {
                if (selectedIds.length < 2) return alert('Selecciona al menos 2 notas para concatenar.');

                const orderedSelectedNotes = chapter.notes.filter(n => selectedIds.includes(n.id));
                if (orderedSelectedNotes.length < 2) return;

                const concatenatedContent = orderedSelectedNotes
                    .map(note => `<div>${note.content}</div>`)
                    .join('');

                const newNote = { id: generateId(), content: concatenatedContent, timestamp: Date.now() };

                const mergedNotes = [];
                let inserted = false;
                chapter.notes.forEach(note => {
                    if (selectedIds.includes(note.id)) {
                        if (!inserted) {
                            mergedNotes.push(newNote);
                            inserted = true;
                        }
                        return;
                    }
                    mergedNotes.push(note);
                });

                onUpdateNotes(mergedNotes);
                setSelectedIds([]);
                setSelectionMode(false);
                noteMoveMode.exitMoveMode();
            };

            const bulkRelocate = async (mode) => {
                if (selectedIds.length === 0) return alert("Sin notas seleccionadas.");
                const destination = await chooseDestination({ type: 'chapter', bookId, chapterId: chapter.id });
                if (!destination) return;

                const isSameDestination = destination.type === 'chapter' && destination.bookId === bookId && destination.chapterId === chapter.id;
                if (isSameDestination) return alert('Elige un destino diferente.');

                selectedIds.forEach(id => relocateNote({ type: 'chapter', bookId, chapterId: chapter.id }, destination, id, mode));
                setSelectedIds([]);
                setSelectionMode(false);
                noteMoveMode.exitMoveMode();
            };

            return (
                <div className="min-h-screen flex flex-col bg-gradient-to-b from-indigo-50 via-blue-50 to-amber-50">
                    <header className="glass-panel sticky top-0 z-10 px-4 py-3 flex items-center justify-between border-b border-gray-200">
                        <div className="flex items-center gap-2">
                            <button onClick={onBack} className="p-1 rounded-full hover:bg-gray-100 text-gray-600"><Icons.ChevronLeft /></button>
                            <div className="overflow-hidden"><h1 className="text-lg font-bold text-emerald-800 truncate">{chapter.title}</h1><p className="text-xs text-gray-500 truncate">{selectedIds.length} seleccionadas</p></div>
                        </div>
                        <div className="flex items-center gap-2">
                            <button onClick={() => { setSelectionMode(!selectionMode); setSelectedIds([]); noteMoveMode.exitMoveMode(); }} className={`text-xs px-3 py-1.5 rounded-full font-medium transition ${selectionMode ? 'bg-emerald-100 text-emerald-700' : 'bg-gray-100 text-gray-600'}`}>{selectionMode ? 'Cancelar' : 'Seleccionar'}</button>
                            <button onClick={() => setMenuOpen(true)} className="icon-btn text-emerald-700 hover:text-emerald-900">
                                <Icons.Menu />
                            </button>
                        </div>
                    </header>

                    <main className="flex-1 p-4 pb-32 w-full max-w-md mx-auto">
                        <div className="mb-4 flex flex-col gap-2">
                            <div className="flex gap-2 overflow-x-auto pb-2 scrollbar-hide">
                                {selectionMode && selectedIds.length > 1 && <button onClick={() => processAI('merge', 'selection')} className="whitespace-nowrap text-xs flex items-center gap-1 bg-emerald-100 text-emerald-800 px-3 py-2 rounded-lg border border-emerald-200 font-medium active:scale-95 transition" title="Fusiona y reemplaza la selección por una sola nota"><Icons.Merge className="w-3 h-3" /> Fusionar</button>}
                                {selectionMode && selectedIds.length > 0 && <button onClick={() => processAI('style', 'selection')} className="whitespace-nowrap text-xs flex items-center gap-1 bg-emerald-50 text-emerald-700 px-3 py-2 rounded-lg border border-emerald-200 font-medium active:scale-95 transition"><Icons.Wand className="w-3 h-3" /> Estilo (Sel)</button>}
                                {selectionMode && selectedIds.length > 0 && <button onClick={() => processAI('generate', 'selection')} className="whitespace-nowrap text-xs flex items-center gap-1 bg-emerald-200 text-emerald-900 px-3 py-2 rounded-lg border border-emerald-300 font-medium active:scale-95 transition">💡 Generar</button>}
                                {!selectionMode && chapter.notes.length > 0 && <>
                                    <button onClick={() => processAI('style', 'chapter')} className="whitespace-nowrap text-xs flex items-center gap-1 bg-emerald-50 text-emerald-700 px-3 py-2 rounded-lg border border-emerald-200 font-medium active:scale-95 transition"><Icons.Wand className="w-3 h-3" /> Estilo (Todo)</button>
                                    <button onClick={() => processAI('generate', 'chapter')} className="whitespace-nowrap text-xs flex items-center gap-1 bg-emerald-200 text-emerald-900 px-3 py-2 rounded-lg border border-emerald-300 font-medium active:scale-95 transition">💡 Generar capítulo</button>
                                </>}
                            </div>
                            {selectionMode && selectedIds.length > 0 && (
                                <div className="flex gap-2 overflow-x-auto pb-2 scrollbar-hide">
                                    <button onClick={deleteSelectedNotes} className="whitespace-nowrap text-xs flex items-center gap-1 bg-red-50 text-red-700 px-3 py-2 rounded-lg border border-red-200 font-medium active:scale-95 transition"><Icons.Trash className="w-3 h-3" /> Eliminar</button>
                                    <button onClick={() => bulkRelocate('move')} className="whitespace-nowrap text-xs flex items-center gap-1 bg-gradient-to-r from-indigo-50 to-cyan-50 text-blue-700 px-3 py-2 rounded-lg border border-blue-200 font-medium active:scale-95 transition"><Icons.Folder className="w-3 h-3" /> Mover</button>
                                    <button onClick={() => bulkRelocate('copy')} className="whitespace-nowrap text-xs flex items-center gap-1 bg-purple-50 text-purple-700 px-3 py-2 rounded-lg border border-purple-200 font-medium active:scale-95 transition"><Icons.Plus className="w-3 h-3" /> Duplicar</button>
                                    {selectedIds.length > 1 && (
                                        <button
                                            onClick={concatenateSelectedNotes}
                                            className="whitespace-nowrap text-xs flex items-center gap-1 bg-amber-50 text-amber-800 px-3 py-2 rounded-lg border border-amber-200 font-medium active:scale-95 transition"
                                        >
                                            <Icons.Merge className="w-3 h-3" /> Concatenar
                                        </button>
                                    )}
                                </div>
                            )}
                        </div>

                        {chapter.notes.length === 0 && <div className="flex flex-col items-center justify-center h-64 text-gray-400"><Icons.Mic className="w-12 h-12 mb-2 opacity-20" /><p>Graba una nota</p></div>}

                        <div className="space-y-3">
                            {chapter.notes.map(note => {
                                const moveProps = noteMoveMode.getItemProps(note.id);
                                        const baseActions = {
                                            onMoveUp: () => reorderNote(note.id, -1),
                                            onMoveDown: () => reorderNote(note.id, 1),
                                        };
                                        return (
                                            <NoteChip
                                                key={note.id}
                                                note={note}
                                                moveHandlers={moveProps}
                                                moveModeActive={noteMoveMode.moveModeId === note.id}
                                                selectionMode={selectionMode}
                                                isSelected={selectedIds.includes(note.id)}
                                                onCardClick={selectionMode ? () => handleSelectClick(note.id) : undefined}
                                                collapsed
                                                actions={selectionMode ? baseActions : {
                                                    ...baseActions,
                                                    onEdit: () => openNoteModal(note)
                                                }}
                                            />
                                        );
                                    })}
                        </div>
                    </main>

                    <div className="fixed bottom-6 left-1/2 transform -translate-x-1/2 z-20 flex flex-col items-center gap-2">
                        {isRecording && <p className="bg-black/70 text-white text-xs px-2 py-1 rounded whitespace-nowrap animate-pulse">Escuchando...</p>}
                        <div className="flex items-center gap-3 bg-white/85 backdrop-blur rounded-full shadow-xl border border-white/60 px-3 py-2 shadow-indigo-100">
                            <button onClick={openNoteModal} className="w-12 h-12 rounded-full bg-gradient-to-br from-amber-200 via-rose-200 to-indigo-200 text-emerald-900 flex items-center justify-center text-lg shadow-md hover:shadow-lg hover:scale-105 transition" title="Escribir nota">
                                📝
                            </button>
                            <button onClick={toggleRecording} disabled={!!supportError} className={`w-16 h-16 rounded-full flex items-center justify-center shadow-2xl transition-all duration-300 text-white ${isRecording ? 'bg-gradient-to-br from-rose-500 via-red-500 to-orange-400 pulse-ring scale-110' : 'bg-gradient-to-br from-indigo-600 via-purple-600 to-blue-600 hover:scale-105 hover:shadow-indigo-300/50'} ${supportError ? 'bg-gray-400 cursor-not-allowed' : ''}`}>
                                {isRecording ? <div className="w-6 h-6 bg-white rounded-sm shadow-sm" /> : <Icons.Mic className="text-white" />}
                            </button>
                        </div>
                    </div>

                    <NoteEditorModal
                        isOpen={noteModalOpen}
                        title={editingNoteId ? 'Editar nota' : 'Añadir nota escrita'}
                        value={noteDraft}
                        onChange={setNoteDraft}
                        onSave={saveTypedNote}
                        onClose={closeNoteModal}
                    />
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
