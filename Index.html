<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>VoiceNotes AI Manager</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel para JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        /* Estilos base y utilidades */
        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: #f3f4f6;
            -webkit-tap-highlight-color: transparent;
        }
        
        /* Animación de carga */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Animación de grabación */
        .pulse-ring {
            box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
            animation: pulse-red 1.5s infinite cubic-bezier(0.66, 0, 0, 1);
        }
        @keyframes pulse-red {
            to { box-shadow: 0 0 0 15px rgba(239, 68, 68, 0); }
        }

        /* Scrollbar bonita */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        
        .glass-panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- ICONOS SVG ---
        const Icons = {
            Book: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></svg>,
            Folder: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg>,
            Mic: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>,
            MicOff: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="1" y1="1" x2="23" y2="23"></line><path d="M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6"></path><path d="M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>,
            Settings: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.72v-.51a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>,
            ChevronLeft: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="15 18 9 12 15 6"/></svg>,
            Plus: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>,
            Wand: () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M15 4V2"/><path d="M15 16v-2"/><path d="M8 9h2"/><path d="M20 9h2"/><path d="M17.8 11.8 19 13"/><path d="M15 9h0"/><path d="M17.8 6.2 19 5"/><path d="M3 21l9-9"/><path d="M12.2 6.2 11 5"/></svg>,
            Merge: () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m8 6 4-4 4 4"/><path d="M12 2v10.3"/><path d="M12 12.3v9.3"/><path d="m8 18 4 4 4-4"/></svg>,
            Trash: () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>
        };

        // --- CONFIGURACIÓN INICIAL Y HELPERS ---
        const DEFAULT_API_KEY = "AIzaSyBHy7CI9Dr1oONZkqghOOguNGQts94BjvI"; 
        
        const DEFAULT_PROMPTS = {
            merge: "Combina las siguientes notas en un único texto coherente, bien estructurado y resumido. Usa Markdown para dar formato si es necesario.",
            style: "Reescribe el siguiente contenido aplicando estrictamente el siguiente estilo o tono: {STYLE}. Mantén la información original pero cambia la forma de expresarla."
        };

        const generateId = () => Date.now().toString(36) + Math.random().toString(36).substr(2);

        // --- API GEMINI ---
        async function callGemini(apiKey, prompt, content) {
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`;
            const fullText = `${prompt}\n\n--- CONTENIDO ---\n${content}`;
            const payload = { contents: [{ parts: [{ text: fullText }] }] };

            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const data = await response.json();
                if (!response.ok) throw new Error(data.error?.message || 'Error en la API de Gemini');
                return data.candidates?.[0]?.content?.parts?.[0]?.text || "No se generó respuesta.";
            } catch (error) {
                console.error("API Error:", error);
                throw error;
            }
        }

        // --- COMPONENTE PRINCIPAL ---
        function App() {
            const [books, setBooks] = useState([]);
            const [settings, setSettings] = useState({ apiKey: DEFAULT_API_KEY, prompts: { ...DEFAULT_PROMPTS } });
            const [view, setView] = useState('home'); // home, book, chapter, settings
            const [activeBookId, setActiveBookId] = useState(null);
            const [activeChapterId, setActiveChapterId] = useState(null);
            const [loading, setLoading] = useState(false);

            useEffect(() => {
                const savedBooks = localStorage.getItem('voiceNotes_books');
                const savedSettings = localStorage.getItem('voiceNotes_settings');
                if (savedBooks) setBooks(JSON.parse(savedBooks));
                if (savedSettings) setSettings(JSON.parse(savedSettings));
            }, []);

            useEffect(() => { localStorage.setItem('voiceNotes_books', JSON.stringify(books)); }, [books]);
            useEffect(() => { localStorage.setItem('voiceNotes_settings', JSON.stringify(settings)); }, [settings]);

            const addBook = (title) => setBooks([...books, { id: generateId(), title, chapters: [] }]);

            const addChapter = (bookId, title) => {
                const updatedBooks = books.map(b => {
                    if (b.id === bookId) return { ...b, chapters: [...b.chapters, { id: generateId(), title, notes: [] }] };
                    return b;
                });
                setBooks(updatedBooks);
            };

            const addNote = (bookId, chapterId, content) => {
                if (!content || content.trim() === "") return;
                const cleanContent = content.charAt(0).toUpperCase() + content.slice(1).trim();
                
                const updatedBooks = books.map(b => {
                    if (b.id === bookId) {
                        const updatedChapters = b.chapters.map(c => {
                            if (c.id === chapterId) {
                                return { ...c, notes: [...c.notes, { id: generateId(), content: cleanContent, timestamp: Date.now() }] };
                            }
                            return c;
                        });
                        return { ...b, chapters: updatedChapters };
                    }
                    return b;
                });
                setBooks(updatedBooks);
            };

            const updateNotes = (bookId, chapterId, newNotes) => {
                const updatedBooks = books.map(b => {
                    if (b.id === bookId) {
                        const updatedChapters = b.chapters.map(c => {
                            if (c.id === chapterId) return { ...c, notes: newNotes };
                            return c;
                        });
                        return { ...b, chapters: updatedChapters };
                    }
                    return b;
                });
                setBooks(updatedBooks);
            };
            
             const updateBookChapters = (bookId, newChapters) => {
                const updatedBooks = books.map(b => b.id === bookId ? { ...b, chapters: newChapters } : b);
                setBooks(updatedBooks);
            };


            const goHome = () => { setView('home'); setActiveBookId(null); setActiveChapterId(null); };
            const goBook = (id) => { setActiveBookId(id); setView('book'); };
            const goChapter = (id) => { setActiveChapterId(id); setView('chapter'); };
            const goSettings = () => setView('settings');

            const activeBook = books.find(b => b.id === activeBookId);
            const activeChapter = activeBook?.chapters.find(c => c.id === activeChapterId);

            if (loading) {
                return (
                    <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center backdrop-blur-sm">
                        <div className="bg-white p-6 rounded-xl shadow-2xl flex flex-col items-center">
                            <div className="loader mb-4"></div>
                            <p className="text-gray-700 font-medium">Procesando con IA...</p>
                        </div>
                    </div>
                );
            }

            const Header = ({ title, onBack }) => (
                <header className="glass-panel sticky top-0 z-10 px-4 py-3 flex items-center justify-between border-b border-gray-200">
                    <div className="flex items-center gap-2">
                        {onBack && (
                            <button onClick={onBack} className="p-1 rounded-full hover:bg-gray-100 text-gray-600">
                                <Icons.ChevronLeft />
                            </button>
                        )}
                        <h1 className="text-lg font-bold text-gray-800 truncate max-w-[200px]">{title}</h1>
                    </div>
                    <button onClick={goSettings} className="p-2 text-gray-500 hover:text-blue-600">
                        <Icons.Settings />
                    </button>
                </header>
            );

            if (view === 'settings') {
                return (
                    <div className="min-h-screen bg-gray-50">
                        <Header title="Configuración" onBack={() => view === 'home' ? null : window.history.back() || goHome()} />
                        <div className="p-4 max-w-md mx-auto space-y-6">
                            <div className="bg-white p-4 rounded-lg shadow">
                                <label className="block text-sm font-medium text-gray-700 mb-1">Gemini API Key</label>
                                <input 
                                    type="text" 
                                    value={settings.apiKey}
                                    onChange={(e) => setSettings({...settings, apiKey: e.target.value})}
                                    className="w-full p-2 border rounded-md bg-gray-50 text-sm font-mono focus:ring-2 focus:ring-blue-500 outline-none"
                                />
                            </div>
                            <div className="bg-white p-4 rounded-lg shadow">
                                <h3 className="font-medium text-gray-800 mb-3 border-b pb-2">Prompts del Sistema</h3>
                                <div className="mb-4">
                                    <label className="block text-xs font-bold text-gray-500 uppercase mb-1">Fusión de Notas</label>
                                    <textarea 
                                        value={settings.prompts.merge}
                                        onChange={(e) => setSettings({...settings, prompts: {...settings.prompts, merge: e.target.value}})}
                                        className="w-full p-2 border rounded-md bg-gray-50 text-sm h-24 focus:ring-2 focus:ring-blue-500 outline-none resize-none"
                                    />
                                </div>
                                <div>
                                    <label className="block text-xs font-bold text-gray-500 uppercase mb-1">Cambio de Estilo</label>
                                    <textarea 
                                        value={settings.prompts.style}
                                        onChange={(e) => setSettings({...settings, prompts: {...settings.prompts, style: e.target.value}})}
                                        className="w-full p-2 border rounded-md bg-gray-50 text-sm h-24 focus:ring-2 focus:ring-blue-500 outline-none resize-none"
                                    />
                                </div>
                            </div>
                            <button onClick={() => { if(activeChapterId) goChapter(activeChapterId); else if(activeBookId) goBook(activeBookId); else goHome(); }}
                                className="w-full py-3 bg-blue-600 text-white rounded-lg font-medium hover:bg-blue-700 transition">
                                Guardar y Salir
                            </button>
                        </div>
                    </div>
                );
            }

            if (view === 'home') {
                return (
                    <div className="min-h-screen flex flex-col">
                        <Header title="Mis Libros" />
                        <main className="flex-1 p-4 max-w-md mx-auto w-full">
                            {books.length === 0 && <div className="text-center py-10 text-gray-400"><p>No tienes libros creados.</p></div>}
                            <div className="space-y-3">
                                {books.map(book => (
                                    <div key={book.id} onClick={() => goBook(book.id)} 
                                        className="bg-white p-4 rounded-xl shadow-sm border border-gray-100 flex items-center gap-3 active:scale-95 transition cursor-pointer">
                                        <div className="p-2 bg-blue-50 text-blue-600 rounded-lg"><Icons.Book /></div>
                                        <div className="flex-1"><h3 className="font-semibold text-gray-800">{book.title}</h3><p className="text-xs text-gray-500">{book.chapters.length} capítulos</p></div>
                                        <Icons.ChevronLeft className="rotate-180 text-gray-300 w-5 h-5" />
                                    </div>
                                ))}
                            </div>
                        </main>
                        <div className="p-4 bg-white border-t sticky bottom-0">
                            <button onClick={() => { const title = prompt("Nombre del nuevo libro:"); if (title) addBook(title); }} 
                                className="w-full flex items-center justify-center gap-2 bg-blue-600 text-white py-3 rounded-xl font-medium shadow-lg hover:bg-blue-700 transition">
                                <Icons.Plus /> Nuevo Libro
                            </button>
                        </div>
                    </div>
                );
            }

            if (view === 'book' && activeBook) {
                const handleStyleBook = async () => {
                    if(activeBook.chapters.length === 0) return alert("El libro está vacío.");
                    const styleDesc = prompt("Describe el estilo para reescribir TODO el libro:");
                    if (!styleDesc) return;

                    setLoading(true);
                    try {
                        let newChapters = JSON.parse(JSON.stringify(activeBook.chapters));
                        for (let chapter of newChapters) {
                            if (chapter.notes.length === 0) continue;
                            const chapterText = chapter.notes.map(n => n.content).join("\n");
                            const finalPrompt = settings.prompts.style.replace('{STYLE}', styleDesc);
                            const newText = await callGemini(settings.apiKey, finalPrompt, chapterText);
                            chapter.notes = [{ id: generateId(), content: newText, timestamp: Date.now() }];
                        }
                        updateBookChapters(activeBook.id, newChapters);
                        alert("¡Libro reescrito!");
                    } catch (e) { alert("Error: " + e.message); } finally { setLoading(false); }
                };

                return (
                    <div className="min-h-screen flex flex-col">
                        <Header title={activeBook.title} onBack={goHome} />
                        <main className="flex-1 p-4 max-w-md mx-auto w-full">
                            <div className="mb-4 flex justify-end">
                                <button onClick={handleStyleBook} className="text-xs flex items-center gap-1 bg-purple-50 text-purple-700 px-3 py-1.5 rounded-full font-medium hover:bg-purple-100 border border-purple-200">
                                    <Icons.Wand className="w-3 h-3" /> Estilo Libro
                                </button>
                            </div>
                            {activeBook.chapters.length === 0 && <div className="text-center py-10 text-gray-400"><p>Libro vacío.</p></div>}
                            <div className="space-y-3">
                                {activeBook.chapters.map(chap => (
                                    <div key={chap.id} onClick={() => goChapter(chap.id)}
                                        className="bg-white p-4 rounded-xl shadow-sm border border-gray-100 flex items-center gap-3 active:scale-95 transition cursor-pointer">
                                        <div className="p-2 bg-indigo-50 text-indigo-600 rounded-lg"><Icons.Folder /></div>
                                        <div className="flex-1"><h3 className="font-semibold text-gray-800">{chap.title}</h3><p className="text-xs text-gray-500">{chap.notes.length} notas</p></div>
                                        <Icons.ChevronLeft className="rotate-180 text-gray-300 w-5 h-5" />
                                    </div>
                                ))}
                            </div>
                        </main>
                        <div className="p-4 bg-white border-t sticky bottom-0">
                            <button onClick={() => { const title = prompt("Nombre del capítulo:"); if (title) addChapter(activeBook.id, title); }} 
                                className="w-full flex items-center justify-center gap-2 bg-indigo-600 text-white py-3 rounded-xl font-medium shadow-lg hover:bg-indigo-700 transition">
                                <Icons.Plus /> Nuevo Capítulo
                            </button>
                        </div>
                    </div>
                );
            }

            if (view === 'chapter' && activeChapter) {
                return <NoteManager 
                    bookId={activeBookId} chapter={activeChapter} onBack={() => goBook(activeBookId)}
                    onAddNote={(text) => addNote(activeBookId, activeChapter.id, text)}
                    onUpdateNotes={(newNotes) => updateNotes(activeBookId, activeChapter.id, newNotes)}
                    settings={settings} setLoading={setLoading}
                />;
            }
            return null;
        }

        // --- NOTE MANAGER ---
        function NoteManager({ bookId, chapter, onBack, onAddNote, onUpdateNotes, settings, setLoading }) {
            const [isRecording, setIsRecording] = useState(false);
            const [selectedIds, setSelectedIds] = useState([]);
            const [selectionMode, setSelectionMode] = useState(false);
            const recognitionRef = useRef(null);
            const [supportError, setSupportError] = useState(null);

            // --- INICIALIZACIÓN DE VOZ SEGURA ---
            useEffect(() => {
                // Verificar soporte al montar
                if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                    setSupportError("Navegador no compatible con Voz a Texto");
                }
                
                // Limpiar al desmontar
                return () => {
                    if (recognitionRef.current) {
                        recognitionRef.current.stop();
                        recognitionRef.current = null;
                    }
                }
            }, []);

            const startRecording = () => {
                if (supportError) return alert(supportError);

                // Crear instancia nueva cada vez para evitar conflictos de estado en móviles/safari
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                const recognition = new SpeechRecognition();
                
                recognition.lang = 'es-ES';
                recognition.continuous = false;
                recognition.interimResults = false;
                recognition.maxAlternatives = 1;

                recognition.onstart = () => {
                    setIsRecording(true);
                };

                recognition.onresult = (event) => {
                    const transcript = event.results[0][0].transcript;
                    if (transcript) {
                        onAddNote(transcript);
                    }
                };

                recognition.onerror = (event) => {
                    console.error("Speech API Error:", event.error);
                    setIsRecording(false);
                    
                    if (event.error === 'not-allowed') {
                        alert("ACCESO DENEGADO: El navegador bloqueó el micrófono. \n\nSi estás abriendo el archivo como 'file://', esto es normal por seguridad. \n\nSOLUCIÓN: Usa un servidor local (localhost) o un hosting HTTPS.");
                    } else if (event.error === 'network') {
                        alert("ERROR DE RED: El reconocimiento de voz requiere conexión a internet.");
                    } else if (event.error === 'no-speech') {
                        // Ignorar silencio
                    } else {
                        alert("Error de reconocimiento: " + event.error);
                    }
                };

                recognition.onend = () => {
                    setIsRecording(false);
                    recognitionRef.current = null;
                };

                try {
                    recognition.start();
                    recognitionRef.current = recognition;
                } catch (e) {
                    console.error("No se pudo iniciar el reconocimiento", e);
                    setIsRecording(false);
                }
            };

            const stopRecording = () => {
                if (recognitionRef.current) {
                    recognitionRef.current.stop();
                }
            };

            const toggleRecording = () => {
                if (isRecording) {
                    stopRecording();
                } else {
                    startRecording();
                }
            };

            const toggleSelect = (id) => {
                if (selectedIds.includes(id)) setSelectedIds(selectedIds.filter(sid => sid !== id));
                else setSelectedIds([...selectedIds, id]);
            };

            const handleMerge = async () => {
                if (selectedIds.length < 2) return alert("Selecciona al menos 2 notas.");
                setLoading(true);
                try {
                    const notesToMerge = chapter.notes.filter(n => selectedIds.includes(n.id));
                    const contentText = notesToMerge.map(n => `- ${n.content}`).join("\n");
                    const result = await callGemini(settings.apiKey, settings.prompts.merge, contentText);
                    const remainingNotes = chapter.notes.filter(n => !selectedIds.includes(n.id));
                    onUpdateNotes([...remainingNotes, { id: generateId(), content: result, timestamp: Date.now() }]);
                    setSelectedIds([]); setSelectionMode(false);
                } catch (e) { alert(e.message); } finally { setLoading(false); }
            };

            const handleStyle = async (scope) => {
                const notesToProcess = scope === 'selection' ? chapter.notes.filter(n => selectedIds.includes(n.id)) : chapter.notes;
                if (notesToProcess.length === 0) return alert("Sin notas.");
                const styleDesc = prompt("Describe el estilo:");
                if (!styleDesc) return;
                setLoading(true);
                try {
                    const contentText = notesToProcess.map(n => n.content).join("\n\n");
                    const finalPrompt = settings.prompts.style.replace('{STYLE}', styleDesc);
                    const result = await callGemini(settings.apiKey, finalPrompt, contentText);
                    if (scope === 'selection') {
                        const remaining = chapter.notes.filter(n => !selectedIds.includes(n.id));
                        onUpdateNotes([...remaining, { id: generateId(), content: result, timestamp: Date.now() }]);
                        setSelectedIds([]); setSelectionMode(false);
                    } else {
                        onUpdateNotes([{ id: generateId(), content: result, timestamp: Date.now() }]);
                    }
                } catch (e) { alert(e.message); } finally { setLoading(false); }
            };

            return (
                <div className="min-h-screen flex flex-col bg-gray-50">
                    <header className="glass-panel sticky top-0 z-10 px-4 py-3 flex items-center justify-between border-b border-gray-200">
                        <div className="flex items-center gap-2">
                            <button onClick={onBack} className="p-1 rounded-full hover:bg-gray-100 text-gray-600"><Icons.ChevronLeft /></button>
                            <div className="overflow-hidden"><h1 className="text-lg font-bold text-gray-800 truncate">{chapter.title}</h1><p className="text-xs text-gray-500 truncate">Selección: {selectedIds.length}</p></div>
                        </div>
                        <button onClick={() => { setSelectionMode(!selectionMode); setSelectedIds([]); }}
                            className={`text-xs px-3 py-1.5 rounded-full font-medium transition ${selectionMode ? 'bg-blue-100 text-blue-700' : 'bg-gray-100 text-gray-600'}`}>
                            {selectionMode ? 'Cancelar' : 'Seleccionar'}
                        </button>
                    </header>

                    <main className="flex-1 p-4 pb-32 w-full max-w-md mx-auto">
                        <div className="mb-4 flex gap-2 overflow-x-auto pb-2 scrollbar-hide">
                            {selectionMode && selectedIds.length > 1 && (
                                <button onClick={handleMerge} className="whitespace-nowrap text-xs flex items-center gap-1 bg-green-50 text-green-700 px-3 py-2 rounded-lg border border-green-200 font-medium active:scale-95 transition"><Icons.Merge className="w-3 h-3" /> Fusionar</button>
                            )}
                            {selectionMode && selectedIds.length > 0 && (
                                <button onClick={() => handleStyle('selection')} className="whitespace-nowrap text-xs flex items-center gap-1 bg-purple-50 text-purple-700 px-3 py-2 rounded-lg border border-purple-200 font-medium active:scale-95 transition"><Icons.Wand className="w-3 h-3" /> Estilo (Sel)</button>
                            )}
                            {!selectionMode && chapter.notes.length > 0 && (
                                <button onClick={() => handleStyle('chapter')} className="whitespace-nowrap text-xs flex items-center gap-1 bg-indigo-50 text-indigo-700 px-3 py-2 rounded-lg border border-indigo-200 font-medium active:scale-95 transition"><Icons.Wand className="w-3 h-3" /> Estilo (Todo)</button>
                            )}
                        </div>

                        {chapter.notes.length === 0 && (
                            <div className="flex flex-col items-center justify-center h-64 text-gray-400">
                                <Icons.Mic className="w-12 h-12 mb-2 opacity-20" />
                                <p>Graba tu primera nota</p>
                                {supportError && <p className="text-red-400 text-xs mt-2">{supportError}</p>}
                            </div>
                        )}

                        <div className="space-y-3">
                            {chapter.notes.map(note => (
                                <div key={note.id} onClick={() => selectionMode && toggleSelect(note.id)}
                                    className={`p-4 rounded-xl shadow-sm border transition relative ${selectedIds.includes(note.id) ? 'bg-blue-50 border-blue-400 ring-1 ring-blue-400' : 'bg-white border-gray-100'}`}>
                                    <p className="text-gray-800 text-sm leading-relaxed whitespace-pre-wrap">{note.content}</p>
                                    <div className="mt-2 flex justify-between items-center text-[10px] text-gray-400">
                                        <span>{new Date(note.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>
                                        {!selectionMode && (
                                            <button onClick={(e) => { e.stopPropagation(); if(confirm("¿Borrar nota?")) { const remaining = chapter.notes.filter(n => n.id !== note.id); onUpdateNotes(remaining); }}} className="text-gray-300 hover:text-red-500 p-1"><Icons.Trash /></button>
                                        )}
                                    </div>
                                </div>
                            ))}
                        </div>
                    </main>

                    <div className="fixed bottom-6 left-1/2 transform -translate-x-1/2 z-20 flex flex-col items-center gap-2">
                        {isRecording && <p className="bg-black/70 text-white text-xs px-2 py-1 rounded whitespace-nowrap animate-pulse">Escuchando...</p>}
                        <button onClick={toggleRecording} disabled={!!supportError}
                            className={`w-16 h-16 rounded-full flex items-center justify-center shadow-2xl transition-all duration-300 ${isRecording ? 'bg-red-500 pulse-ring scale-110' : 'bg-blue-600 hover:bg-blue-700 hover:scale-105'} ${supportError ? 'bg-gray-400 cursor-not-allowed' : ''}`}>
                            {isRecording ? <div className="w-6 h-6 bg-white rounded-sm" /> : <Icons.Mic className="text-white" />}
                        </button>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>


