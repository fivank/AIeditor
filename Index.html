<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>VoiceNotes AI Manager</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel para JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        /* Estilos base y utilidades */
        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: #f3f4f6;
            -webkit-tap-highlight-color: transparent;
        }
        
        /* Animación de carga */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Animación de grabación */
        .pulse-ring {
            box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
            animation: pulse-red 1.5s infinite cubic-bezier(0.66, 0, 0, 1);
        }
        @keyframes pulse-red {
            to { box-shadow: 0 0 0 15px rgba(239, 68, 68, 0); }
        }

        /* Scrollbar bonita */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        
        .glass-panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- ICONOS SVG ---
        const Icons = {
            Book: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></svg>,
            Folder: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg>,
            Mic: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>,
            Settings: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.72v-.51a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>,
            ChevronLeft: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="15 18 9 12 15 6"/></svg>,
            Plus: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>,
            Wand: () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M15 4V2"/><path d="M15 16v-2"/><path d="M8 9h2"/><path d="M20 9h2"/><path d="M17.8 11.8 19 13"/><path d="M15 9h0"/><path d="M17.8 6.2 19 5"/><path d="M3 21l9-9"/><path d="M12.2 6.2 11 5"/></svg>,
            Merge: () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m8 6 4-4 4 4"/><path d="M12 2v10.3"/><path d="M12 12.3v9.3"/><path d="m8 18 4 4 4-4"/></svg>,
            Trash: () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>,
            Check: () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="20 6 9 17 4 12"/></svg>,
            Alert: () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>
        };

        // --- CONFIGURACIÓN INICIAL ---
        const DEFAULT_API_KEY = "";
        const DEFAULT_MODEL = "gemini-2.0-flash";
        const DEFAULT_PROMPTS = {
            merge: "Combina las siguientes notas en un único texto coherente, bien estructurado y resumido. Usa Markdown solo si ayuda a la claridad.",
            style: "Reescribe el siguiente contenido aplicando estrictamente el siguiente estilo o tono: {STYLE}. Mantén la información original pero cambia la forma de expresarla sin añadir ideas.",
            generate: "Genera una nota basada en el contenido recibido y el prompt indicado. Respeta fielmente la información y evita inventar datos."
        };

        const generateId = () => Date.now().toString(36) + Math.random().toString(36).substr(2);

        // --- API GEMINI ---
        async function callGemini(apiKey, model, prompt, content) {
            if (!apiKey || apiKey.length < 10) throw new Error("Falta la API Key.");

            // Usar el modelo configurado
            const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
            const fullText = `${prompt}\n\n--- CONTENIDO ---\n${content}`;
            const payload = { contents: [{ parts: [{ text: fullText }] }] };

            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const data = await response.json();

                if (!response.ok) {
                    if (data.error?.code === 404) {
                        throw new Error(`Modelo '${model}' no encontrado. Revisa el nombre en Configuración.`);
                    }
                    throw new Error(data.error?.message || 'Error desconocido en la API');
                }

                return data.candidates?.[0]?.content?.parts?.[0]?.text || "No se generó respuesta.";
            } catch (error) {
                console.error("API Error:", error);
                throw error;
            }
        }

        // --- COMPONENTE PRINCIPAL ---
        function App() {
            const [books, setBooks] = useState([]);
            const [settings, setSettings] = useState({
                apiKey: DEFAULT_API_KEY,
                model: DEFAULT_MODEL,
                prompts: { ...DEFAULT_PROMPTS }
            });
            const [view, setView] = useState('home');
            const [activeBookId, setActiveBookId] = useState(null);
            const [activeChapterId, setActiveChapterId] = useState(null);
            const [loading, setLoading] = useState(false);
            const [testStatus, setTestStatus] = useState(null); // null, 'loading', 'success', 'error'
            const [testMsg, setTestMsg] = useState("");

            useEffect(() => {
                const savedBooks = localStorage.getItem('voiceNotes_books');
                const savedSettings = localStorage.getItem('voiceNotes_settings');
                if (savedBooks) setBooks(JSON.parse(savedBooks));
                if (savedSettings) {
                    const parsed = JSON.parse(savedSettings);
                    setSettings({
                        apiKey: parsed.apiKey || DEFAULT_API_KEY,
                        model: parsed.model || DEFAULT_MODEL,
                        prompts: { ...DEFAULT_PROMPTS, ...(parsed.prompts || {}) }
                    });
                }
            }, []);

            useEffect(() => { localStorage.setItem('voiceNotes_books', JSON.stringify(books)); }, [books]);
            useEffect(() => { localStorage.setItem('voiceNotes_settings', JSON.stringify(settings)); }, [settings]);

            // Helpers de navegación y datos
            const addBook = (title) => setBooks([...books, { id: generateId(), title, chapters: [] }]);
            const renameBook = (bookId, title) => setBooks(books.map(b => b.id === bookId ? { ...b, title } : b));
            const deleteBook = (bookId) => setBooks(books.filter(b => b.id !== bookId));
            const moveBook = (bookId, direction) => {
                const idx = books.findIndex(b => b.id === bookId);
                const newIdx = idx + direction;
                if (newIdx < 0 || newIdx >= books.length) return;
                const reordered = [...books];
                const [item] = reordered.splice(idx, 1);
                reordered.splice(newIdx, 0, item);
                setBooks(reordered);
            };
            const addChapter = (bookId, title) => {
                setBooks(books.map(b => b.id === bookId ? { ...b, chapters: [...b.chapters, { id: generateId(), title, notes: [] }] } : b));
            };
            const renameChapter = (bookId, chapterId, title) => {
                setBooks(books.map(b => b.id === bookId ? {
                    ...b,
                    chapters: b.chapters.map(c => c.id === chapterId ? { ...c, title } : c)
                } : b));
            };
            const deleteChapter = (bookId, chapterId) => {
                setBooks(books.map(b => b.id === bookId ? { ...b, chapters: b.chapters.filter(c => c.id !== chapterId) } : b));
            };
            const moveChapter = (bookId, chapterId, direction) => {
                const book = books.find(b => b.id === bookId);
                if (!book) return;
                const idx = book.chapters.findIndex(c => c.id === chapterId);
                const newIdx = idx + direction;
                if (newIdx < 0 || newIdx >= book.chapters.length) return;
                const reordered = [...book.chapters];
                const [item] = reordered.splice(idx, 1);
                reordered.splice(newIdx, 0, item);
                updateBookChapters(bookId, reordered);
            };
            const addNote = (bookId, chapterId, content) => {
                if (!content || !content.trim()) return;
                const cleanContent = content.charAt(0).toUpperCase() + content.slice(1).trim();
                setBooks(books.map(b => b.id === bookId ? { ...b, chapters: b.chapters.map(c => c.id === chapterId ? { ...c, notes: [...c.notes, { id: generateId(), content: cleanContent, timestamp: Date.now() }] } : c) } : b));
            };
            const updateNotes = (bookId, chapterId, newNotes) => {
                setBooks(books.map(b => b.id === bookId ? { ...b, chapters: b.chapters.map(c => c.id === chapterId ? { ...c, notes: newNotes } : c) } : b));
            };
            const updateBookChapters = (bookId, newChapters) => {
                setBooks(books.map(b => b.id === bookId ? { ...b, chapters: newChapters } : b));
            };
            const moveNotePosition = (bookId, chapterId, noteId, direction) => {
                const book = books.find(b => b.id === bookId);
                const chapter = book?.chapters.find(c => c.id === chapterId);
                if (!chapter) return;
                const idx = chapter.notes.findIndex(n => n.id === noteId);
                const newIdx = idx + direction;
                if (newIdx < 0 || newIdx >= chapter.notes.length) return;
                const reordered = [...chapter.notes];
                const [item] = reordered.splice(idx, 1);
                reordered.splice(newIdx, 0, item);
                updateNotes(bookId, chapterId, reordered);
            };
            const moveOrCopyNotes = (noteIds, sourceBookId, sourceChapterId, targetBookId, targetChapterId, copyOnly = false) => {
                if (!noteIds.length || !targetBookId || !targetChapterId) return;
                const sourceBook = books.find(b => b.id === sourceBookId);
                const targetBook = books.find(b => b.id === targetBookId);
                const sourceChapter = sourceBook?.chapters.find(c => c.id === sourceChapterId);
                const targetChapter = targetBook?.chapters.find(c => c.id === targetChapterId);
                if (!sourceChapter || !targetChapter) return;
                const movingNotes = sourceChapter.notes.filter(n => noteIds.includes(n.id)).map(n => copyOnly ? { ...n, id: generateId(), timestamp: Date.now() } : n);
                const newTargetNotes = [...targetChapter.notes, ...movingNotes];

                const updatedBooks = books.map(b => {
                    if (b.id === targetBookId) {
                        return { ...b, chapters: b.chapters.map(c => c.id === targetChapterId ? { ...c, notes: newTargetNotes } : c) };
                    }
                    return b;
                });

                if (!copyOnly) {
                    const remaining = sourceChapter.notes.filter(n => !noteIds.includes(n.id));
                    setBooks(updatedBooks.map(b => b.id === sourceBookId ? {
                        ...b,
                        chapters: b.chapters.map(c => c.id === sourceChapterId ? { ...c, notes: remaining } : c)
                    } : b));
                } else {
                    setBooks(updatedBooks);
                }
            };

            const goHome = () => { setView('home'); setActiveBookId(null); setActiveChapterId(null); };
            const goBook = (id) => { setActiveBookId(id); setView('book'); };
            const goChapter = (id) => { setActiveChapterId(id); setView('chapter'); };
            const goSettings = () => setView('settings');

            // Componente de Pantalla de Carga
            if (loading) {
                return (
                    <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center backdrop-blur-sm">
                        <div className="bg-white p-6 rounded-xl shadow-2xl flex flex-col items-center">
                            <div className="loader mb-4"></div>
                            <p className="text-gray-700 font-medium">Procesando con IA...</p>
                        </div>
                    </div>
                );
            }

            // Header
            const Header = ({ title, onBack }) => (
                <header className="glass-panel sticky top-0 z-10 px-4 py-3 flex items-center justify-between border-b border-gray-200">
                    <div className="flex items-center gap-2">
                        {onBack && <button onClick={onBack} className="p-1 rounded-full hover:bg-gray-100 text-gray-600"><Icons.ChevronLeft /></button>}
                        <h1 className="text-lg font-bold text-gray-800 truncate max-w-[200px]">{title}</h1>
                    </div>
                    <button onClick={goSettings} className="p-2 text-gray-500 hover:text-blue-600"><Icons.Settings /></button>
                </header>
            );

            // --- VISTA: SETTINGS (Mejorada) ---
            if (view === 'settings') {
                const testConnection = async () => {
                    setTestStatus('loading');
                    try {
                        await callGemini(settings.apiKey, settings.model, "Di hola", "Test de conexión");
                        setTestStatus('success');
                        setTestMsg("¡Conexión Exitosa!");
                    } catch (e) {
                        setTestStatus('error');
                        setTestMsg(e.message);
                    }
                };

                return (
                    <div className="min-h-screen bg-gray-50">
                        <Header title="Configuración" onBack={() => view === 'home' ? null : window.history.back() || goHome()} />
                        <div className="p-4 max-w-md mx-auto space-y-6">
                            
                            {/* Sección API */}
                            <div className="bg-white p-4 rounded-lg shadow space-y-4">
                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-1">Gemini API Key</label>
                                    <input type="text" value={settings.apiKey} onChange={(e) => setSettings({...settings, apiKey: e.target.value})}
                                        className="w-full p-2 border rounded-md bg-gray-50 text-sm font-mono focus:ring-2 focus:ring-blue-500 outline-none" placeholder="AIzaSy..." />
                                </div>

                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-1">Modelo (Model Name)</label>
                                    <div className="flex gap-2">
                                        <select 
                                            value={settings.model} 
                                            onChange={(e) => setSettings({...settings, model: e.target.value})}
                                            className="w-full p-2 border rounded-md bg-gray-50 text-sm focus:ring-2 focus:ring-blue-500 outline-none"
                                        >
                                            <option value="gemini-2.0-flash">gemini-2.0-flash (Por defecto)</option>
                                            <option value="gemini-1.5-flash">gemini-1.5-flash (Estándar)</option>
                                            <option value="gemini-1.5-pro">gemini-1.5-pro (Más inteligente)</option>
                                            <option value="gemini-2.0-flash-exp">gemini-2.0-flash-exp (Experimental)</option>
                                            <option value="gemini-pro">gemini-pro (Legacy)</option>
                                        </select>
                                    </div>
                                    {/* Opción manual por si acaso */}
                                    <input 
                                        type="text" 
                                        value={settings.model}
                                        onChange={(e) => setSettings({...settings, model: e.target.value})}
                                        placeholder="Nombre manual del modelo..."
                                        className="w-full mt-2 p-2 border border-dashed rounded-md text-xs text-gray-500"
                                    />
                                </div>

                                <button onClick={testConnection} disabled={testStatus === 'loading'}
                                    className={`w-full py-2 px-4 rounded text-sm font-medium border transition flex items-center justify-center gap-2
                                    ${testStatus === 'success' ? 'bg-green-50 text-green-700 border-green-200' : 
                                      testStatus === 'error' ? 'bg-red-50 text-red-700 border-red-200' : 'bg-gray-100 text-gray-600 hover:bg-gray-200'}`}>
                                    {testStatus === 'loading' ? <div className="loader w-4 h-4 border-2 border-gray-400 border-t-transparent"></div> : 
                                     testStatus === 'success' ? <Icons.Check /> : 
                                     testStatus === 'error' ? <Icons.Alert /> : "Probar Conexión"}
                                    {testStatus === 'loading' ? ' Probando...' : testStatus === 'success' ? ' Conectado' : testStatus === 'error' ? ' Error' : ' Probar Conexión'}
                                </button>
                                {testMsg && <p className={`text-xs ${testStatus === 'error' ? 'text-red-600' : 'text-green-600'}`}>{testMsg}</p>}
                            </div>

                            {/* Sección Prompts */}
                            <div className="bg-white p-4 rounded-lg shadow">
                                <h3 className="font-medium text-gray-800 mb-3 border-b pb-2">Prompts</h3>
                                <div className="mb-4">
                                    <label className="block text-xs font-bold text-gray-500 uppercase mb-1">Fusión</label>
                                    <textarea value={settings.prompts.merge} onChange={(e) => setSettings({...settings, prompts: {...settings.prompts, merge: e.target.value}})}
                                        className="w-full p-2 border rounded-md bg-gray-50 text-sm h-20 resize-none" />
                                </div>
                                <div className="mb-4">
                                    <label className="block text-xs font-bold text-gray-500 uppercase mb-1">Estilo</label>
                                    <textarea value={settings.prompts.style} onChange={(e) => setSettings({...settings, prompts: {...settings.prompts, style: e.target.value}})}
                                        className="w-full p-2 border rounded-md bg-gray-50 text-sm h-20 resize-none" />
                                </div>
                                <div>
                                    <label className="block text-xs font-bold text-gray-500 uppercase mb-1">Generación</label>
                                    <textarea value={settings.prompts.generate} onChange={(e) => setSettings({...settings, prompts: {...settings.prompts, generate: e.target.value}})}
                                        className="w-full p-2 border rounded-md bg-gray-50 text-sm h-20 resize-none" />
                                </div>
                            </div>

                            <button onClick={() => { if(activeChapterId) goChapter(activeChapterId); else if(activeBookId) goBook(activeBookId); else goHome(); }}
                                className="w-full py-3 bg-blue-600 text-white rounded-lg font-medium hover:bg-blue-700 transition shadow-lg">
                                Guardar y Salir
                            </button>
                        </div>
                    </div>
                );
            }

            const activeBook = books.find(b => b.id === activeBookId);
            const activeChapter = activeBook?.chapters.find(c => c.id === activeChapterId);

            if (view === 'home') {
                return (
                    <div className="min-h-screen flex flex-col">
                        <Header title="Mis Libros" />
                        <main className="flex-1 p-4 max-w-md mx-auto w-full">
                            {books.length === 0 && <div className="text-center py-10 text-gray-400"><p>No tienes libros creados.</p></div>}
                            <div className="space-y-3">
                                {books.map(book => (
                                    <div key={book.id} className="bg-white p-4 rounded-xl shadow-sm border border-gray-100 flex items-center gap-3">
                                        <div className="p-2 bg-blue-50 text-blue-600 rounded-lg"><Icons.Book /></div>
                                        <div onClick={() => goBook(book.id)} className="flex-1 cursor-pointer"><h3 className="font-semibold text-gray-800">{book.title}</h3><p className="text-xs text-gray-500">{book.chapters.length} capítulos</p></div>
                                        <div className="flex gap-1 text-xs">
                                            <button onClick={() => moveBook(book.id, -1)} className="px-2 py-1 bg-gray-100 rounded">↑</button>
                                            <button onClick={() => moveBook(book.id, 1)} className="px-2 py-1 bg-gray-100 rounded">↓</button>
                                            <button onClick={() => { const name = prompt("Renombrar libro", book.title); if(name) renameBook(book.id, name); }} className="px-2 py-1 bg-blue-50 text-blue-700 rounded">Renombrar</button>
                                            <button onClick={() => { if(confirm("¿Eliminar libro y todo su contenido?")) deleteBook(book.id); }} className="px-2 py-1 bg-red-50 text-red-600 rounded">Borrar</button>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </main>
                        <div className="p-4 bg-white border-t sticky bottom-0">
                            <button onClick={() => { const title = prompt("Nuevo libro:"); if (title) addBook(title); }} className="w-full flex items-center justify-center gap-2 bg-blue-600 text-white py-3 rounded-xl font-medium shadow-lg hover:bg-blue-700 transition"><Icons.Plus /> Nuevo Libro</button>
                        </div>
                    </div>
                );
            }

            if (view === 'book' && activeBook) {
                const handleStyleBook = async () => {
                    if(activeBook.chapters.length === 0) return alert("Libro vacío.");
                    const styleDesc = prompt("Describe el estilo para todo el libro:");
                    if (!styleDesc) return;
                    setLoading(true);
                    try {
                        let newChapters = JSON.parse(JSON.stringify(activeBook.chapters));
                        for (let chapter of newChapters) {
                            if (chapter.notes.length === 0) continue;
                            const chapterText = chapter.notes.map(n => n.content).join("\n");
                            const finalPrompt = settings.prompts.style.replace('{STYLE}', styleDesc);
                            const newText = await callGemini(settings.apiKey, settings.model, finalPrompt, chapterText);
                            chapter.notes = [{ id: generateId(), content: newText, timestamp: Date.now() }];
                        }
                        updateBookChapters(activeBook.id, newChapters);
                        alert("¡Libro reescrito!");
                    } catch (e) { alert("Error: " + e.message); } finally { setLoading(false); }
                };

                return (
                    <div className="min-h-screen flex flex-col">
                        <Header title={activeBook.title} onBack={goHome} />
                        <main className="flex-1 p-4 max-w-md mx-auto w-full">
                            <div className="mb-4 flex flex-wrap gap-2 justify-end">
                                <button onClick={handleStyleBook} className="text-xs flex items-center gap-1 bg-purple-50 text-purple-700 px-3 py-1.5 rounded-full font-medium border border-purple-200"><Icons.Wand className="w-3 h-3" /> Estilo Libro</button>
                                <button onClick={async () => {
                                    if(activeBook.chapters.length === 0) return alert("Crea un capítulo para guardar la nota generada.");
                                    const targetChapterId = prompt("ID de capítulo destino (o deja vacío para el primero):", activeBook.chapters[0]?.id || "");
                                    const chapterId = activeBook.chapters.find(c => c.id === targetChapterId)?.id || activeBook.chapters[0].id;
                                    const promptText = prompt("Indica qué nota generar (ej. índice, resumen, glosario):");
                                    if(!promptText) return;
                                    setLoading(true);
                                    try {
                                        const bookText = activeBook.chapters.map(c => `# ${c.title}\n${c.notes.map(n=>n.content).join('\n')}`).join('\n\n');
                                        const finalPrompt = settings.prompts.generate + `\n\nInstrucción del usuario: ${promptText}`;
                                        const result = await callGemini(settings.apiKey, settings.model, finalPrompt, bookText);
                                        addNote(activeBook.id, chapterId, result);
                                        alert("Nota generada para el libro");
                                    } catch(e){ alert(e.message);} finally { setLoading(false);} 
                                }} className="text-xs flex items-center gap-1 bg-green-50 text-green-700 px-3 py-1.5 rounded-full font-medium border border-green-200"><Icons.Merge className="w-3 h-3" /> Generar nota</button>
                            </div>
                            {activeBook.chapters.length === 0 && <div className="text-center py-10 text-gray-400"><p>Libro vacío.</p></div>}
                            <div className="space-y-3">
                                {activeBook.chapters.map(chap => (
                                    <div key={chap.id} className="bg-white p-4 rounded-xl shadow-sm border border-gray-100 flex items-center gap-3">
                                        <div className="p-2 bg-indigo-50 text-indigo-600 rounded-lg"><Icons.Folder /></div>
                                        <div onClick={() => goChapter(chap.id)} className="flex-1 cursor-pointer"><h3 className="font-semibold text-gray-800">{chap.title}</h3><p className="text-xs text-gray-500">{chap.notes.length} notas</p></div>
                                        <div className="flex gap-1 text-xs">
                                            <button onClick={() => moveChapter(activeBook.id, chap.id, -1)} className="px-2 py-1 bg-gray-100 rounded">↑</button>
                                            <button onClick={() => moveChapter(activeBook.id, chap.id, 1)} className="px-2 py-1 bg-gray-100 rounded">↓</button>
                                            <button onClick={() => { const name = prompt("Renombrar capítulo", chap.title); if(name) renameChapter(activeBook.id, chap.id, name); }} className="px-2 py-1 bg-blue-50 text-blue-700 rounded">Renombrar</button>
                                            <button onClick={() => { if(confirm("¿Eliminar capítulo y sus notas?")) deleteChapter(activeBook.id, chap.id); }} className="px-2 py-1 bg-red-50 text-red-600 rounded">Borrar</button>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </main>
                        <div className="p-4 bg-white border-t sticky bottom-0">
                            <button onClick={() => { const title = prompt("Nuevo capítulo:"); if (title) addChapter(activeBook.id, title); }} className="w-full flex items-center justify-center gap-2 bg-indigo-600 text-white py-3 rounded-xl font-medium shadow-lg hover:bg-indigo-700 transition"><Icons.Plus /> Nuevo Capítulo</button>
                        </div>
                    </div>
                );
            }

            if (view === 'chapter' && activeChapter) {
                return <NoteManager bookId={activeBookId} chapter={activeChapter} onBack={() => goBook(activeBookId)}
                    onAddNote={(text) => addNote(activeBookId, activeChapter.id, text)}
                    onUpdateNotes={(newNotes) => updateNotes(activeBookId, activeChapter.id, newNotes)}
                    onMoveNotePosition={(noteId, dir) => moveNotePosition(activeBookId, activeChapter.id, noteId, dir)}
                    onTransferNotes={(ids, destBookId, destChapterId, copyOnly) => moveOrCopyNotes(ids, activeBookId, activeChapter.id, destBookId, destChapterId, copyOnly)}
                    settings={settings} books={books} setLoading={setLoading} />;
            }
            return null;
        }

        // --- NOTE MANAGER (Optimized) ---
        function NoteManager({ bookId, chapter, onBack, onAddNote, onUpdateNotes, onMoveNotePosition, onTransferNotes, settings, books, setLoading }) {
            const [isRecording, setIsRecording] = useState(false);
            const [selectedIds, setSelectedIds] = useState([]);
            const [selectionMode, setSelectionMode] = useState(false);
            const recognitionRef = useRef(null);
            const [supportError, setSupportError] = useState(null);
            const [manualNote, setManualNote] = useState("");
            const [showTransfer, setShowTransfer] = useState(false);
            const [transferData, setTransferData] = useState({ bookId, chapterId: chapter.id, copy: false });

            useEffect(() => {
                if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) setSupportError("Navegador sin soporte de voz");
                return () => { if (recognitionRef.current) recognitionRef.current.stop(); }
            }, []);

            const startRecording = () => {
                if (supportError) return alert(supportError);
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                const recognition = new SpeechRecognition();
                recognition.lang = 'es-ES';
                recognition.continuous = false;
                recognition.onstart = () => setIsRecording(true);
                recognition.onresult = (event) => { if(event.results[0][0].transcript) onAddNote(event.results[0][0].transcript); };
                recognition.onerror = (event) => { console.error(event); setIsRecording(false); if(event.error === 'not-allowed') alert("Permiso de micrófono denegado."); };
                recognition.onend = () => setIsRecording(false);
                recognition.start();
                recognitionRef.current = recognition;
            };

            const toggleRecording = () => isRecording ? recognitionRef.current?.stop() : startRecording();
            const toggleSelect = (id) => setSelectedIds(prev => prev.includes(id) ? prev.filter(sid => sid !== id) : [...prev, id]);

            const processAI = async (type, scope) => {
                const notes = scope === 'selection' ? chapter.notes.filter(n => selectedIds.includes(n.id)) : chapter.notes;
                if (notes.length === 0) return alert("Sin notas seleccionadas.");
                if (type === 'merge' && notes.length < 2) return alert("Selecciona 2+ notas.");

                const extraPrompt = type === 'style' ? prompt("Describe el estilo:") : null;
                if (type === 'style' && !extraPrompt) return;
                const genPrompt = type === 'generate' ? prompt("¿Qué necesitas generar? (índice, resumen, glosario, etc.)") : null;
                if (type === 'generate' && !genPrompt) return;

                setLoading(true);
                try {
                    const text = notes.map(n => type === 'merge' ? `- ${n.content}` : n.content).join("\n\n");
                    const basePrompt = type === 'merge' ? settings.prompts.merge : type === 'style' ? settings.prompts.style.replace('{STYLE}', extraPrompt) : settings.prompts.generate + `\n\nInstrucción del usuario: ${genPrompt}`;
                    const promptText = basePrompt;
                    const result = await callGemini(settings.apiKey, settings.model, promptText, text);

                    const newNote = { id: generateId(), content: result, timestamp: Date.now() };
                    if (scope === 'selection') {
                        const remaining = chapter.notes.filter(n => !selectedIds.includes(n.id));
                        onUpdateNotes([...remaining, newNote]);
                        setSelectedIds([]); setSelectionMode(false);
                    } else {
                        if (type === 'style') {
                            onUpdateNotes([newNote]);
                        } else {
                            onUpdateNotes([...chapter.notes, newNote]);
                        }
                    }
                } catch (e) { alert(e.message); } finally { setLoading(false); }
            };

            return (
                <div className="min-h-screen flex flex-col bg-gray-50">
                    <header className="glass-panel sticky top-0 z-10 px-4 py-3 flex items-center justify-between border-b border-gray-200">
                        <div className="flex items-center gap-2">
                            <button onClick={onBack} className="p-1 rounded-full hover:bg-gray-100 text-gray-600"><Icons.ChevronLeft /></button>
                            <div className="overflow-hidden"><h1 className="text-lg font-bold text-gray-800 truncate">{chapter.title}</h1><p className="text-xs text-gray-500 truncate">{selectedIds.length} seleccionadas</p></div>
                        </div>
                        <button onClick={() => { setSelectionMode(!selectionMode); setSelectedIds([]); }} className={`text-xs px-3 py-1.5 rounded-full font-medium transition ${selectionMode ? 'bg-blue-100 text-blue-700' : 'bg-gray-100 text-gray-600'}`}>{selectionMode ? 'Cancelar' : 'Seleccionar'}</button>
                    </header>

                    <main className="flex-1 p-4 pb-32 w-full max-w-md mx-auto">
                        <div className="mb-4 flex gap-2 overflow-x-auto pb-2 scrollbar-hide">
                            {selectionMode && selectedIds.length > 1 && <button onClick={() => processAI('merge', 'selection')} className="whitespace-nowrap text-xs flex items-center gap-1 bg-green-50 text-green-700 px-3 py-2 rounded-lg border border-green-200 font-medium active:scale-95 transition"><Icons.Merge className="w-3 h-3" /> Fusionar</button>}
                            {selectionMode && selectedIds.length > 0 && <>
                                <button onClick={() => processAI('style', 'selection')} className="whitespace-nowrap text-xs flex items-center gap-1 bg-purple-50 text-purple-700 px-3 py-2 rounded-lg border border-purple-200 font-medium active:scale-95 transition"><Icons.Wand className="w-3 h-3" /> Estilo (Sel)</button>
                                <button onClick={() => processAI('generate', 'selection')} className="whitespace-nowrap text-xs flex items-center gap-1 bg-green-50 text-green-700 px-3 py-2 rounded-lg border border-green-200 font-medium active:scale-95 transition"><Icons.Plus className="w-3 h-3" /> Generar nota</button>
                                <button onClick={() => setShowTransfer(true)} className="whitespace-nowrap text-xs flex items-center gap-1 bg-blue-50 text-blue-700 px-3 py-2 rounded-lg border border-blue-200 font-medium active:scale-95 transition">Mover/Copiar</button>
                            </>}
                            {!selectionMode && chapter.notes.length > 0 && <>
                                <button onClick={() => processAI('style', 'chapter')} className="whitespace-nowrap text-xs flex items-center gap-1 bg-indigo-50 text-indigo-700 px-3 py-2 rounded-lg border border-indigo-200 font-medium active:scale-95 transition"><Icons.Wand className="w-3 h-3" /> Estilo (Todo)</button>
                                <button onClick={() => processAI('generate', 'chapter')} className="whitespace-nowrap text-xs flex items-center gap-1 bg-green-50 text-green-700 px-3 py-2 rounded-lg border border-green-200 font-medium active:scale-95 transition"><Icons.Plus className="w-3 h-3" /> Generar nota</button>
                            </>}
                        </div>

                        {chapter.notes.length === 0 && <div className="flex flex-col items-center justify-center h-64 text-gray-400"><Icons.Mic className="w-12 h-12 mb-2 opacity-20" /><p>Graba una nota</p></div>}

                        <div className="space-y-3">
                            {chapter.notes.map(note => (
                                <div key={note.id} onClick={() => selectionMode && toggleSelect(note.id)} className={`p-4 rounded-xl shadow-sm border transition relative ${selectedIds.includes(note.id) ? 'bg-blue-50 border-blue-400 ring-1 ring-blue-400' : 'bg-white border-gray-100'}`}>
                                    <p className="text-gray-800 text-sm leading-relaxed whitespace-pre-wrap">{note.content}</p>
                                    <div className="mt-2 flex justify-between items-center text-[10px] text-gray-400">
                                        <span>{new Date(note.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>
                                        {!selectionMode && <div className="flex gap-2 items-center text-gray-400">
                                            <button onClick={(e) => { e.stopPropagation(); const updated = prompt("Editar nota", note.content); if(updated !== null) onUpdateNotes(chapter.notes.map(n => n.id === note.id ? { ...n, content: updated.trim() } : n)); }} className="text-blue-500">Editar</button>
                                            <button onClick={(e) => { e.stopPropagation(); onMoveNotePosition(note.id, -1); }} className="px-2 py-1 bg-gray-100 rounded">↑</button>
                                            <button onClick={(e) => { e.stopPropagation(); onMoveNotePosition(note.id, 1); }} className="px-2 py-1 bg-gray-100 rounded">↓</button>
                                            <button onClick={(e) => { e.stopPropagation(); if(confirm("¿Borrar?")) onUpdateNotes(chapter.notes.filter(n => n.id !== note.id)); }} className="text-gray-300 hover:text-red-500 p-1"><Icons.Trash /></button>
                                        </div>}
                                    </div>
                                </div>
                            ))}
                        </div>
                    </main>

                    <div className="p-4 bg-white border-t shadow-inner">
                        <label className="text-xs text-gray-500">Añadir nota manual</label>
                        <textarea value={manualNote} onChange={(e)=>setManualNote(e.target.value)} className="w-full mt-1 p-2 border rounded-md bg-gray-50 text-sm" rows="3" placeholder="Escribe aquí..."></textarea>
                        <div className="flex justify-between mt-2">
                            <button onClick={() => { if(manualNote.trim()) { onAddNote(manualNote); setManualNote(""); } }} className="px-3 py-2 bg-blue-600 text-white rounded-lg text-sm">Guardar nota</button>
                            <button onClick={() => setManualNote("")} className="text-xs text-gray-500">Limpiar</button>
                        </div>
                    </div>

                    <div className="fixed bottom-6 left-1/2 transform -translate-x-1/2 z-20 flex flex-col items-center gap-2">
                        {isRecording && <p className="bg-black/70 text-white text-xs px-2 py-1 rounded whitespace-nowrap animate-pulse">Escuchando...</p>}
                        <button onClick={toggleRecording} disabled={!!supportError} className={`w-16 h-16 rounded-full flex items-center justify-center shadow-2xl transition-all duration-300 ${isRecording ? 'bg-red-500 pulse-ring scale-110' : 'bg-blue-600 hover:bg-blue-700 hover:scale-105'} ${supportError ? 'bg-gray-400 cursor-not-allowed' : ''}`}>
                            {isRecording ? <div className="w-6 h-6 bg-white rounded-sm" /> : <Icons.Mic className="text-white" />}
                        </button>
                    </div>

                    {showTransfer && (
                        <div className="fixed inset-0 bg-black/40 flex items-center justify-center z-30">
                            <div className="bg-white p-4 rounded-xl shadow-xl w-80 space-y-3">
                                <h3 className="font-semibold text-gray-800">Mover o copiar notas</h3>
                                <div>
                                    <label className="text-xs text-gray-500">Libro destino</label>
                                    <select className="w-full border rounded p-2 mt-1" value={transferData.bookId} onChange={(e)=>{
                                        const newBookId = e.target.value;
                                        const firstChapter = books.find(b => b.id === newBookId)?.chapters[0];
                                        setTransferData({ ...transferData, bookId: newBookId, chapterId: firstChapter?.id || '' });
                                    }}>
                                        {books.map(b => <option key={b.id} value={b.id}>{b.title}</option>)}
                                    </select>
                                </div>
                                <div>
                                    <label className="text-xs text-gray-500">Capítulo destino</label>
                                    <select className="w-full border rounded p-2 mt-1" value={transferData.chapterId} onChange={(e)=>setTransferData({...transferData, chapterId: e.target.value})}>
                                        {books.find(b => b.id === transferData.bookId)?.chapters.map(c => <option key={c.id} value={c.id}>{c.title}</option>)}
                                    </select>
                                </div>
                                <div className="flex items-center gap-2 text-sm">
                                    <input type="checkbox" id="copyMode" checked={transferData.copy} onChange={(e)=>setTransferData({...transferData, copy: e.target.checked})} />
                                    <label htmlFor="copyMode">Copiar en vez de mover</label>
                                </div>
                                <div className="flex justify-end gap-2 text-sm">
                                    <button onClick={()=>setShowTransfer(false)} className="px-3 py-2 bg-gray-100 rounded">Cancelar</button>
                                    <button onClick={()=>{
                                        if(!transferData.chapterId) return alert("Selecciona un capítulo destino");
                                        onTransferNotes(selectedIds, transferData.bookId, transferData.chapterId, transferData.copy);
                                        setShowTransfer(false); setSelectedIds([]); setSelectionMode(false);
                                    }} className="px-3 py-2 bg-blue-600 text-white rounded">Confirmar</button>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>


